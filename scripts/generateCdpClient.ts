/* eslint-disable @typescript-eslint/no-unsafe-assignment */
import { NodeOrTokenData } from '@typescript-eslint/types/dist/generated/ast-spec'
import { parse, TSESTree as ts } from '@typescript-eslint/typescript-estree'
import dedent from 'dedent'
import { readFile } from 'fs/promises'
import path from 'path'
import { format } from 'prettier'

import { ExpressionBuilder } from '@/codegen/estree'

const SCRIPT_BANNER = dedent`
  // This file is auto-generated by scripts/generateCdpClient.ts. DO NOT EDIT!

  /* eslint-disable @typescript-eslint/no-namespace */
  /* eslint-disable @typescript-eslint/no-unnecessary-type-assertion */
`

// eslint-disable-next-line @typescript-eslint/no-explicit-any
const baseNode: NodeOrTokenData & { parent: any } = {
  type: '',
  range: [0, 0],
  loc: {
    start: { line: 0, column: 0 },
    end: { line: 0, column: 0 },
  },
  parent: null,
}

const NodeType = ts.AST_NODE_TYPES

interface ProtocolTypeBase {
  id: string
  description?: string
}

const BASE_DEFINITIONS = parse(`
  let id = 0

  function generateId() {
    return ++id
  }

  type DisposeFn = () => void

  type ChromeEventListener<Event = unknown> = (event: ChromeEvent<Event>) => void

  export interface Transport {
    call<Return>(command: ChromeCommand): Promise<Return>;
 
    on(event: string, listener: ChromeEventListener): DisposeFn
    off(event: string, listener: ChromeEventListener): void
  } 

  export interface ChromeCommand {
    id: number;
    sessionId: string | undefined
    method: string;
    params: Record<string, unknown> 
  }
 
  export interface ChromeEvent<Event = unknown> {
    sessionId?: string
    name: string
    data: Event
  }
`)

interface ProtocolTypePrimitive extends ProtocolTypeBase {
  type: 'string' | 'boolean' | 'integer' | 'number' | 'unknown' | 'any'
}

interface ProtocolTypeEnum extends ProtocolTypeBase {
  type: 'string'
  enum: string[]
}

interface ProtocolTypeRef extends ProtocolTypeBase {
  $ref: string
}

interface ProtocolTypeArray extends ProtocolTypeBase {
  type: 'array'
  items: ProtocolType
}

interface ProtocolObjectPropertyBase {
  name: string
  description?: string
  optional?: boolean
}

interface ProtocolObjectPropertyRef extends ProtocolObjectPropertyBase {
  $ref: string
}

interface ProtocolObjectPropertyArray extends ProtocolObjectPropertyBase {
  type: 'array'
  items: ProtocolType
}

interface ProtocolObjectPropertyObject extends ProtocolObjectPropertyBase {
  type: 'object'
  properties?: ProtocolObjectProperty[]
}

interface ProtocolObjectPropertyType extends ProtocolObjectPropertyBase {
  type: 'string' | 'boolean' | 'integer' | 'number'
}

type ProtocolObjectProperty =
  | ProtocolObjectPropertyRef
  | ProtocolObjectPropertyType
  | ProtocolObjectPropertyArray
  | ProtocolObjectPropertyObject

interface ProtocolObjectType extends ProtocolTypeBase {
  type: 'object'
  properties?: ProtocolObjectProperty[]
}

type ProtocolType =
  | ProtocolTypeEnum
  | ProtocolTypePrimitive
  | ProtocolObjectType
  | ProtocolTypeRef
  | ProtocolTypeArray

interface ProtocolCommand {
  name: string
  description?: string
  parameters?: ProtocolObjectProperty[]
  returns?: ProtocolObjectProperty[]
}

interface ProtocolEvent {
  name: string
  parameters?: ProtocolObjectProperty[]
}

interface ProtocolDomain {
  domain: string
  types?: ProtocolType[]
  commands?: ProtocolCommand[]
  events?: ProtocolEvent[]
}

interface ProtocolDefinition {
  domains: ProtocolDomain[]
}

function identifier(
  name: string,
  type?: ts.TypeNode | [name: string, domain: string | undefined],
  optional = false
): ts.Identifier {
  const typeAnnotation: ts.TSTypeAnnotation | undefined = type && {
    ...baseNode,
    type: NodeType.TSTypeAnnotation,
    typeAnnotation: Array.isArray(type) ? toQualifiedName(...type) : type,
  }

  return {
    ...baseNode,
    type: NodeType.Identifier,
    name,
    decorators: [],
    optional,
    typeAnnotation,
  }
}

function string(value: string): ts.Literal {
  return {
    ...baseNode,
    type: NodeType.Literal,
    value,
    raw: JSON.stringify(value),
  }
}

function record(keyType: ts.TypeNode, valueType: ts.TypeNode): ts.TypeNode {
  return {
    ...baseNode,
    type: NodeType.TSTypeReference,
    typeName: identifier('Record'),
    typeArguments: {
      ...baseNode,
      type: NodeType.TSTypeParameterInstantiation,
      params: [keyType, valueType],
    },
  }
}

function toPrimitiveType(type: string): ts.TypeNode {
  switch (type) {
    case 'string':
      return {
        ...baseNode,
        type: NodeType.TSStringKeyword,
      }

    case 'boolean':
      return {
        ...baseNode,
        type: NodeType.TSBooleanKeyword,
      }

    case 'number':
    case 'integer':
      return {
        ...baseNode,
        type: NodeType.TSNumberKeyword,
      }

    case 'any':
      return {
        ...baseNode,
        type: NodeType.TSUnknownKeyword,
      }

    default:
      return {
        ...baseNode,
        type: NodeType.TSNeverKeyword,
      }
  }
}

function add(first: ts.Expression, ...rest: ts.Expression[]): ts.Expression {
  return rest.reduce((acc, expr) => {
    return {
      ...baseNode,
      type: NodeType.BinaryExpression,
      operator: '+',
      left: acc,
      right: expr,
    }
  }, first)
}

function escape(node: ts.Identifier): ts.Identifier {
  switch (node.name) {
    case 'arguments':
      return {
        ...node,
        name: node.name + '_',
      }

    default:
      return node
  }
}

class InterfaceBuilder {
  name: string

  typeParameters: ts.TSTypeParameter[] = []
  members: ts.TSPropertySignature[] = []

  constructor(name: string) {
    this.name = name
  }

  member(name: string, type: ts.TypeNode) {
    this.members.push(typeProperty(name, type))

    return this
  }

  done(): ts.TSInterfaceDeclaration {
    const typeParameters: ts.TSTypeParameterDeclaration = {
      ...baseNode,
      type: NodeType.TSTypeParameterDeclaration,
      params: this.typeParameters,
    }

    return {
      ...baseNode,
      type: NodeType.TSInterfaceDeclaration,
      id: identifier(this.name),
      typeParameters:
        this.typeParameters.length > 0 ? typeParameters : undefined,
      declare: false,
      extends: [],
      body: {
        ...baseNode,
        type: NodeType.TSInterfaceBody,
        body: this.members,
      },
    }
  }
}

function toQualifiedName(
  name: string,
  domain: string | undefined
): ts.TSTypeReference {
  const [first, ...rest] = name.split('.')

  if (first === undefined) {
    throw new Error('Invalid name')
  }

  if (rest.length === 0 && domain !== undefined) {
    return {
      ...baseNode,
      type: NodeType.TSTypeReference,
      typeName: {
        ...baseNode,
        type: NodeType.TSQualifiedName,
        left: identifier(domain),
        right: identifier(first),
      },
      typeArguments: undefined,
    }
  }

  const typeName = rest.reduce<ts.Identifier | ts.TSQualifiedName>(
    (acc, part) => {
      return {
        ...baseNode,
        type: NodeType.TSQualifiedName,
        left: acc,
        right: identifier(part),
      }
    },
    identifier(first)
  )

  return {
    ...baseNode,
    type: NodeType.TSTypeReference,
    typeName: typeName,
    typeArguments: undefined,
  }
}

function toRef(ref: { $ref: string }, domain: string | undefined): ts.TypeNode {
  if (ref.$ref === '') {
    return toPrimitiveType('unknown')
  }

  return toQualifiedName(ref.$ref, domain)
}

function toTypeWithRef(
  property: ProtocolObjectProperty,
  domain: string | undefined
): ts.TypeNode {
  if ('$ref' in property) {
    return toRef(property, domain)
  }

  if (property.type === 'array') {
    return {
      ...baseNode,
      type: NodeType.TSArrayType,
      elementType: toTypeNode(property.items, domain),
    }
  }

  if (property.type === 'object') {
    return record(_string(), _unknown())
  }

  return toPrimitiveType(property.type)
}

function toTypeNode(
  type: ProtocolType,
  domain: string | undefined
): ts.TypeNode {
  if ('$ref' in type) {
    return toRef(type, domain)
  }

  if ('enum' in type) {
    return {
      ...baseNode,
      type: NodeType.TSUnionType,
      types: type.enum.map((value) => {
        return {
          ...baseNode,
          type: NodeType.TSLiteralType,
          literal: string(value),
        }
      }),
      comment: type.description,
    }
  }

  if (type.type === 'object') {
    if (!type.properties) {
      return record(_string(), type.id === 'Headers' ? _string() : _unknown())
    }

    return {
      ...baseNode,
      type: NodeType.TSTypeLiteral,
      members:
        type.properties?.map<ts.TSPropertySignatureNonComputedName>(
          (property) => {
            return {
              ...baseNode,
              type: NodeType.TSPropertySignature,
              computed: false,
              key: identifier(property.name),
              typeAnnotation: {
                ...baseNode,
                type: NodeType.TSTypeAnnotation,
                typeAnnotation: toTypeWithRef(property, domain),
              },
              optional: property.optional ?? false,
              accessibility: undefined,
              readonly: false,
              static: false,
            }
          }
        ) ?? [],
    }
  }

  if (type.type === 'array') {
    return {
      ...baseNode,
      type: NodeType.TSArrayType,
      elementType: toTypeNode(type.items, domain),
    }
  }

  return toPrimitiveType(type.type)
}

async function readProtocolFile(name: string): Promise<ProtocolDefinition> {
  const content = await readFile(
    path.join(process.cwd(), `node_modules/devtools-protocol/json/${name}`),
    'utf-8'
  )

  return JSON.parse(content) as ProtocolDefinition
}

function field(
  name: string,
  type: ts.TypeNode,
  isPrivate: boolean = true
): ts.PropertyDefinition {
  return {
    ...baseNode,
    type: NodeType.PropertyDefinition,
    key: identifier(name),
    value: null,
    accessibility: isPrivate ? 'private' : undefined,
    computed: false,
    optional: false,
    static: false,
    declare: false,
    decorators: [],
    definite: false,
    override: false,
    readonly: false,
    typeAnnotation: {
      ...baseNode,
      type: NodeType.TSTypeAnnotation,
      typeAnnotation: type,
    },
  }
}

function _undefined(): ts.TSUndefinedKeyword {
  return {
    ...baseNode,
    type: NodeType.TSUndefinedKeyword,
  }
}

function _void(): ts.TSVoidKeyword {
  return {
    ...baseNode,
    type: NodeType.TSVoidKeyword,
  }
}

function _this(): ts.ThisExpression {
  return {
    ...baseNode,
    type: NodeType.ThisExpression,
  }
}

function property(name: string, value: ts.Expression): ts.Property {
  return {
    ...baseNode,
    type: NodeType.Property,
    key: identifier(name),
    value,
    kind: 'init',
    method: false,
    shorthand: false,
    computed: false,
    optional: false,
  }
}

function typeProperty(name: string, type: ts.TypeNode): ts.TSPropertySignature {
  return {
    ...baseNode,
    type: NodeType.TSPropertySignature,
    computed: false,
    key: identifier(name),
    accessibility: undefined,
    readonly: false,
    static: false,
    optional: false,
    typeAnnotation: {
      ...baseNode,
      type: NodeType.TSTypeAnnotation,
      typeAnnotation: type,
    },
  }
}

function promise(type: ts.TypeNode): ts.TSTypeReference {
  return {
    ...baseNode,
    type: NodeType.TSTypeReference,
    typeName: identifier('Promise'),
    typeArguments: {
      ...baseNode,
      type: NodeType.TSTypeParameterInstantiation,
      params: [type],
    },
  }
}

function _string(): ts.TSStringKeyword {
  return {
    ...baseNode,
    type: NodeType.TSStringKeyword,
  }
}

function _unknown(): ts.TSUnknownKeyword {
  return {
    ...baseNode,
    type: NodeType.TSUnknownKeyword,
  }
}

function _number(): ts.TSNumberKeyword {
  return {
    ...baseNode,
    type: NodeType.TSNumberKeyword,
  }
}

function construct(
  params: ts.Identifier[],
  body: ts.Statement[]
): ts.MethodDefinition {
  return {
    ...baseNode,
    type: NodeType.MethodDefinition,
    key: identifier('constructor'),
    accessibility: undefined,
    computed: false,
    kind: 'constructor',
    static: false,
    optional: false,
    override: false,
    decorators: [],
    value: {
      ...baseNode,
      type: NodeType.FunctionExpression,
      id: null,
      generator: false,
      declare: false,
      async: false,
      expression: false,
      returnType: undefined,
      typeParameters: undefined,
      params,
      body: {
        ...baseNode,
        type: NodeType.BlockStatement,
        body,
      },
    },
  }
}

function method({
  name,
  params = [],
  async = false,
  typeParameters,
  returnType,
  body,
}: {
  name: string
  params?: ts.Identifier[]
  async: boolean
  typeParameters?: ts.TSTypeParameter[]
  returnType: ts.TypeNode
  body: ts.Statement[]
}): ts.MethodDefinition {
  return {
    ...baseNode,
    type: NodeType.MethodDefinition,
    key: identifier(name),
    accessibility: undefined,
    computed: false,
    kind: 'method',
    static: false,
    optional: false,
    override: false,
    decorators: [],
    value: {
      ...baseNode,
      type: NodeType.FunctionExpression,
      id: null,
      generator: false,
      declare: false,
      async,
      expression: false,
      returnType: {
        ...baseNode,
        type: NodeType.TSTypeAnnotation,
        typeAnnotation: returnType,
      },
      typeParameters: typeParameters && {
        ...baseNode,
        type: NodeType.TSTypeParameterDeclaration,
        params: typeParameters,
      },
      params: params ?? [],
      body: {
        ...baseNode,
        type: NodeType.BlockStatement,
        body,
      },
    },
  }
}

function union(types: ts.TypeNode[]): ts.TSUnionType {
  return {
    ...baseNode,
    type: NodeType.TSUnionType,
    types,
  }
}

function init(
  name: string,
  expr: ts.Expression | string
): ts.ExpressionStatement {
  const right = typeof expr === 'string' ? identifier(expr) : expr

  return {
    ...baseNode,
    type: NodeType.ExpressionStatement,
    directive: undefined,
    expression: {
      ...baseNode,
      type: NodeType.AssignmentExpression,
      operator: '=',
      left: {
        ...baseNode,
        type: NodeType.MemberExpression,
        object: {
          ...baseNode,
          type: NodeType.ThisExpression,
        },
        property: identifier(name),
        computed: false,
        optional: false,
      },
      right,
    },
  }
}

function exported(node: ts.NamedExportDeclarations): ts.ExportNamedDeclaration {
  return {
    ...baseNode,
    type: NodeType.ExportNamedDeclaration,
    exportKind: 'value',
    attributes: [],
    assertions: [],
    declaration: node,
    specifiers: [],
    source: null,
  }
}

function camelCase(input: string) {
  if (input === 'IO' || input === 'PWA' || input === 'CSS') {
    return input.toLocaleLowerCase()
  }

  if (input.startsWith('DOM')) {
    return 'dom' + input.slice(3)
  }

  const first = input.slice(0, 1).toLowerCase()
  const rest = input.slice(1)

  return first + rest
}

function pascalCase(input: string) {
  const first = input.slice(0, 1).toUpperCase()
  const rest = input.slice(1)

  return first + rest
}

function generateEventInterfaces({
  events = [],
}: ProtocolDomain): ts.TSInterfaceDeclaration[] {
  if (events.length === 0) {
    return []
  }

  const interfaces = events.map((event) => {
    const builder = new InterfaceBuilder(pascalCase(event.name) + 'Event')
    const params = event.parameters ?? []

    return params
      .reduce((builder, param) => {
        return builder.member(param.name, toTypeWithRef(param, undefined))
      }, builder)
      .done()
  })

  const eventMap: ts.TSInterfaceDeclaration = events
    .reduce((builder, event) => {
      return builder.member(
        event.name,
        toQualifiedName(pascalCase(event.name) + 'Event', undefined)
      )
    }, new InterfaceBuilder('EventMap'))
    .done()

  return [...interfaces, eventMap]
}

function generateEventFunctions({ domain, events = [] }: ProtocolDomain) {
  if (events.length === 0) {
    return []
  }

  const onFunctionBody = parse(`
    const filteredListener: typeof listener = (event) => {
      if (event.sessionId !== this.sessionId) {
        return
      }

      listener(event)
    }

    this.listeners.set(listener as ChromeEventListener, filteredListener as ChromeEventListener)
  `)

  const offFunctionBody = parse(`
    const filteredListener = this.listeners.get(listener as ChromeEventListener)

    if (filteredListener === undefined) {
      return
    }

    this.listeners.delete(listener as ChromeEventListener)
  `)

  function eventFn(
    domain: string,
    name: 'on' | 'off',
    returnType: ts.TypeNode,
    body: ts.Statement[]
  ) {
    const eventMap = toQualifiedName('EventMap', domain)

    const keyOfEventMap: ts.TypeNode = {
      ...baseNode,
      type: NodeType.TSTypeOperator,
      operator: 'keyof',
      typeAnnotation: eventMap,
    }

    const typeParameters: ts.TSTypeParameter = {
      ...baseNode,
      type: NodeType.TSTypeParameter,
      name: identifier('K'),
      default: undefined,
      const: false,
      in: false,
      out: false,
      constraint: keyOfEventMap,
    }

    const keyedEventType: ts.TypeNode = {
      ...baseNode,
      type: NodeType.TSIndexedAccessType,
      objectType: eventMap,
      indexType: toQualifiedName('K', undefined),
    }

    const eventType: ts.TypeNode = {
      ...baseNode,
      type: NodeType.TSTypeReference,
      typeName: identifier('ChromeEvent'),
      typeArguments: {
        ...baseNode,
        type: NodeType.TSTypeParameterInstantiation,
        params: [keyedEventType],
      },
    }

    const listenerType: ts.TypeNode = {
      ...baseNode,
      type: NodeType.TSFunctionType,
      params: [identifier('event', eventType)],
      returnType: {
        ...baseNode,
        type: NodeType.TSTypeAnnotation,
        typeAnnotation: _void(),
      },
      typeParameters: undefined,
    }

    return method({
      name,
      async: false,
      params: [
        identifier('name', toQualifiedName('K', undefined)),
        identifier('listener', listenerType),
      ],
      typeParameters: [typeParameters],
      returnType,
      body: [
        ...body,
        {
          ...baseNode,
          type: NodeType.ReturnStatement,
          argument: new ExpressionBuilder(_this())
            .member('transport')
            .member(name)
            .call([
              add(string(domain + '.'), identifier('name')),
              new ExpressionBuilder(identifier('filteredListener'))
                .as(toQualifiedName('ChromeEventListener', undefined))
                .done(),
            ])
            .done(),
        },
      ],
    })
  }

  const disposeFnType: ts.TSFunctionType = {
    ...baseNode,
    type: NodeType.TSFunctionType,
    params: [],
    typeParameters: undefined,
    returnType: {
      ...baseNode,
      type: NodeType.TSTypeAnnotation,
      typeAnnotation: _void(),
    },
  }

  const on = eventFn(domain, 'on', disposeFnType, onFunctionBody.body)
  const off = eventFn(domain, 'off', _void(), offFunctionBody.body)

  return [on, off]
}

function toResultInterfaceName(commandName: string) {
  return pascalCase(commandName) + 'Result'
}

function generateResultInterfaces({
  commands = [],
}: ProtocolDomain): ts.TSInterfaceDeclaration[] {
  return commands.flatMap((command) => {
    if (command.returns === undefined) {
      return []
    }

    return command.returns
      .reduce(
        (builder, param) => {
          return builder.member(param.name, toTypeWithRef(param, undefined))
        },
        new InterfaceBuilder(toResultInterfaceName(command.name))
      )
      .done()
  })
}

async function generate() {
  const browser = await readProtocolFile('browser_protocol.json')
  const js = await readProtocolFile('js_protocol.json')

  const domains = [...browser.domains, ...js.domains]

  const domainNamespaces: ts.TSModuleDeclaration[] = domains.map((domain) => {
    const types =
      domain.types
        ?.map<ts.TSTypeAliasDeclaration>((type) => {
          return {
            ...baseNode,
            type: NodeType.TSTypeAliasDeclaration,
            id: identifier(type.id),
            typeAnnotation: toTypeNode(type, undefined),
            typeParameters: undefined,
            declare: false,
            export: true,
          }
        })
        .map(exported) ?? []

    const resultInterfaces = generateResultInterfaces(domain).map(exported)
    const eventInterfaces = generateEventInterfaces(domain).map(exported)

    const block: ts.TSModuleBlock = {
      ...baseNode,
      type: NodeType.TSModuleBlock,
      body: [...types, ...resultInterfaces, ...eventInterfaces],
    }

    return {
      ...baseNode,
      type: NodeType.TSModuleDeclaration,
      id: identifier(domain.domain),
      kind: 'namespace',
      body: block,
      global: false,
      declare: false,
    }
  })

  const clients = domains.map<ts.ClassDeclarationWithName>((domain) => {
    const listenerType = toQualifiedName('ChromeEventListener', undefined)

    const fields: ts.PropertyDefinition[] = [
      field('transport', {
        ...baseNode,
        type: NodeType.TSTypeReference,
        typeName: identifier('Transport'),
        typeArguments: undefined,
      }),
      field(
        'sessionId',
        union([toQualifiedName('SessionID', 'Target'), _undefined()])
      ),
      field('listeners', {
        ...baseNode,
        type: NodeType.TSTypeReference,
        typeName: identifier('WeakMap'),
        typeArguments: {
          ...baseNode,
          type: NodeType.TSTypeParameterInstantiation,
          params: [listenerType, listenerType],
        },
      }),
    ]

    const ctor: ts.MethodDefinition = {
      ...baseNode,
      type: NodeType.MethodDefinition,
      key: identifier('constructor'),
      accessibility: undefined,
      computed: false,
      kind: 'constructor',
      static: false,
      optional: false,
      override: false,
      decorators: [],
      value: {
        ...baseNode,
        type: NodeType.FunctionExpression,
        id: null,
        generator: false,
        declare: false,
        async: false,
        expression: false,
        returnType: undefined,
        typeParameters: undefined,
        params: [
          identifier('transport', ['Transport', undefined]),
          identifier('sessionId', ['SessionID', 'Target'], true),
        ],
        body: {
          ...baseNode,
          type: NodeType.BlockStatement,
          body: [
            init('transport', 'transport'),
            init('sessionId', 'sessionId'),
            init(
              'listeners',
              new ExpressionBuilder(identifier('WeakMap')).new([]).done()
            ),
          ],
        },
      },
    }

    const methods = domain.commands?.map<ts.MethodDefinition>((command) => {
      function compareOptional(
        a: ProtocolObjectProperty,
        b: ProtocolObjectProperty
      ) {
        if (a.optional === b.optional) {
          return 0
        }

        if (a.optional === true) {
          return 1
        }

        return -1
      }

      const params = command.parameters
        ?.toSorted(compareOptional)
        .map((param) => {
          return escape(
            identifier(
              param.name,
              toTypeWithRef(param, domain.domain),
              param.optional === true
            )
          )
        })

      return method({
        name: camelCase(command.name),
        params: params ?? [],
        async: true,
        returnType:
          command.returns === undefined
            ? promise(_void())
            : promise(
                toQualifiedName(
                  toResultInterfaceName(command.name),
                  domain.domain
                )
              ),
        body: [
          {
            ...baseNode,
            type: NodeType.ReturnStatement,
            argument: {
              ...baseNode,
              type: NodeType.CallExpression,
              callee: {
                ...baseNode,
                type: NodeType.MemberExpression,
                object: {
                  ...baseNode,
                  type: NodeType.MemberExpression,
                  object: _this(),
                  property: identifier('transport'),
                  computed: false,
                  optional: false,
                },
                property: identifier('call'),
                computed: false,
                optional: false,
              },
              optional: false,
              typeArguments: {
                ...baseNode,
                type: NodeType.TSTypeParameterInstantiation,
                params: [
                  command.returns === undefined
                    ? _void()
                    : toQualifiedName(
                        toResultInterfaceName(command.name),
                        domain.domain
                      ),
                ],
              },
              arguments: [
                {
                  ...baseNode,
                  type: NodeType.ObjectExpression,
                  properties: [
                    property('id', {
                      ...baseNode,
                      type: NodeType.CallExpression,
                      callee: identifier('generateId'),
                      arguments: [],
                      optional: false,
                      typeArguments: undefined,
                    }),
                    property('sessionId', {
                      ...baseNode,
                      type: NodeType.MemberExpression,
                      object: _this(),
                      property: identifier('sessionId'),
                      computed: false,
                      optional: false,
                    }),
                    property(
                      'method',
                      string(`${domain.domain}.${command.name}`)
                    ),
                    property('params', {
                      ...baseNode,
                      type: NodeType.ObjectExpression,
                      properties:
                        command.parameters?.map((param) =>
                          property(param.name, escape(identifier(param.name)))
                        ) ?? [],
                    }),
                  ],
                },
              ],
            },
          },
        ],
      })
    })

    const eventFns = generateEventFunctions(domain)

    return {
      ...baseNode,
      type: NodeType.ClassDeclaration,
      id: identifier(`${domain.domain}Client`),
      abstract: false,
      superClass: null,
      declare: false,
      superTypeArguments: undefined,
      implements: [],
      typeParameters: undefined,
      decorators: [],
      body: {
        ...baseNode,
        type: NodeType.ClassBody,
        body: [...fields, ctor, ...(methods ?? []), ...eventFns],
      },
    }
  })

  function createClient(): ts.ClassDeclarationWithName {
    const fields = domains.map((domain) => {
      return field(
        camelCase(domain.domain),
        {
          ...baseNode,
          type: NodeType.TSTypeReference,
          typeName: identifier(`${domain.domain}Client`),
          typeArguments: undefined,
        },
        false
      )
    })

    const constructor = construct(
      [
        identifier('transport', ['Transport', undefined]),
        identifier('sessionId', ['SessionID', 'Target'], true),
      ],
      [
        init('transport', 'transport'),
        ...domains.map((domain) =>
          init(
            camelCase(domain.domain),
            `new ${domain.domain}Client(transport, sessionId)`
          )
        ),
      ]
    )

    const newClient = new ExpressionBuilder(identifier('ChromeDevToolsClient'))
      .new([
        new ExpressionBuilder(_this()).member('transport').done(),
        identifier('sessionId'),
      ])
      .returned()

    return {
      ...baseNode,
      type: NodeType.ClassDeclaration,
      id: identifier('ChromeDevToolsClient'),
      abstract: false,
      superClass: null,
      declare: false,
      superTypeArguments: undefined,
      implements: [],
      typeParameters: undefined,
      decorators: [],
      body: {
        ...baseNode,
        type: NodeType.ClassBody,
        body: [
          field('transport', toQualifiedName('Transport', undefined)),
          method({
            name: 'withSession',
            params: [identifier('sessionId', ['SessionID', 'Target'])],
            async: false,
            returnType: toQualifiedName('ChromeDevToolsClient', undefined),
            body: [newClient],
          }),

          ...fields,
          constructor,
        ],
      },
    }
  }

  const client: ts.ClassDeclarationWithName = createClient()

  const exports: ts.ExportNamedDeclaration[] = domainNamespaces.map(exported)

  const program = {
    ...baseNode,
    type: NodeType.Program,
    body: [...BASE_DEFINITIONS.body, ...exports, ...clients, exported(client)],
    sourceType: 'module',
    interpreter: null,
  }

  const result = await format("const test = ''", {
    parser: 'raw',
    plugins: [
      {
        parsers: {
          raw: {
            astFormat: 'estree',
            parse: () => program,
            locStart() {
              return 0
            },
            locEnd() {
              return 0
            },
          },
        },
      },
    ],
  })

  if (result.includes(': never')) {
    throw new Error(
      'Generated types include `never` type, meaning something is not mapped correctly'
    )
  }

  process.stdout.write(SCRIPT_BANNER + result)
}

generate().catch((err) => {
  console.error(err)
  process.exit(1)
})
