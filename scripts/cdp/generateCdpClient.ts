/* eslint-disable @typescript-eslint/no-unsafe-assignment */

/**
 * By generating the client we can detect breaking changes in CDP by:
 
 *  1. Updating the devtools-protocol package to the latest version
 *  2. Generating a new client
 * 
 * If CDP has breaking changes impacting the methods we're using, then we'll get type errors because the client will be different.
*/
import { parse, TSESTree as ts } from '@typescript-eslint/typescript-estree'
import dedent from 'dedent'
import { readFile } from 'fs/promises'
import path from 'path'
import { format, Options } from 'prettier'

import {
  $this,
  ClassBuilder,
  ExpressionBuilder,
  FunctionBuilder,
  identifier,
  ObjectBuilder,
  string,
} from '@/codegen/estree'
import { baseProps, NodeType } from '@/codegen/estree/nodes'
import { typeRef, t, InterfaceBuilder } from '@/codegen/estree/typescript'

import * as cdp from './types/protocol'
import {
  camelCase,
  toArgInterfaceName,
  toEventTypeName,
  toResultTypeName,
} from './utils'

const SCRIPT_BANNER = dedent` 
  // This file is auto-generated by generateCdpClient.ts. DO NOT EDIT!

  /* eslint-disable @typescript-eslint/no-namespace */
  /* eslint-disable @typescript-eslint/no-unnecessary-type-assertion */
`

const BASE_DEFINITIONS = parse(`
  let id = 0

  function generateId() {
    return ++id
  }

  type DisposeFn = () => void

  type ChromeEventListener<Event = unknown> = (event: ChromeEvent<Event>) => void

  export interface Transport {
    call<Return>(command: ChromeCommand): Promise<Return>;
 
    on(event: string, listener: ChromeEventListener): DisposeFn
    off(event: string, listener: ChromeEventListener): void

    dispose(): void
  } 

  export interface ChromeCommand {
    id: number;
    sessionId: string | undefined
    method: string;
    params: object
  }
 
  export interface ChromeEvent<Event = unknown> {
    sessionId?: string
    name: string
    data: Event
  }
`)

const CLIENT_CLASS_NAME = identifier('ChromeDevToolsClient')

const TRANSPORT_TYPE = typeRef('Transport')
const SESSION_ID_TYPE = typeRef(['Target', 'SessionID'])

function toPrimitiveType(type: string): ts.TypeNode {
  switch (type) {
    case 'string':
      return {
        ...baseProps,
        type: NodeType.TSStringKeyword,
      }

    case 'boolean':
      return {
        ...baseProps,
        type: NodeType.TSBooleanKeyword,
      }

    case 'number':
    case 'integer':
      return {
        ...baseProps,
        type: NodeType.TSNumberKeyword,
      }

    case 'any':
      return {
        ...baseProps,
        type: NodeType.TSUnknownKeyword,
      }

    default:
      return {
        ...baseProps,
        type: NodeType.TSNeverKeyword,
      }
  }
}

/**
 * Takes a potentially qualified name (e.g. Page.Frame) and creates a type reference. If a domain is provided
 * it is used as a fallback for unqualified names (e.g. Frame with domain Page becomes Page.Frame).
 */
function toQualifiedName(
  name: string,
  domain: string | undefined
): ts.TSTypeReference {
  const [first, ...rest] = name.split('.')

  if (first === undefined) {
    throw new Error('Invalid name')
  }

  if (rest.length === 0 && domain !== undefined) {
    return {
      ...baseProps,
      type: NodeType.TSTypeReference,
      typeName: {
        ...baseProps,
        type: NodeType.TSQualifiedName,
        left: identifier(domain),
        right: identifier(first),
      },
      typeArguments: undefined,
    }
  }

  const typeName = rest.reduce<ts.Identifier | ts.TSQualifiedName>(
    (acc, part) => {
      return {
        ...baseProps,
        type: NodeType.TSQualifiedName,
        left: acc,
        right: identifier(part),
      }
    },
    identifier(first)
  )

  return {
    ...baseProps,
    type: NodeType.TSTypeReference,
    typeName: typeName,
    typeArguments: undefined,
  }
}

function toRef(ref: { $ref: string }, domain: string | undefined): ts.TypeNode {
  if (ref.$ref === '') {
    return toPrimitiveType('unknown')
  }

  return toQualifiedName(ref.$ref, domain)
}

function toTypeWithRef(
  property: cdp.Property,
  domain: string | undefined
): ts.TypeNode {
  if ('$ref' in property) {
    return toRef(property, domain)
  }

  if (property.type === 'array') {
    return {
      ...baseProps,
      type: NodeType.TSArrayType,
      elementType: toTypeNode(property.items, domain),
    }
  }

  if (property.type === 'object') {
    return t.record(t.string(), t.unknown())
  }

  if (property.type === 'string' && property.enum !== undefined) {
    return t.union(property.enum.map((literal) => t.string(literal)))
  }

  return toPrimitiveType(property.type)
}

function toTypeNode(
  type: cdp.Declaration | cdp.Type,
  domain: string | undefined
): ts.TypeNode {
  if ('$ref' in type) {
    return toRef(type, domain)
  }

  if (type.type === 'string' && type.enum !== undefined) {
    return {
      ...baseProps,
      type: NodeType.TSUnionType,
      types: type.enum.map((value) => {
        return {
          ...baseProps,
          type: NodeType.TSLiteralType,
          literal: string(value),
        }
      }),
    }
  }

  if (type.type === 'object') {
    if (!type.properties) {
      const valueType =
        'id' in type && type.id === 'Headers' ? t.string() : t.unknown()

      return t.record(t.string(), valueType)
    }

    return {
      ...baseProps,
      type: NodeType.TSTypeLiteral,
      members:
        type.properties?.map<ts.TSPropertySignatureNonComputedName>(
          (property) => {
            return {
              ...baseProps,
              type: NodeType.TSPropertySignature,
              computed: false,
              key: identifier(property.name),
              typeAnnotation: {
                ...baseProps,
                type: NodeType.TSTypeAnnotation,
                typeAnnotation: toTypeWithRef(property, domain),
              },
              optional: property.optional ?? false,
              accessibility: undefined,
              readonly: false,
              static: false,
            }
          }
        ) ?? [],
    }
  }

  if (type.type === 'array') {
    return {
      ...baseProps,
      type: NodeType.TSArrayType,
      elementType: toTypeNode(type.items, domain),
    }
  }

  return toPrimitiveType(type.type)
}

async function readProtocolFile(name: string): Promise<cdp.Protocol> {
  const content = await readFile(
    path.join(process.cwd(), `node_modules/devtools-protocol/json/${name}`),
    'utf-8'
  )

  return cdp.ProtocolSchema.parse(JSON.parse(content))
}

function exported(node: ts.NamedExportDeclarations): ts.ExportNamedDeclaration {
  return {
    ...baseProps,
    type: NodeType.ExportNamedDeclaration,
    exportKind: 'value',
    attributes: [],
    assertions: [],
    declaration: node,
    specifiers: [],
    source: null,
  }
}

function generateEventInterfaces({
  events = [],
}: cdp.Domain): ts.TSInterfaceDeclaration[] {
  if (events.length === 0) {
    return []
  }

  const interfaces = events.map((event) => {
    return InterfaceBuilder.define(toEventTypeName(event))
      .reduce(event.parameters ?? [], (builder, param) => {
        return builder.property(param.name, toTypeWithRef(param, undefined))
      })
      .done()
  })

  const eventMap = InterfaceBuilder.define('EventMap')
    .reduce(events, (builder, event) => {
      return builder.property(event.name, typeRef(toEventTypeName(event)))
    })
    .done()

  return [...interfaces, eventMap]
}

function generateArgInterfaces({
  commands = [],
}: cdp.Domain): ts.TSInterfaceDeclaration[] {
  return commands.flatMap((command) => {
    // We only emit the args interface if there are multiple parameters, otherwise we'll
    // just inline the single parameter.
    if (command.parameters === undefined || command.parameters.length <= 1) {
      return []
    }

    return InterfaceBuilder.define(toArgInterfaceName(command))
      .reduce(command.parameters, (builder, param) => {
        if (param.optional) {
          return builder.optional(param.name, toTypeWithRef(param, undefined))
        }

        return builder.property(param.name, toTypeWithRef(param, undefined))
      })
      .done()
  })
}

function generateResultInterfaces({
  commands = [],
}: cdp.Domain): ts.TSInterfaceDeclaration[] {
  return commands.flatMap((command) => {
    if (command.returns === undefined) {
      return []
    }

    return InterfaceBuilder.define(toResultTypeName(command))
      .reduce(command.returns, (builder, param) => {
        return builder.property(param.name, toTypeWithRef(param, undefined))
      })
      .done()
  })
}

function generateEventFunctions({ domain, events = [] }: cdp.Domain) {
  if (events.length === 0) {
    return []
  }

  const onFunctionBody = parse(`
    const filteredListener: typeof listener = (event) => {
      if (event.sessionId !== this.sessionId) {
        return
      }

      listener(event)
    }

    this.listeners.set(listener as ChromeEventListener, filteredListener as ChromeEventListener)
  `)

  const offFunctionBody = parse(`
    const filteredListener = this.listeners.get(listener as ChromeEventListener)

    if (filteredListener === undefined) {
      return
    }

    this.listeners.delete(listener as ChromeEventListener)
  `)

  function eventFn(
    domain: string,
    name: 'on' | 'off',
    returnType: ts.TypeNode,
    body: ts.Statement[]
  ): ts.MethodDefinition {
    const eventMap = typeRef([domain, 'EventMap'])

    const eventType = (eventKey: ts.TypeNode): ts.TypeNode => {
      return {
        ...baseProps,
        type: NodeType.TSTypeReference,
        typeName: identifier('ChromeEvent'),
        typeArguments: {
          ...baseProps,
          type: NodeType.TSTypeParameterInstantiation,
          params: [t.index(eventMap, eventKey)],
        },
      }
    }

    const listenerType = (eventKey: ts.TypeNode): ts.TypeNode => {
      return {
        ...baseProps,
        type: NodeType.TSFunctionType,
        params: [
          identifier('event', {
            typeAnnotation: eventType(eventKey),
          }),
        ],
        returnType: {
          ...baseProps,
          type: NodeType.TSTypeAnnotation,
          typeAnnotation: t.void(),
        },
        typeParameters: undefined,
      }
    }

    const value = FunctionBuilder.define()
      .typeParam('K', { extends: t.keyOf(eventMap) })
      .param('name', (params) => params.K)
      .param('listener', (params) => listenerType(params.K))
      .returns(returnType)
      .body((params) => {
        const eventName = new ExpressionBuilder(string(domain + '.')).calculate(
          '+',
          params.name
        )
        const listener = new ExpressionBuilder(identifier('listener')).as(
          typeRef('ChromeEventListener')
        )

        return [
          ...body,
          new ExpressionBuilder($this())
            .member('transport')
            .member(name)
            .call([eventName, listener])
            .returned(),
        ]
      })

    return {
      ...baseProps,
      type: NodeType.MethodDefinition,
      key: identifier(name),
      kind: 'method',
      static: false,
      computed: false,
      override: false,
      decorators: [],
      accessibility: undefined,
      optional: false,
      value,
    }
  }

  const disposeFnType: ts.TSFunctionType = {
    ...baseProps,
    type: NodeType.TSFunctionType,
    params: [],
    typeParameters: undefined,
    returnType: {
      ...baseProps,
      type: NodeType.TSTypeAnnotation,
      typeAnnotation: t.void(),
    },
  }

  const on = eventFn(domain, 'on', disposeFnType, onFunctionBody.body)
  const off = eventFn(domain, 'off', t.void(), offFunctionBody.body)

  return [on, off]
}

function toCommandParameter(domain: cdp.Domain, command: cdp.Command) {
  const [first, ...rest] = command.parameters ?? []

  // If the command has no parameters, then we want to generate a
  // function that doesn't take any arguments.
  if (first === undefined) {
    return {
      parameter: null,
      init: ObjectBuilder.empty(),
    }
  }

  // IF the command has exactly one parameter, then we want to generate a
  // function that takes that parameter directly and make it optional if needed.
  if (rest.length === 0) {
    return {
      parameter: {
        name: first.name,
        type: toTypeWithRef(first, domain.domain),
        optional: first.optional ?? false,
      },
      init: ObjectBuilder.from({
        [first.name]: identifier(first.name),
      }),
    }
  }

  const args = identifier('args')
  const optional =
    command.parameters?.every((p) => p.optional === true) ?? false

  // If the command has multiple parameters, then we use an object for all of them.
  return {
    parameter: {
      name: args.name,
      optional,
      type: typeRef([domain.domain, toArgInterfaceName(command)]),
    },
    init: optional
      ? new ExpressionBuilder(args).nullish(ObjectBuilder.empty()).done()
      : args,
  }
}

async function generate() {
  const browser = await readProtocolFile('browser_protocol.json')
  const js = await readProtocolFile('js_protocol.json')

  const domains = [...browser.domains, ...js.domains]

  const domainNamespaces: ts.TSModuleDeclaration[] = domains.map((domain) => {
    const types =
      domain.types
        ?.map<ts.TSTypeAliasDeclaration>((type) => {
          return {
            ...baseProps,
            type: NodeType.TSTypeAliasDeclaration,
            id: identifier(type.id),
            typeAnnotation: toTypeNode(type, undefined),
            typeParameters: undefined,
            declare: false,
            export: true,
          }
        })
        .map(exported) ?? []

    const argInterfaces = generateArgInterfaces(domain).map(exported)
    const resultInterfaces = generateResultInterfaces(domain).map(exported)
    const eventInterfaces = generateEventInterfaces(domain).map(exported)

    const block: ts.TSModuleBlock = {
      ...baseProps,
      type: NodeType.TSModuleBlock,
      body: [
        ...types,
        ...argInterfaces,
        ...resultInterfaces,
        ...eventInterfaces,
      ],
    }

    return {
      ...baseProps,
      type: NodeType.TSModuleDeclaration,
      id: identifier(domain.domain),
      kind: 'namespace',
      body: block,
      global: false,
      declare: false,
    }
  })

  const clients = domains.map<ts.ClassDeclarationWithName>((domain) => {
    const listenerType = typeRef('ChromeEventListener')

    return ClassBuilder.define()
      .field('transport', (b) => b.type(TRANSPORT_TYPE).init())
      .field('sessionId', (b) =>
        b.type(t.union([SESSION_ID_TYPE, t.undefined()])).init()
      )
      .field('listeners', (b) =>
        b.type(typeRef('WeakMap', [listenerType, listenerType])).init()
      )
      .construct((b, self) => {
        return b
          .param('transport', TRANSPORT_TYPE)
          .optional('sessionId', SESSION_ID_TYPE)
          .body((params) => {
            return [
              new ExpressionBuilder(self.transport)
                .assign(params.transport)
                .statement(),
              new ExpressionBuilder(self.sessionId)
                .assign(params.sessionId)
                .statement(),
              new ExpressionBuilder(self.listeners)
                .assign(
                  new ExpressionBuilder(identifier('WeakMap')).new([]).done()
                )
                .statement(),
            ]
          })
      })
      .reduce(domain.commands ?? [], (b, command, self) => {
        return b.method(camelCase(command.name), (b) => {
          const { parameter, init } = toCommandParameter(domain, command)

          const returnType =
            command.returns === undefined
              ? t.void()
              : typeRef([domain.domain, toResultTypeName(command)])

          return b
            .reduce(parameter ? [parameter] : [], (b, param) => {
              if (param.optional) {
                return b.optional(param.name, param.type)
              }

              return b.param(param.name, param.type)
            })
            .returns(t.promise(returnType))
            .body(() => {
              const commandArg = new ObjectBuilder()
                .property(
                  'id',
                  new ExpressionBuilder(identifier('generateId'))
                    .call([])
                    .done()
                )
                .property(
                  'sessionId',
                  new ExpressionBuilder(self.sessionId).done()
                )
                .property('method', string(`${domain.domain}.${command.name}`))
                .property('params', init)
                .done()

              return [
                new ExpressionBuilder(self.transport)
                  .member('call')
                  .call([commandArg], {
                    typeParameters: [returnType],
                  })
                  .returned(),
              ]
            })
        })
      })
      .add(...generateEventFunctions(domain))
      .declare(`${domain.domain}Client`)
  })

  const client = ClassBuilder.define()
    .field('transport', (b) => b.type(TRANSPORT_TYPE).init())
    .field('sessionId', (b) =>
      b.type(t.union([SESSION_ID_TYPE, t.undefined()])).init()
    )
    .reduce(domains, (b, domain) => {
      return b.field(camelCase(domain.domain), (b) =>
        b.type(typeRef(`${domain.domain}Client`)).init()
      )
    })
    .construct((b, self) => {
      return b
        .param('transport', TRANSPORT_TYPE)
        .optional('sessionId', SESSION_ID_TYPE)
        .body((params) => [
          new ExpressionBuilder(self.transport)
            .assign(params.transport)
            .statement(),
          new ExpressionBuilder(self.sessionId)
            .assign(params.sessionId)
            .statement(),
          ...domains.map((domain) => {
            const field = self[camelCase(domain.domain)]
            const clientName = identifier(`${domain.domain}Client`)

            if (field === undefined) {
              throw new Error('Field not found: ' + domain.domain)
            }

            return new ExpressionBuilder(field)
              .assign(
                new ExpressionBuilder(clientName)
                  .new([self.transport, self.sessionId])
                  .done()
              )
              .statement()
          }),
        ])
    })
    .method('withSession', (b, self) => {
      return b
        .param('sessionId', SESSION_ID_TYPE)
        .body((params) => [
          new ExpressionBuilder(CLIENT_CLASS_NAME)
            .new([self.transport, params.sessionId])
            .returned(),
        ])
    })
    .method('dispose', (b, self) => {
      return b.body(() => [
        new ExpressionBuilder(self.transport)
          .member('dispose')
          .call([])
          .statement(),
      ])
    })
    .declare(CLIENT_CLASS_NAME)

  const exports: ts.ExportNamedDeclaration[] = domainNamespaces.map(exported)

  const program = {
    ...baseProps,
    type: NodeType.Program,
    body: [...BASE_DEFINITIONS.body, ...exports, ...clients, exported(client)],
    sourceType: 'module',
    interpreter: null,
  }

  const prettierConfig = await readFile(
    path.join(process.cwd(), '.prettierrc'),
    'utf-8'
  )

  const result = await format("const test = ''", {
    parser: 'raw',
    plugins: [
      {
        parsers: {
          raw: {
            astFormat: 'estree',
            parse: () => program,
            locStart() {
              return 0
            },
            locEnd() {
              return 0
            },
          },
        },
      },
    ],
    ...(JSON.parse(prettierConfig) as Options),
  })

  if (result.includes(': never')) {
    throw new Error(
      'Generated types include `never` type, meaning something is not mapped correctly'
    )
  }

  process.stdout.write(SCRIPT_BANNER + '\n\n' + result)
}

generate().catch((err) => {
  console.error(err)
  process.exit(1)
})
