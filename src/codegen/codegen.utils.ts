import { canonicalHeaderKey } from '@/rules/utils'
import { ProxyData, RequestSnippetSchema } from '@/types'
import { getLocationHeader, getUpgradeHeader } from '@/utils/headers'

const HEADERS_TO_EXCLUDE = ['Cookie', 'User-Agent', 'Host', 'Content-Length']

// TODO: find a well-maintained library for this
export function stringify(value: unknown): string {
  if (typeof value === 'string') {
    return `'${value}'`
  }

  if (Array.isArray(value)) {
    return `[${value.map(stringify).join(', ')}]`
  }

  if (typeof value === 'object' && value !== null) {
    const properties = Object.entries(value)
      .filter(([, value]) => value !== undefined)
      .map(([key, value]) => `${key}: ${stringify(value)}`)
      .join(',\n')

    return `{${properties}}`
  }

  // TODO: https://github.com/grafana/k6-studio/issues/277
  // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
  return `${value}`
}

function isRedirect(response: ProxyData['response']) {
  if (!response) return false
  return [301, 302, 303, 307, 308].includes(response.statusCode)
}

function isValidUrl(url: string) {
  try {
    new URL(url)
    return true
  } catch {
    return false
  }
}

export function getRedirectUrl(
  request: ProxyData['request'],
  response: ProxyData['response']
) {
  if (!response || !isRedirect(response)) return undefined
  const location = getLocationHeader(response.headers)

  if (!location) return undefined
  if (isValidUrl(location)) return location

  return buildLocationUrl(request, location)
}

function buildLocationUrl(request: ProxyData['request'], location: string) {
  const { protocol, host } = new URL(request.url)
  return `${protocol}//${host}${location}`
}

function followChain(
  start: RequestSnippetSchema,
  snippets: RequestSnippetSchema[],
  processed: Set<string>
): RequestSnippetSchema[] {
  const chain: RequestSnippetSchema[] = [start]
  const visited = new Set<string>([start.data.id])
  let current = start
  let nextUrl = getRedirectUrl(current.data.request, current.data.response)

  while (nextUrl) {
    const next = snippets.find(
      (s) =>
        s.data.request.url === nextUrl &&
        !processed.has(s.data.id) &&
        !visited.has(s.data.id)
    )
    if (!next) break

    visited.add(next.data.id)
    chain.push(next)
    current = next
    nextUrl = getRedirectUrl(current.data.request, current.data.response)
  }

  return chain
}

export function processRedirectChains(
  snippets: RequestSnippetSchema[],
  affectedRequestIds: Set<string>
): RequestSnippetSchema[] {
  const processed = new Set<string>()
  const result: RequestSnippetSchema[] = []

  for (const snippet of snippets) {
    if (processed.has(snippet.data.id)) {
      continue
    }

    if (!snippet.data.response || !isRedirect(snippet.data.response)) {
      result.push(snippet)
      processed.add(snippet.data.id)
      continue
    }

    const chain = followChain(snippet, snippets, processed)
    const chainAffected = chain.some((s) => affectedRequestIds.has(s.data.id))

    chain.forEach((s) => processed.add(s.data.id))

    if (chainAffected) {
      // Skip redirect merging since redirect chain is affected by some rules
      chain.forEach((chainSnippet) => {
        result.push({
          ...chainSnippet,
          noRedirect: isRedirect(chainSnippet.data.response),
        })
      })
      continue
    }

    const last = chain[chain.length - 1]!
    result.push({
      ...snippet,
      data: { ...snippet.data, response: last.data.response },
    })
  }

  return result
}

export const removeWebsocketRequests = (recording: ProxyData[]) => {
  return recording.filter((data) => {
    return getUpgradeHeader(data.request.headers) !== 'websocket'
  })
}

export function cleanupRecording(recording: ProxyData[]) {
  return removeWebsocketRequests(recording)
}

export function shouldIncludeHeaderInScript(key: string) {
  return !HEADERS_TO_EXCLUDE.includes(canonicalHeaderKey(key))
}

export function generateScriptHeader() {
  return `Generated by Grafana k6 Studio (${__APP_VERSION__}) on ${new Date().toISOString()}`
}
