import { afterAll, beforeAll, describe, expect, it, vi } from 'vitest'

import { createParameterizationRuleInstance } from '@/rules/parameterization'
import { generateSequentialInt } from '@/rules/utils'
import { createProxyData, createRequest } from '@/test/factories/proxyData'
import { checksRecording } from '@/test/fixtures/checksRecording'
import { correlationRecording } from '@/test/fixtures/correlationRecording'
import {
  customCodeReplaceCsrf,
  customCodeReplaceProjectId,
  jsonRule,
} from '@/test/fixtures/parameterizationRules'
import { Cookie, Header, ProxyData, Request } from '@/types'
import { GeneratorFileData } from '@/types/generator'
import { TestRule } from '@/types/rules'
import { ThinkTime } from '@/types/testOptions'
import { prettify } from '@/utils/prettify'

import {
  generateScript,
  generateRequestSnippets,
  generateVariableDeclarations,
  generateGroupSnippet,
  generateRequestParams,
  generateVUCode,
  generateDataFileDeclarations,
  generateImports,
  generateParameterizationCustomCode,
} from './codegen'

const fakeDate = new Date('2000-01-01T00:00:00Z')

const thinkTime: ThinkTime = {
  sleepType: 'iterations',
  timing: {
    type: 'fixed',
    value: 1,
  },
}

describe('Code generation', () => {
  beforeAll(() => {
    vi.mock('./options', () => ({
      generateOptions: () => '{}',
    }))

    vi.stubGlobal('__APP_VERSION__', '0.0.0')
    vi.setSystemTime(fakeDate)
  })

  afterAll(() => {
    vi.resetAllMocks()
  })

  describe('generateScript', () => {
    it('should generate script', () => {
      const expectedResult = `
      // Generated by Grafana k6 Studio (0.0.0) on ${fakeDate.toISOString()}

      import { group, sleep, check } from 'k6'
      import http from 'k6/http'
      import execution from 'k6/execution'

      export const options = {}

      export default function() {
        let params
        let resp
        let match
        let regex
        let url
        const correlation_vars = {}
        sleep(1)
      }
      `

      expect(
        generateScript({
          recording: [],
          generator: {
            version: '2.0',
            recordingPath: 'test',
            options: {
              loadProfile: {
                executor: 'shared-iterations',
                vus: 1,
                iterations: 1,
              },
              thinkTime: {
                sleepType: 'iterations',
                timing: {
                  type: 'fixed',
                  value: 1,
                },
              },
              thresholds: [],
              cloud: {
                loadZones: {
                  distribution: 'even',
                  zones: [],
                },
              },
            },
            testData: {
              variables: [],
              files: [],
            },
            rules: [],
            allowlist: [],
            includeStaticAssets: false,
            scriptName: 'my-script.js',
          },
        }).replace(/\s/g, '')
      ).toBe(expectedResult.replace(/\s/g, ''))
    })
  })

  describe('generateImports', () => {
    const generator: GeneratorFileData = {
      version: '2.0',
      recordingPath: 'test',
      options: {
        loadProfile: {
          executor: 'shared-iterations',
          vus: 1,
          iterations: 1,
        },
        thinkTime: {
          sleepType: 'iterations',
          timing: {
            type: 'fixed',
            value: 1,
          },
        },
        thresholds: [],
        cloud: {
          loadZones: {
            distribution: 'even',
            zones: [],
          },
        },
      },
      testData: {
        variables: [],
        files: [],
      },
      rules: [],
      allowlist: [],
      includeStaticAssets: false,
      scriptName: 'my-script.js',
    }

    it('should generate imports', async () => {
      const expectedResult = await prettify(`
        import { group, sleep, check } from 'k6'
        import http from 'k6/http'
        import execution from "k6/execution";
      `)

      expect(await prettify(generateImports(generator))).toBe(expectedResult)
    })

    it('should generate imports with data files', async () => {
      const files = [{ name: 'users.csv' }, { name: 'products.json' }]
      const expectedResult = await prettify(`
        import { group, sleep, check } from 'k6'
        import http from 'k6/http'
        import execution from "k6/execution";
        import { SharedArray } from 'k6/data'
        import csv from "k6/experimental/csv";
        import fs from "k6/experimental/fs";
        `)

      expect(
        await prettify(
          generateImports({
            ...generator,
            testData: {
              ...generator.testData,
              files,
            },
          })
        )
      ).toBe(expectedResult)
    })
  })

  describe('generateVariableDeclarations', () => {
    it('should generate variable declarations', async () => {
      const variables = [
        {
          name: 'test',
          value: 'test',
        },
      ]

      const expectedResult = await prettify(`
        const VARS = {
          "test": "test",
        };`)

      expect(await prettify(generateVariableDeclarations(variables))).toBe(
        expectedResult
      )
    })
  })

  describe('generateDataFileDeclarations', () => {
    it('should generate file declarations', async () => {
      const files = [{ name: 'users.csv' }, { name: 'products.json' }]

      const expectedResult = await prettify(`
        const FILES = {
          users: await csv.parse(await fs.open("../Data/users.csv"), { asObjects: true }),

          products: new SharedArray("products", () => {
            const data = JSON.parse(open("../Data/products.json"));
            return Array.isArray(data) ? data : [data];
          }),
        };`)

      expect(await prettify(generateDataFileDeclarations(files))).toBe(
        expectedResult
      )
    })
  })

  describe('generateRequestSnippets', () => {
    it('should generate request snippets', () => {
      const recording: ProxyData[] = [
        {
          id: '1',
          request: {
            method: 'GET',
            url: '/api/v1/users',
            headers: [],
            cookies: [],
            query: [],
            scheme: 'http',
            host: 'localhost:3000',
            content: '',
            path: '/api/v1/users',
            timestampStart: 0,
            timestampEnd: 0,
            contentLength: 0,
            httpVersion: '1.1',
          },
        },
      ]

      const rules: TestRule[] = []

      const expectedResult = `
        params = { headers: {}, cookies: {} }
        url = http.url\`/api/v1/users\`
        resp = http.request('GET', url, null, params)
      `

      expect(
        generateRequestSnippets(
          recording,
          rules,
          thinkTime
        )[0]?.snippet.replace(/\s/g, '')
      ).toBe(expectedResult.replace(/\s/g, ''))
    })

    describe('Correlation', () => {
      const rules: TestRule[] = [
        {
          type: 'correlation',
          id: '1',
          enabled: true,
          extractor: {
            filter: { path: '/login' },
            selector: {
              type: 'json',
              from: 'body',
              path: 'user_id',
            },
            extractionMode: 'single',
          },
        },
        {
          type: 'correlation',
          id: '2',
          enabled: true,
          extractor: {
            filter: { path: '' },
            selector: {
              type: 'regex',
              from: 'headers',
              regex: 'project_id=(.*)$',
            },
            extractionMode: 'single',
          },
        },
        {
          type: 'correlation',
          id: '3',
          enabled: true,
          extractor: {
            filter: { path: '' },
            selector: {
              type: 'json',
              from: 'body',
              path: 'is_admin',
            },
            extractionMode: 'single',
          },
        },
      ]

      it('should replace correlated values', async () => {
        const expectedResult = await prettify(`
        let params
        let resp
        let match
        let regex
        let url
        const correlation_vars = {}

        group('one', function () {
          params = {
            headers: {}, cookies: {}
          }

          url = http.url\`http://test.k6.io/api/v1/foo\`
          resp = http.request('POST', url, null, params)

          regex = new RegExp("project_id=(.*)$");
          match = resp.headers["Project"].match(regex);
          if (match) {
            correlation_vars["correlation_0"] = match[1];
          }

          correlation_vars['correlation_1'] = resp.json().is_admin

          params = {
            headers: {}, cookies: {}
          }

          url = http.url\`http://test.k6.io/api/v1/login?project_id=\${correlation_vars['correlation_0']}\`
          resp = http.request('POST', url, null, params)

          correlation_vars['correlation_2'] = resp.json().user_id
        })

        group('two', function () {
          params = {
            headers: {}, cookies: {}
          }

          url = http.url\`http://test.k6.io/api/v1/users/\${correlation_vars['correlation_2']}\`
          resp = http.request('GET', url, null, params)

          params = {
            headers: {}, cookies: {}
          }

          url = http.url\`http://test.k6.io/api/v1/users\`
          resp = http.request(
            'POST',
            url,
            \`{"user_id":"\${correlation_vars['correlation_2']}","is_admin":\${correlation_vars['correlation_1']}}\`,
            params
          )
        })

        sleep(1)
      `)

        expect(
          await prettify(generateVUCode(correlationRecording, rules, thinkTime))
        ).toBe(expectedResult)
      })

      it('should not generate correlation if rule is disabled', async () => {
        const expectedResult = await prettify(`
          let params
          let resp
          let match
          let regex
          let url
          const correlation_vars = {}

          group('one', function () {
            params = {
              headers: {}, cookies: {}
            }

            url = http.url\`http://test.k6.io/api/v1/foo\`
            resp = http.request('POST', url, null, params)

            params = {
              headers: {}, cookies: {}
            }

            url = http.url\`http://test.k6.io/api/v1/login?project_id=555\`
            resp = http.request('POST', url, null, params)
          })

          group('two', function () {
            params = {
              headers: {}, cookies: {}
            }

            url = http.url\`http://test.k6.io/api/v1/users/333\`
            resp = http.request('GET', url, null, params)

            params = {
              headers: {}, cookies: {}
            }

            url = http.url\`http://test.k6.io/api/v1/users\`
            resp = http.request(
              'POST',
              url,
              \`${JSON.stringify({ user_id: '333', is_admin: false })}\`,
              params
            )
          })

          sleep(1)
        `)

        const disabledRules = rules.map((rule) => ({ ...rule, enabled: false }))
        expect(
          await prettify(
            generateVUCode(correlationRecording, disabledRules, thinkTime)
          )
        ).toBe(expectedResult)
      })
    })

    it('should generate checks', () => {
      const rules: TestRule[] = [
        {
          type: 'verification',
          id: '1',
          enabled: true,
          filter: { path: '' },
          operator: 'equals',
          target: 'status',
          value: {
            type: 'recordedValue',
          },
        },
      ]

      const expectedResult = `
        params = { headers: {}, cookies: {} }
        url = http.url\`http://test.k6.io/api/v1/foo\`
        resp = http.request('POST', url, null, params)
        check(resp, { 'status equals 200': (r) => r.status === 200 })
      `

      expect(
        generateRequestSnippets(
          checksRecording,
          rules,
          thinkTime
        )[0]?.snippet.replace(/\s/g, '')
      ).toBe(expectedResult.replace(/\s/g, ''))
    })

    describe('Parameterization', () => {
      const recording = [
        createProxyData({
          id: '1',
          request: createRequest({
            method: 'POST',
            url: 'http://test.k6.io/api/v1/users',
            content: JSON.stringify({ user_id: '333' }),
            headers: [['content-type', 'application/json']],
          }),
        }),

        createProxyData({
          id: '2',
          request: createRequest({
            url: 'http://example.com/api/v1/users?project_id=123&csrf=321',
          }),
        }),

        createProxyData({
          id: '3',
          request: createRequest({
            url: 'http://example.com/api/v1/users?project_id=123',
          }),
        }),
      ]

      it('should replace paremeterization values', async () => {
        const rules: TestRule[] = [
          jsonRule,
          customCodeReplaceProjectId,
          customCodeReplaceCsrf,
        ]

        const expectedResult = await prettify(`
          let params
          let resp
          let match
          let regex
          let url
          const correlation_vars = {}

          function getParameterizationValue1() {
            const randomInteger = Math.floor(Math.random() * 100000)
            return randomInteger
          }
          function getParameterizationValue2() {
            return '123456'
          }
          group('Default group', function () {
            params = {
              headers: {
                'content-type': \`application/json\`
              },
              cookies: {}
            }

            url = http.url\`http://test.k6.io/api/v1/users\`
            resp = http.request('POST', url, \`${JSON.stringify({ user_id: 'TEST_ID' })}\`, params)

            params = {
              headers: {},
              cookies: {},
            }

            url = http.url\`http://example.com/api/v1/users?project_id=\${getParameterizationValue1()}&csrf=\${getParameterizationValue2()}\`
            resp = http.request('GET', url, null, params)


            params = {
              headers: {},
              cookies: {},
            }

            url = http.url\`http://example.com/api/v1/users?project_id=\${getParameterizationValue1()}\`
            resp = http.request('GET', url, null, params)
          })

          sleep(1)

        `)

        expect(
          await prettify(generateVUCode(recording, rules, thinkTime))
        ).toBe(expectedResult)
      })

      it('should not replace paremeterization values if rule is disabled', async () => {
        const disabledRules: TestRule[] = [
          { ...jsonRule, enabled: false },
          { ...customCodeReplaceProjectId, enabled: false },
          { ...customCodeReplaceCsrf, enabled: false },
        ]

        const expectedResult = await prettify(`
          let params
          let resp
          let match
          let regex
          let url
          const correlation_vars = {}

          group('Default group', function () {
            params = {
              headers: {
                'content-type': \`application/json\`
              },
              cookies: {}
            }

            url = http.url\`http://test.k6.io/api/v1/users\`
            resp = http.request('POST', url, \`${JSON.stringify({ user_id: '333' })}\`, params)

            params = {
              headers: {},
              cookies: {},
            }

            url = http.url\`http://example.com/api/v1/users?project_id=123&csrf=321\`
            resp = http.request('GET', url, null, params)


            params = {
              headers: {},
              cookies: {},
            }

            url = http.url\`http://example.com/api/v1/users?project_id=123\`
            resp = http.request('GET', url, null, params)
          })

          sleep(1)

        `)

        expect(
          await prettify(generateVUCode(recording, disabledRules, thinkTime))
        ).toBe(expectedResult)
      })
    })
  })

  describe('generateGroupSnippet', () => {
    it('should generate group snippet', () => {
      const expectedResult = `
      group('group_1', function(){});
      sleep(1)
    `

      expect(
        generateGroupSnippet('group_1', '', {
          sleepType: 'groups',
          timing: {
            type: 'fixed',
            value: 1,
          },
        }).replace(/\s/g, '')
      ).toBe(expectedResult.replace(/\s/g, ''))
    })
  })

  describe('generateRequestParams', () => {
    const generateRequest = (
      headers: Header[],
      cookies: Cookie[] = [['security', 'none']]
    ): Request => {
      return {
        method: 'POST',
        url: 'http://test.k6.io/api/v1/foo',
        headers,
        cookies: cookies,
        query: [],
        scheme: 'http',
        host: 'localhost:3000',
        content: '',
        path: '/api/v1/foo',
        timestampStart: 0,
        timestampEnd: 0,
        contentLength: 0,
        httpVersion: '1.1',
      }
    }

    it('generate request params', () => {
      const headers: Header[] = [['content-type', 'application/json']]
      const request = generateRequest(headers)

      const expectedResult = `
    {
      headers: {
        'content-type': \`application/json\`
      },
      cookies: {

      }
    }
  `
      expect(generateRequestParams(request).replace(/\s/g, '')).toBe(
        expectedResult.replace(/\s/g, '')
      )
    })

    it('generate request params with cookie header', () => {
      const headers: Header[] = [
        ['content-type', 'application/json'],
        ['Cookie', 'hello=world'],
      ]
      const request = generateRequest(headers)

      const expectedResult = `
    {
      headers: {
        'content-type': \`application/json\`
      },
      cookies: {

      }
    }
  `
      expect(generateRequestParams(request).replace(/\s/g, '')).toBe(
        expectedResult.replace(/\s/g, '')
      )
    })

    it('generate request params with cookies with correlation', () => {
      const headers: Header[] = [
        ['content-type', 'application/json'],
        ['Cookie', "security=${correlation_vars['correlation_0']}"],
      ]
      const cookies: Cookie[] = [
        ['security', "${correlation_vars['correlation_0']}"],
      ]
      const request = generateRequest(headers, cookies)

      const expectedResult = `
    {
      headers: {
        'content-type': \`application/json\`
      },
      cookies: {
        'security': {value: \`\${correlation_vars['correlation_0']}\`, replace: true}
      }
    }
  `
      expect(generateRequestParams(request)).toBe(expectedResult)
    })
  })

  describe('generateParameterizationCustomCode', () => {
    it('should generate custom code correctly', async () => {
      const idGenerator = generateSequentialInt()
      const { rule } = createParameterizationRuleInstance(
        customCodeReplaceProjectId,
        idGenerator
      )

      const customCode = generateParameterizationCustomCode([rule])

      expect(await prettify(customCode)).toBe(
        await prettify(
          `function getParameterizationValue0() { ${customCodeReplaceProjectId.value.code} }`
        )
      )
    })
  })
})
