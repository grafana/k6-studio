// This file is auto-generated by generateCdpClient.ts. DO NOT EDIT!

/* eslint-disable @typescript-eslint/no-namespace */
/* eslint-disable @typescript-eslint/no-unnecessary-type-assertion */

let id = 0
function generateId() {
  return ++id
}
type DisposeFn = () => void
type ChromeEventListener<Event = unknown> = (event: ChromeEvent<Event>) => void
export interface Transport {
  call<Return>(command: ChromeCommand): Promise<Return>
  on(event: string, listener: ChromeEventListener): DisposeFn
  off(event: string, listener: ChromeEventListener): void
  dispose(): void
}
export interface ChromeCommand {
  id: number
  sessionId: string | undefined
  method: string
  params: object
}
export interface ChromeEvent<Event = unknown> {
  sessionId?: string
  name: string
  data: Event
}
export namespace Accessibility {
  export type AXNodeId = string
  export type AXValueType =
    | 'boolean'
    | 'tristate'
    | 'booleanOrUndefined'
    | 'idref'
    | 'idrefList'
    | 'integer'
    | 'node'
    | 'nodeList'
    | 'number'
    | 'string'
    | 'computedString'
    | 'token'
    | 'tokenList'
    | 'domRelation'
    | 'role'
    | 'internalRole'
    | 'valueUndefined'
  export type AXValueSourceType =
    | 'attribute'
    | 'implicit'
    | 'style'
    | 'contents'
    | 'placeholder'
    | 'relatedElement'
  export type AXValueNativeSourceType =
    | 'description'
    | 'figcaption'
    | 'label'
    | 'labelfor'
    | 'labelwrapped'
    | 'legend'
    | 'rubyannotation'
    | 'tablecaption'
    | 'title'
    | 'other'
  export type AXValueSource = {
    type: AXValueSourceType
    value?: AXValue
    attribute?: string
    attributeValue?: AXValue
    superseded?: boolean
    nativeSource?: AXValueNativeSourceType
    nativeSourceValue?: AXValue
    invalid?: boolean
    invalidReason?: string
  }
  export type AXRelatedNode = {
    backendDOMNodeId: DOM.BackendNodeId
    idref?: string
    text?: string
  }
  export type AXProperty = { name: AXPropertyName; value: AXValue }
  export type AXValue = {
    type: AXValueType
    value?: unknown
    relatedNodes?: AXRelatedNode[]
    sources?: AXValueSource[]
  }
  export type AXPropertyName =
    | 'actions'
    | 'busy'
    | 'disabled'
    | 'editable'
    | 'focusable'
    | 'focused'
    | 'hidden'
    | 'hiddenRoot'
    | 'invalid'
    | 'keyshortcuts'
    | 'settable'
    | 'roledescription'
    | 'live'
    | 'atomic'
    | 'relevant'
    | 'root'
    | 'autocomplete'
    | 'hasPopup'
    | 'level'
    | 'multiselectable'
    | 'orientation'
    | 'multiline'
    | 'readonly'
    | 'required'
    | 'valuemin'
    | 'valuemax'
    | 'valuetext'
    | 'checked'
    | 'expanded'
    | 'modal'
    | 'pressed'
    | 'selected'
    | 'activedescendant'
    | 'controls'
    | 'describedby'
    | 'details'
    | 'errormessage'
    | 'flowto'
    | 'labelledby'
    | 'owns'
    | 'url'
  export type AXNode = {
    nodeId: AXNodeId
    ignored: boolean
    ignoredReasons?: AXProperty[]
    role?: AXValue
    chromeRole?: AXValue
    name?: AXValue
    description?: AXValue
    value?: AXValue
    properties?: AXProperty[]
    parentId?: AXNodeId
    childIds?: AXNodeId[]
    backendDOMNodeId?: DOM.BackendNodeId
    frameId?: Page.FrameId
  }
  export interface GetPartialAXTreeArgs {
    nodeId?: DOM.NodeId
    backendNodeId?: DOM.BackendNodeId
    objectId?: Runtime.RemoteObjectId
    fetchRelatives?: boolean
  }
  export interface GetFullAXTreeArgs {
    depth?: number
    frameId?: Page.FrameId
  }
  export interface GetAXNodeAndAncestorsArgs {
    nodeId?: DOM.NodeId
    backendNodeId?: DOM.BackendNodeId
    objectId?: Runtime.RemoteObjectId
  }
  export interface GetChildAXNodesArgs {
    id: AXNodeId
    frameId?: Page.FrameId
  }
  export interface QueryAXTreeArgs {
    nodeId?: DOM.NodeId
    backendNodeId?: DOM.BackendNodeId
    objectId?: Runtime.RemoteObjectId
    accessibleName?: string
    role?: string
  }
  export interface GetPartialAXTreeResult {
    nodes: AXNode[]
  }
  export interface GetFullAXTreeResult {
    nodes: AXNode[]
  }
  export interface GetRootAXNodeResult {
    node: AXNode
  }
  export interface GetAXNodeAndAncestorsResult {
    nodes: AXNode[]
  }
  export interface GetChildAXNodesResult {
    nodes: AXNode[]
  }
  export interface QueryAXTreeResult {
    nodes: AXNode[]
  }
  export interface LoadCompleteEvent {
    root: AXNode
  }
  export interface NodesUpdatedEvent {
    nodes: AXNode[]
  }
  export interface EventMap {
    loadComplete: LoadCompleteEvent
    nodesUpdated: NodesUpdatedEvent
  }
}
export namespace Animation {
  export type Animation = {
    id: string
    name: string
    pausedState: boolean
    playState: string
    playbackRate: number
    startTime: number
    currentTime: number
    type: 'CSSTransition' | 'CSSAnimation' | 'WebAnimation'
    source?: AnimationEffect
    cssId?: string
    viewOrScrollTimeline?: ViewOrScrollTimeline
  }
  export type ViewOrScrollTimeline = {
    sourceNodeId?: DOM.BackendNodeId
    startOffset?: number
    endOffset?: number
    subjectNodeId?: DOM.BackendNodeId
    axis: DOM.ScrollOrientation
  }
  export type AnimationEffect = {
    delay: number
    endDelay: number
    iterationStart: number
    iterations: number
    duration: number
    direction: string
    fill: string
    backendNodeId?: DOM.BackendNodeId
    keyframesRule?: KeyframesRule
    easing: string
  }
  export type KeyframesRule = { name?: string; keyframes: KeyframeStyle[] }
  export type KeyframeStyle = { offset: string; easing: string }
  export interface SeekAnimationsArgs {
    animations: string[]
    currentTime: number
  }
  export interface SetPausedArgs {
    animations: string[]
    paused: boolean
  }
  export interface SetTimingArgs {
    animationId: string
    duration: number
    delay: number
  }
  export interface GetCurrentTimeResult {
    currentTime: number
  }
  export interface GetPlaybackRateResult {
    playbackRate: number
  }
  export interface ResolveAnimationResult {
    remoteObject: Runtime.RemoteObject
  }
  export interface AnimationCanceledEvent {
    id: string
  }
  export interface AnimationCreatedEvent {
    id: string
  }
  export interface AnimationStartedEvent {
    animation: Animation
  }
  export interface AnimationUpdatedEvent {
    animation: Animation
  }
  export interface EventMap {
    animationCanceled: AnimationCanceledEvent
    animationCreated: AnimationCreatedEvent
    animationStarted: AnimationStartedEvent
    animationUpdated: AnimationUpdatedEvent
  }
}
export namespace Audits {
  export type AffectedCookie = { name: string; path: string; domain: string }
  export type AffectedRequest = { requestId?: Network.RequestId; url: string }
  export type AffectedFrame = { frameId: Page.FrameId }
  export type CookieExclusionReason =
    | 'ExcludeSameSiteUnspecifiedTreatedAsLax'
    | 'ExcludeSameSiteNoneInsecure'
    | 'ExcludeSameSiteLax'
    | 'ExcludeSameSiteStrict'
    | 'ExcludeInvalidSameParty'
    | 'ExcludeSamePartyCrossPartyContext'
    | 'ExcludeDomainNonASCII'
    | 'ExcludeThirdPartyCookieBlockedInFirstPartySet'
    | 'ExcludeThirdPartyPhaseout'
    | 'ExcludePortMismatch'
    | 'ExcludeSchemeMismatch'
  export type CookieWarningReason =
    | 'WarnSameSiteUnspecifiedCrossSiteContext'
    | 'WarnSameSiteNoneInsecure'
    | 'WarnSameSiteUnspecifiedLaxAllowUnsafe'
    | 'WarnSameSiteStrictLaxDowngradeStrict'
    | 'WarnSameSiteStrictCrossDowngradeStrict'
    | 'WarnSameSiteStrictCrossDowngradeLax'
    | 'WarnSameSiteLaxCrossDowngradeStrict'
    | 'WarnSameSiteLaxCrossDowngradeLax'
    | 'WarnAttributeValueExceedsMaxSize'
    | 'WarnDomainNonASCII'
    | 'WarnThirdPartyPhaseout'
    | 'WarnCrossSiteRedirectDowngradeChangesInclusion'
    | 'WarnDeprecationTrialMetadata'
    | 'WarnThirdPartyCookieHeuristic'
  export type CookieOperation = 'SetCookie' | 'ReadCookie'
  export type InsightType = 'GitHubResource' | 'GracePeriod' | 'Heuristics'
  export type CookieIssueInsight = { type: InsightType; tableEntryUrl?: string }
  export type CookieIssueDetails = {
    cookie?: AffectedCookie
    rawCookieLine?: string
    cookieWarningReasons: CookieWarningReason[]
    cookieExclusionReasons: CookieExclusionReason[]
    operation: CookieOperation
    siteForCookies?: string
    cookieUrl?: string
    request?: AffectedRequest
    insight?: CookieIssueInsight
  }
  export type MixedContentResolutionStatus =
    | 'MixedContentBlocked'
    | 'MixedContentAutomaticallyUpgraded'
    | 'MixedContentWarning'
  export type MixedContentResourceType =
    | 'AttributionSrc'
    | 'Audio'
    | 'Beacon'
    | 'CSPReport'
    | 'Download'
    | 'EventSource'
    | 'Favicon'
    | 'Font'
    | 'Form'
    | 'Frame'
    | 'Image'
    | 'Import'
    | 'JSON'
    | 'Manifest'
    | 'Ping'
    | 'PluginData'
    | 'PluginResource'
    | 'Prefetch'
    | 'Resource'
    | 'Script'
    | 'ServiceWorker'
    | 'SharedWorker'
    | 'SpeculationRules'
    | 'Stylesheet'
    | 'Track'
    | 'Video'
    | 'Worker'
    | 'XMLHttpRequest'
    | 'XSLT'
  export type MixedContentIssueDetails = {
    resourceType?: MixedContentResourceType
    resolutionStatus: MixedContentResolutionStatus
    insecureURL: string
    mainResourceURL: string
    request?: AffectedRequest
    frame?: AffectedFrame
  }
  export type BlockedByResponseReason =
    | 'CoepFrameResourceNeedsCoepHeader'
    | 'CoopSandboxedIFrameCannotNavigateToCoopPage'
    | 'CorpNotSameOrigin'
    | 'CorpNotSameOriginAfterDefaultedToSameOriginByCoep'
    | 'CorpNotSameOriginAfterDefaultedToSameOriginByDip'
    | 'CorpNotSameOriginAfterDefaultedToSameOriginByCoepAndDip'
    | 'CorpNotSameSite'
    | 'SRIMessageSignatureMismatch'
  export type BlockedByResponseIssueDetails = {
    request: AffectedRequest
    parentFrame?: AffectedFrame
    blockedFrame?: AffectedFrame
    reason: BlockedByResponseReason
  }
  export type HeavyAdResolutionStatus = 'HeavyAdBlocked' | 'HeavyAdWarning'
  export type HeavyAdReason =
    | 'NetworkTotalLimit'
    | 'CpuTotalLimit'
    | 'CpuPeakLimit'
  export type HeavyAdIssueDetails = {
    resolution: HeavyAdResolutionStatus
    reason: HeavyAdReason
    frame: AffectedFrame
  }
  export type ContentSecurityPolicyViolationType =
    | 'kInlineViolation'
    | 'kEvalViolation'
    | 'kURLViolation'
    | 'kSRIViolation'
    | 'kTrustedTypesSinkViolation'
    | 'kTrustedTypesPolicyViolation'
    | 'kWasmEvalViolation'
  export type SourceCodeLocation = {
    scriptId?: Runtime.ScriptId
    url: string
    lineNumber: number
    columnNumber: number
  }
  export type ContentSecurityPolicyIssueDetails = {
    blockedURL?: string
    violatedDirective: string
    isReportOnly: boolean
    contentSecurityPolicyViolationType: ContentSecurityPolicyViolationType
    frameAncestor?: AffectedFrame
    sourceCodeLocation?: SourceCodeLocation
    violatingNodeId?: DOM.BackendNodeId
  }
  export type SharedArrayBufferIssueType = 'TransferIssue' | 'CreationIssue'
  export type SharedArrayBufferIssueDetails = {
    sourceCodeLocation: SourceCodeLocation
    isWarning: boolean
    type: SharedArrayBufferIssueType
  }
  export type LowTextContrastIssueDetails = {
    violatingNodeId: DOM.BackendNodeId
    violatingNodeSelector: string
    contrastRatio: number
    thresholdAA: number
    thresholdAAA: number
    fontSize: string
    fontWeight: string
  }
  export type CorsIssueDetails = {
    corsErrorStatus: Network.CorsErrorStatus
    isWarning: boolean
    request: AffectedRequest
    location?: SourceCodeLocation
    initiatorOrigin?: string
    resourceIPAddressSpace?: Network.IPAddressSpace
    clientSecurityState?: Network.ClientSecurityState
  }
  export type AttributionReportingIssueType =
    | 'PermissionPolicyDisabled'
    | 'UntrustworthyReportingOrigin'
    | 'InsecureContext'
    | 'InvalidHeader'
    | 'InvalidRegisterTriggerHeader'
    | 'SourceAndTriggerHeaders'
    | 'SourceIgnored'
    | 'TriggerIgnored'
    | 'OsSourceIgnored'
    | 'OsTriggerIgnored'
    | 'InvalidRegisterOsSourceHeader'
    | 'InvalidRegisterOsTriggerHeader'
    | 'WebAndOsHeaders'
    | 'NoWebOrOsSupport'
    | 'NavigationRegistrationWithoutTransientUserActivation'
    | 'InvalidInfoHeader'
    | 'NoRegisterSourceHeader'
    | 'NoRegisterTriggerHeader'
    | 'NoRegisterOsSourceHeader'
    | 'NoRegisterOsTriggerHeader'
    | 'NavigationRegistrationUniqueScopeAlreadySet'
  export type SharedDictionaryError =
    | 'UseErrorCrossOriginNoCorsRequest'
    | 'UseErrorDictionaryLoadFailure'
    | 'UseErrorMatchingDictionaryNotUsed'
    | 'UseErrorUnexpectedContentDictionaryHeader'
    | 'WriteErrorCossOriginNoCorsRequest'
    | 'WriteErrorDisallowedBySettings'
    | 'WriteErrorExpiredResponse'
    | 'WriteErrorFeatureDisabled'
    | 'WriteErrorInsufficientResources'
    | 'WriteErrorInvalidMatchField'
    | 'WriteErrorInvalidStructuredHeader'
    | 'WriteErrorNavigationRequest'
    | 'WriteErrorNoMatchField'
    | 'WriteErrorNonListMatchDestField'
    | 'WriteErrorNonSecureContext'
    | 'WriteErrorNonStringIdField'
    | 'WriteErrorNonStringInMatchDestList'
    | 'WriteErrorNonStringMatchField'
    | 'WriteErrorNonTokenTypeField'
    | 'WriteErrorRequestAborted'
    | 'WriteErrorShuttingDown'
    | 'WriteErrorTooLongIdField'
    | 'WriteErrorUnsupportedType'
  export type SRIMessageSignatureError =
    | 'MissingSignatureHeader'
    | 'MissingSignatureInputHeader'
    | 'InvalidSignatureHeader'
    | 'InvalidSignatureInputHeader'
    | 'SignatureHeaderValueIsNotByteSequence'
    | 'SignatureHeaderValueIsParameterized'
    | 'SignatureHeaderValueIsIncorrectLength'
    | 'SignatureInputHeaderMissingLabel'
    | 'SignatureInputHeaderValueNotInnerList'
    | 'SignatureInputHeaderValueMissingComponents'
    | 'SignatureInputHeaderInvalidComponentType'
    | 'SignatureInputHeaderInvalidComponentName'
    | 'SignatureInputHeaderInvalidHeaderComponentParameter'
    | 'SignatureInputHeaderInvalidDerivedComponentParameter'
    | 'SignatureInputHeaderKeyIdLength'
    | 'SignatureInputHeaderInvalidParameter'
    | 'SignatureInputHeaderMissingRequiredParameters'
    | 'ValidationFailedSignatureExpired'
    | 'ValidationFailedInvalidLength'
    | 'ValidationFailedSignatureMismatch'
    | 'ValidationFailedIntegrityMismatch'
  export type AttributionReportingIssueDetails = {
    violationType: AttributionReportingIssueType
    request?: AffectedRequest
    violatingNodeId?: DOM.BackendNodeId
    invalidParameter?: string
  }
  export type QuirksModeIssueDetails = {
    isLimitedQuirksMode: boolean
    documentNodeId: DOM.BackendNodeId
    url: string
    frameId: Page.FrameId
    loaderId: Network.LoaderId
  }
  export type NavigatorUserAgentIssueDetails = {
    url: string
    location?: SourceCodeLocation
  }
  export type SharedDictionaryIssueDetails = {
    sharedDictionaryError: SharedDictionaryError
    request: AffectedRequest
  }
  export type SRIMessageSignatureIssueDetails = {
    error: SRIMessageSignatureError
    signatureBase: string
    integrityAssertions: string[]
    request: AffectedRequest
  }
  export type GenericIssueErrorType =
    | 'FormLabelForNameError'
    | 'FormDuplicateIdForInputError'
    | 'FormInputWithNoLabelError'
    | 'FormAutocompleteAttributeEmptyError'
    | 'FormEmptyIdAndNameAttributesForInputError'
    | 'FormAriaLabelledByToNonExistingId'
    | 'FormInputAssignedAutocompleteValueToIdOrNameAttributeError'
    | 'FormLabelHasNeitherForNorNestedInput'
    | 'FormLabelForMatchesNonExistingIdError'
    | 'FormInputHasWrongButWellIntendedAutocompleteValueError'
    | 'ResponseWasBlockedByORB'
  export type GenericIssueDetails = {
    errorType: GenericIssueErrorType
    frameId?: Page.FrameId
    violatingNodeId?: DOM.BackendNodeId
    violatingNodeAttribute?: string
    request?: AffectedRequest
  }
  export type DeprecationIssueDetails = {
    affectedFrame?: AffectedFrame
    sourceCodeLocation: SourceCodeLocation
    type: string
  }
  export type BounceTrackingIssueDetails = { trackingSites: string[] }
  export type CookieDeprecationMetadataIssueDetails = {
    allowedSites: string[]
    optOutPercentage: number
    isOptOutTopLevel: boolean
    operation: CookieOperation
  }
  export type ClientHintIssueReason =
    | 'MetaTagAllowListInvalidOrigin'
    | 'MetaTagModifiedHTML'
  export type FederatedAuthRequestIssueDetails = {
    federatedAuthRequestIssueReason: FederatedAuthRequestIssueReason
  }
  export type FederatedAuthRequestIssueReason =
    | 'ShouldEmbargo'
    | 'TooManyRequests'
    | 'WellKnownHttpNotFound'
    | 'WellKnownNoResponse'
    | 'WellKnownInvalidResponse'
    | 'WellKnownListEmpty'
    | 'WellKnownInvalidContentType'
    | 'ConfigNotInWellKnown'
    | 'WellKnownTooBig'
    | 'ConfigHttpNotFound'
    | 'ConfigNoResponse'
    | 'ConfigInvalidResponse'
    | 'ConfigInvalidContentType'
    | 'ClientMetadataHttpNotFound'
    | 'ClientMetadataNoResponse'
    | 'ClientMetadataInvalidResponse'
    | 'ClientMetadataInvalidContentType'
    | 'IdpNotPotentiallyTrustworthy'
    | 'DisabledInSettings'
    | 'DisabledInFlags'
    | 'ErrorFetchingSignin'
    | 'InvalidSigninResponse'
    | 'AccountsHttpNotFound'
    | 'AccountsNoResponse'
    | 'AccountsInvalidResponse'
    | 'AccountsListEmpty'
    | 'AccountsInvalidContentType'
    | 'IdTokenHttpNotFound'
    | 'IdTokenNoResponse'
    | 'IdTokenInvalidResponse'
    | 'IdTokenIdpErrorResponse'
    | 'IdTokenCrossSiteIdpErrorResponse'
    | 'IdTokenInvalidRequest'
    | 'IdTokenInvalidContentType'
    | 'ErrorIdToken'
    | 'Canceled'
    | 'RpPageNotVisible'
    | 'SilentMediationFailure'
    | 'ThirdPartyCookiesBlocked'
    | 'NotSignedInWithIdp'
    | 'MissingTransientUserActivation'
    | 'ReplacedByActiveMode'
    | 'InvalidFieldsSpecified'
    | 'RelyingPartyOriginIsOpaque'
    | 'TypeNotMatching'
    | 'UiDismissedNoEmbargo'
    | 'CorsError'
    | 'SuppressedBySegmentationPlatform'
  export type FederatedAuthUserInfoRequestIssueDetails = {
    federatedAuthUserInfoRequestIssueReason: FederatedAuthUserInfoRequestIssueReason
  }
  export type FederatedAuthUserInfoRequestIssueReason =
    | 'NotSameOrigin'
    | 'NotIframe'
    | 'NotPotentiallyTrustworthy'
    | 'NoApiPermission'
    | 'NotSignedInWithIdp'
    | 'NoAccountSharingPermission'
    | 'InvalidConfigOrWellKnown'
    | 'InvalidAccountsResponse'
    | 'NoReturningUserFromFetchedAccounts'
  export type ClientHintIssueDetails = {
    sourceCodeLocation: SourceCodeLocation
    clientHintIssueReason: ClientHintIssueReason
  }
  export type FailedRequestInfo = {
    url: string
    failureMessage: string
    requestId?: Network.RequestId
  }
  export type PartitioningBlobURLInfo =
    | 'BlockedCrossPartitionFetching'
    | 'EnforceNoopenerForNavigation'
  export type PartitioningBlobURLIssueDetails = {
    url: string
    partitioningBlobURLInfo: PartitioningBlobURLInfo
  }
  export type SelectElementAccessibilityIssueReason =
    | 'DisallowedSelectChild'
    | 'DisallowedOptGroupChild'
    | 'NonPhrasingContentOptionChild'
    | 'InteractiveContentOptionChild'
    | 'InteractiveContentLegendChild'
  export type SelectElementAccessibilityIssueDetails = {
    nodeId: DOM.BackendNodeId
    selectElementAccessibilityIssueReason: SelectElementAccessibilityIssueReason
    hasDisallowedAttributes: boolean
  }
  export type StyleSheetLoadingIssueReason = 'LateImportRule' | 'RequestFailed'
  export type StylesheetLoadingIssueDetails = {
    sourceCodeLocation: SourceCodeLocation
    styleSheetLoadingIssueReason: StyleSheetLoadingIssueReason
    failedRequestInfo?: FailedRequestInfo
  }
  export type PropertyRuleIssueReason =
    | 'InvalidSyntax'
    | 'InvalidInitialValue'
    | 'InvalidInherits'
    | 'InvalidName'
  export type PropertyRuleIssueDetails = {
    sourceCodeLocation: SourceCodeLocation
    propertyRuleIssueReason: PropertyRuleIssueReason
    propertyValue?: string
  }
  export type UserReidentificationIssueType =
    | 'BlockedFrameNavigation'
    | 'BlockedSubresource'
  export type UserReidentificationIssueDetails = {
    type: UserReidentificationIssueType
    request?: AffectedRequest
  }
  export type InspectorIssueCode =
    | 'CookieIssue'
    | 'MixedContentIssue'
    | 'BlockedByResponseIssue'
    | 'HeavyAdIssue'
    | 'ContentSecurityPolicyIssue'
    | 'SharedArrayBufferIssue'
    | 'LowTextContrastIssue'
    | 'CorsIssue'
    | 'AttributionReportingIssue'
    | 'QuirksModeIssue'
    | 'PartitioningBlobURLIssue'
    | 'NavigatorUserAgentIssue'
    | 'GenericIssue'
    | 'DeprecationIssue'
    | 'ClientHintIssue'
    | 'FederatedAuthRequestIssue'
    | 'BounceTrackingIssue'
    | 'CookieDeprecationMetadataIssue'
    | 'StylesheetLoadingIssue'
    | 'FederatedAuthUserInfoRequestIssue'
    | 'PropertyRuleIssue'
    | 'SharedDictionaryIssue'
    | 'SelectElementAccessibilityIssue'
    | 'SRIMessageSignatureIssue'
    | 'UserReidentificationIssue'
  export type InspectorIssueDetails = {
    cookieIssueDetails?: CookieIssueDetails
    mixedContentIssueDetails?: MixedContentIssueDetails
    blockedByResponseIssueDetails?: BlockedByResponseIssueDetails
    heavyAdIssueDetails?: HeavyAdIssueDetails
    contentSecurityPolicyIssueDetails?: ContentSecurityPolicyIssueDetails
    sharedArrayBufferIssueDetails?: SharedArrayBufferIssueDetails
    lowTextContrastIssueDetails?: LowTextContrastIssueDetails
    corsIssueDetails?: CorsIssueDetails
    attributionReportingIssueDetails?: AttributionReportingIssueDetails
    quirksModeIssueDetails?: QuirksModeIssueDetails
    partitioningBlobURLIssueDetails?: PartitioningBlobURLIssueDetails
    navigatorUserAgentIssueDetails?: NavigatorUserAgentIssueDetails
    genericIssueDetails?: GenericIssueDetails
    deprecationIssueDetails?: DeprecationIssueDetails
    clientHintIssueDetails?: ClientHintIssueDetails
    federatedAuthRequestIssueDetails?: FederatedAuthRequestIssueDetails
    bounceTrackingIssueDetails?: BounceTrackingIssueDetails
    cookieDeprecationMetadataIssueDetails?: CookieDeprecationMetadataIssueDetails
    stylesheetLoadingIssueDetails?: StylesheetLoadingIssueDetails
    propertyRuleIssueDetails?: PropertyRuleIssueDetails
    federatedAuthUserInfoRequestIssueDetails?: FederatedAuthUserInfoRequestIssueDetails
    sharedDictionaryIssueDetails?: SharedDictionaryIssueDetails
    selectElementAccessibilityIssueDetails?: SelectElementAccessibilityIssueDetails
    sriMessageSignatureIssueDetails?: SRIMessageSignatureIssueDetails
    userReidentificationIssueDetails?: UserReidentificationIssueDetails
  }
  export type IssueId = string
  export type InspectorIssue = {
    code: InspectorIssueCode
    details: InspectorIssueDetails
    issueId?: IssueId
  }
  export interface GetEncodedResponseArgs {
    requestId: Network.RequestId
    encoding: 'webp' | 'jpeg' | 'png'
    quality?: number
    sizeOnly?: boolean
  }
  export interface GetEncodedResponseResult {
    body: string
    originalSize: number
    encodedSize: number
  }
  export interface CheckFormsIssuesResult {
    formIssues: GenericIssueDetails[]
  }
  export interface IssueAddedEvent {
    issue: InspectorIssue
  }
  export interface EventMap {
    issueAdded: IssueAddedEvent
  }
}
export namespace Extensions {
  export type StorageArea = 'session' | 'local' | 'sync' | 'managed'
  export interface GetStorageItemsArgs {
    id: string
    storageArea: StorageArea
    keys?: string[]
  }
  export interface RemoveStorageItemsArgs {
    id: string
    storageArea: StorageArea
    keys: string[]
  }
  export interface ClearStorageItemsArgs {
    id: string
    storageArea: StorageArea
  }
  export interface SetStorageItemsArgs {
    id: string
    storageArea: StorageArea
    values: Record<string, unknown>
  }
  export interface LoadUnpackedResult {
    id: string
  }
  export interface GetStorageItemsResult {
    data: Record<string, unknown>
  }
}
export namespace Autofill {
  export type CreditCard = {
    number: string
    name: string
    expiryMonth: string
    expiryYear: string
    cvc: string
  }
  export type AddressField = { name: string; value: string }
  export type AddressFields = { fields: AddressField[] }
  export type Address = { fields: AddressField[] }
  export type AddressUI = { addressFields: AddressFields[] }
  export type FillingStrategy = 'autocompleteAttribute' | 'autofillInferred'
  export type FilledField = {
    htmlType: string
    id: string
    name: string
    value: string
    autofillType: string
    fillingStrategy: FillingStrategy
    frameId: Page.FrameId
    fieldId: DOM.BackendNodeId
  }
  export interface TriggerArgs {
    fieldId: DOM.BackendNodeId
    frameId?: Page.FrameId
    card: CreditCard
  }
  export interface AddressFormFilledEvent {
    filledFields: FilledField[]
    addressUi: AddressUI
  }
  export interface EventMap {
    addressFormFilled: AddressFormFilledEvent
  }
}
export namespace BackgroundService {
  export type ServiceName =
    | 'backgroundFetch'
    | 'backgroundSync'
    | 'pushMessaging'
    | 'notifications'
    | 'paymentHandler'
    | 'periodicBackgroundSync'
  export type EventMetadata = { key: string; value: string }
  export type BackgroundServiceEvent = {
    timestamp: Network.TimeSinceEpoch
    origin: string
    serviceWorkerRegistrationId: ServiceWorker.RegistrationID
    service: ServiceName
    eventName: string
    instanceId: string
    eventMetadata: EventMetadata[]
    storageKey: string
  }
  export interface SetRecordingArgs {
    shouldRecord: boolean
    service: ServiceName
  }
  export interface RecordingStateChangedEvent {
    isRecording: boolean
    service: ServiceName
  }
  export interface BackgroundServiceEventReceivedEvent {
    backgroundServiceEvent: BackgroundServiceEvent
  }
  export interface EventMap {
    recordingStateChanged: RecordingStateChangedEvent
    backgroundServiceEventReceived: BackgroundServiceEventReceivedEvent
  }
}
export namespace Browser {
  export type BrowserContextID = string
  export type WindowID = number
  export type WindowState = 'normal' | 'minimized' | 'maximized' | 'fullscreen'
  export type Bounds = {
    left?: number
    top?: number
    width?: number
    height?: number
    windowState?: WindowState
  }
  export type PermissionType =
    | 'ar'
    | 'audioCapture'
    | 'automaticFullscreen'
    | 'backgroundFetch'
    | 'backgroundSync'
    | 'cameraPanTiltZoom'
    | 'capturedSurfaceControl'
    | 'clipboardReadWrite'
    | 'clipboardSanitizedWrite'
    | 'displayCapture'
    | 'durableStorage'
    | 'geolocation'
    | 'handTracking'
    | 'idleDetection'
    | 'keyboardLock'
    | 'localFonts'
    | 'localNetworkAccess'
    | 'midi'
    | 'midiSysex'
    | 'nfc'
    | 'notifications'
    | 'paymentHandler'
    | 'periodicBackgroundSync'
    | 'pointerLock'
    | 'protectedMediaIdentifier'
    | 'sensors'
    | 'smartCard'
    | 'speakerSelection'
    | 'storageAccess'
    | 'topLevelStorageAccess'
    | 'videoCapture'
    | 'vr'
    | 'wakeLockScreen'
    | 'wakeLockSystem'
    | 'webAppInstallation'
    | 'webPrinting'
    | 'windowManagement'
  export type PermissionSetting = 'granted' | 'denied' | 'prompt'
  export type PermissionDescriptor = {
    name: string
    sysex?: boolean
    userVisibleOnly?: boolean
    allowWithoutSanitization?: boolean
    allowWithoutGesture?: boolean
    panTiltZoom?: boolean
  }
  export type BrowserCommandId = 'openTabSearch' | 'closeTabSearch' | 'openGlic'
  export type Bucket = { low: number; high: number; count: number }
  export type Histogram = {
    name: string
    sum: number
    count: number
    buckets: Bucket[]
  }
  export type PrivacySandboxAPI =
    | 'BiddingAndAuctionServices'
    | 'TrustedKeyValue'
  export interface SetPermissionArgs {
    permission: PermissionDescriptor
    setting: PermissionSetting
    origin?: string
    browserContextId?: BrowserContextID
  }
  export interface GrantPermissionsArgs {
    permissions: PermissionType[]
    origin?: string
    browserContextId?: BrowserContextID
  }
  export interface SetDownloadBehaviorArgs {
    behavior: 'deny' | 'allow' | 'allowAndName' | 'default'
    browserContextId?: BrowserContextID
    downloadPath?: string
    eventsEnabled?: boolean
  }
  export interface CancelDownloadArgs {
    guid: string
    browserContextId?: BrowserContextID
  }
  export interface GetHistogramsArgs {
    query?: string
    delta?: boolean
  }
  export interface GetHistogramArgs {
    name: string
    delta?: boolean
  }
  export interface SetWindowBoundsArgs {
    windowId: WindowID
    bounds: Bounds
  }
  export interface SetDockTileArgs {
    badgeLabel?: string
    image?: string
  }
  export interface AddPrivacySandboxCoordinatorKeyConfigArgs {
    api: PrivacySandboxAPI
    coordinatorOrigin: string
    keyConfig: string
    browserContextId?: BrowserContextID
  }
  export interface GetVersionResult {
    protocolVersion: string
    product: string
    revision: string
    userAgent: string
    jsVersion: string
  }
  export interface GetBrowserCommandLineResult {
    arguments: string[]
  }
  export interface GetHistogramsResult {
    histograms: Histogram[]
  }
  export interface GetHistogramResult {
    histogram: Histogram
  }
  export interface GetWindowBoundsResult {
    bounds: Bounds
  }
  export interface GetWindowForTargetResult {
    windowId: WindowID
    bounds: Bounds
  }
  export interface DownloadWillBeginEvent {
    frameId: Page.FrameId
    guid: string
    url: string
    suggestedFilename: string
  }
  export interface DownloadProgressEvent {
    guid: string
    totalBytes: number
    receivedBytes: number
    state: 'inProgress' | 'completed' | 'canceled'
    filePath: string
  }
  export interface EventMap {
    downloadWillBegin: DownloadWillBeginEvent
    downloadProgress: DownloadProgressEvent
  }
}
export namespace CSS {
  export type StyleSheetId = string
  export type StyleSheetOrigin =
    | 'injected'
    | 'user-agent'
    | 'inspector'
    | 'regular'
  export type PseudoElementMatches = {
    pseudoType: DOM.PseudoType
    pseudoIdentifier?: string
    matches: RuleMatch[]
  }
  export type CSSAnimationStyle = { name?: string; style: CSSStyle }
  export type InheritedStyleEntry = {
    inlineStyle?: CSSStyle
    matchedCSSRules: RuleMatch[]
  }
  export type InheritedAnimatedStyleEntry = {
    animationStyles?: CSSAnimationStyle[]
    transitionsStyle?: CSSStyle
  }
  export type InheritedPseudoElementMatches = {
    pseudoElements: PseudoElementMatches[]
  }
  export type RuleMatch = { rule: CSSRule; matchingSelectors: number[] }
  export type Value = {
    text: string
    range?: SourceRange
    specificity?: Specificity
  }
  export type Specificity = { a: number; b: number; c: number }
  export type SelectorList = { selectors: Value[]; text: string }
  export type CSSStyleSheetHeader = {
    styleSheetId: StyleSheetId
    frameId: Page.FrameId
    sourceURL: string
    sourceMapURL?: string
    origin: StyleSheetOrigin
    title: string
    ownerNode?: DOM.BackendNodeId
    disabled: boolean
    hasSourceURL?: boolean
    isInline: boolean
    isMutable: boolean
    isConstructed: boolean
    startLine: number
    startColumn: number
    length: number
    endLine: number
    endColumn: number
    loadingFailed?: boolean
  }
  export type CSSRule = {
    styleSheetId?: StyleSheetId
    selectorList: SelectorList
    nestingSelectors?: string[]
    origin: StyleSheetOrigin
    style: CSSStyle
    media?: CSSMedia[]
    containerQueries?: CSSContainerQuery[]
    supports?: CSSSupports[]
    layers?: CSSLayer[]
    scopes?: CSSScope[]
    ruleTypes?: CSSRuleType[]
    startingStyles?: CSSStartingStyle[]
  }
  export type CSSRuleType =
    | 'MediaRule'
    | 'SupportsRule'
    | 'ContainerRule'
    | 'LayerRule'
    | 'ScopeRule'
    | 'StyleRule'
    | 'StartingStyleRule'
  export type RuleUsage = {
    styleSheetId: StyleSheetId
    startOffset: number
    endOffset: number
    used: boolean
  }
  export type SourceRange = {
    startLine: number
    startColumn: number
    endLine: number
    endColumn: number
  }
  export type ShorthandEntry = {
    name: string
    value: string
    important?: boolean
  }
  export type CSSComputedStyleProperty = { name: string; value: string }
  export type CSSStyle = {
    styleSheetId?: StyleSheetId
    cssProperties: CSSProperty[]
    shorthandEntries: ShorthandEntry[]
    cssText?: string
    range?: SourceRange
  }
  export type CSSProperty = {
    name: string
    value: string
    important?: boolean
    implicit?: boolean
    text?: string
    parsedOk?: boolean
    disabled?: boolean
    range?: SourceRange
    longhandProperties?: CSSProperty[]
  }
  export type CSSMedia = {
    text: string
    source: 'mediaRule' | 'importRule' | 'linkedSheet' | 'inlineSheet'
    sourceURL?: string
    range?: SourceRange
    styleSheetId?: StyleSheetId
    mediaList?: MediaQuery[]
  }
  export type MediaQuery = {
    expressions: MediaQueryExpression[]
    active: boolean
  }
  export type MediaQueryExpression = {
    value: number
    unit: string
    feature: string
    valueRange?: SourceRange
    computedLength?: number
  }
  export type CSSContainerQuery = {
    text: string
    range?: SourceRange
    styleSheetId?: StyleSheetId
    name?: string
    physicalAxes?: DOM.PhysicalAxes
    logicalAxes?: DOM.LogicalAxes
    queriesScrollState?: boolean
  }
  export type CSSSupports = {
    text: string
    active: boolean
    range?: SourceRange
    styleSheetId?: StyleSheetId
  }
  export type CSSScope = {
    text: string
    range?: SourceRange
    styleSheetId?: StyleSheetId
  }
  export type CSSLayer = {
    text: string
    range?: SourceRange
    styleSheetId?: StyleSheetId
  }
  export type CSSStartingStyle = {
    range?: SourceRange
    styleSheetId?: StyleSheetId
  }
  export type CSSLayerData = {
    name: string
    subLayers?: CSSLayerData[]
    order: number
  }
  export type PlatformFontUsage = {
    familyName: string
    postScriptName: string
    isCustomFont: boolean
    glyphCount: number
  }
  export type FontVariationAxis = {
    tag: string
    name: string
    minValue: number
    maxValue: number
    defaultValue: number
  }
  export type FontFace = {
    fontFamily: string
    fontStyle: string
    fontVariant: string
    fontWeight: string
    fontStretch: string
    fontDisplay: string
    unicodeRange: string
    src: string
    platformFontFamily: string
    fontVariationAxes?: FontVariationAxis[]
  }
  export type CSSTryRule = {
    styleSheetId?: StyleSheetId
    origin: StyleSheetOrigin
    style: CSSStyle
  }
  export type CSSPositionTryRule = {
    name: Value
    styleSheetId?: StyleSheetId
    origin: StyleSheetOrigin
    style: CSSStyle
    active: boolean
  }
  export type CSSKeyframesRule = {
    animationName: Value
    keyframes: CSSKeyframeRule[]
  }
  export type CSSPropertyRegistration = {
    propertyName: string
    initialValue?: Value
    inherits: boolean
    syntax: string
  }
  export type CSSFontPaletteValuesRule = {
    styleSheetId?: StyleSheetId
    origin: StyleSheetOrigin
    fontPaletteName: Value
    style: CSSStyle
  }
  export type CSSPropertyRule = {
    styleSheetId?: StyleSheetId
    origin: StyleSheetOrigin
    propertyName: Value
    style: CSSStyle
  }
  export type CSSFunctionParameter = { name: string; type: string }
  export type CSSFunctionConditionNode = {
    media?: CSSMedia
    containerQueries?: CSSContainerQuery
    supports?: CSSSupports
    children: CSSFunctionNode[]
    conditionText: string
  }
  export type CSSFunctionNode = {
    condition?: CSSFunctionConditionNode
    style?: CSSStyle
  }
  export type CSSFunctionRule = {
    name: Value
    styleSheetId?: StyleSheetId
    origin: StyleSheetOrigin
    parameters: CSSFunctionParameter[]
    children: CSSFunctionNode[]
  }
  export type CSSKeyframeRule = {
    styleSheetId?: StyleSheetId
    origin: StyleSheetOrigin
    keyText: Value
    style: CSSStyle
  }
  export type StyleDeclarationEdit = {
    styleSheetId: StyleSheetId
    range: SourceRange
    text: string
  }
  export interface AddRuleArgs {
    styleSheetId: StyleSheetId
    ruleText: string
    location: SourceRange
    nodeForPropertySyntaxValidation?: DOM.NodeId
  }
  export interface CreateStyleSheetArgs {
    frameId: Page.FrameId
    force?: boolean
  }
  export interface ForcePseudoStateArgs {
    nodeId: DOM.NodeId
    forcedPseudoClasses: string[]
  }
  export interface ForceStartingStyleArgs {
    nodeId: DOM.NodeId
    forced: boolean
  }
  export interface ResolveValuesArgs {
    values: string[]
    nodeId: DOM.NodeId
    propertyName?: string
    pseudoType?: DOM.PseudoType
    pseudoIdentifier?: string
  }
  export interface GetLonghandPropertiesArgs {
    shorthandName: string
    value: string
  }
  export interface GetLocationForSelectorArgs {
    styleSheetId: StyleSheetId
    selectorText: string
  }
  export interface SetEffectivePropertyValueForNodeArgs {
    nodeId: DOM.NodeId
    propertyName: string
    value: string
  }
  export interface SetPropertyRulePropertyNameArgs {
    styleSheetId: StyleSheetId
    range: SourceRange
    propertyName: string
  }
  export interface SetKeyframeKeyArgs {
    styleSheetId: StyleSheetId
    range: SourceRange
    keyText: string
  }
  export interface SetMediaTextArgs {
    styleSheetId: StyleSheetId
    range: SourceRange
    text: string
  }
  export interface SetContainerQueryTextArgs {
    styleSheetId: StyleSheetId
    range: SourceRange
    text: string
  }
  export interface SetSupportsTextArgs {
    styleSheetId: StyleSheetId
    range: SourceRange
    text: string
  }
  export interface SetScopeTextArgs {
    styleSheetId: StyleSheetId
    range: SourceRange
    text: string
  }
  export interface SetRuleSelectorArgs {
    styleSheetId: StyleSheetId
    range: SourceRange
    selector: string
  }
  export interface SetStyleSheetTextArgs {
    styleSheetId: StyleSheetId
    text: string
  }
  export interface SetStyleTextsArgs {
    edits: StyleDeclarationEdit[]
    nodeForPropertySyntaxValidation?: DOM.NodeId
  }
  export interface AddRuleResult {
    rule: CSSRule
  }
  export interface CollectClassNamesResult {
    classNames: string[]
  }
  export interface CreateStyleSheetResult {
    styleSheetId: StyleSheetId
  }
  export interface GetBackgroundColorsResult {
    backgroundColors: string[]
    computedFontSize: string
    computedFontWeight: string
  }
  export interface GetComputedStyleForNodeResult {
    computedStyle: CSSComputedStyleProperty[]
  }
  export interface ResolveValuesResult {
    results: string[]
  }
  export interface GetLonghandPropertiesResult {
    longhandProperties: CSSProperty[]
  }
  export interface GetInlineStylesForNodeResult {
    inlineStyle: CSSStyle
    attributesStyle: CSSStyle
  }
  export interface GetAnimatedStylesForNodeResult {
    animationStyles: CSSAnimationStyle[]
    transitionsStyle: CSSStyle
    inherited: InheritedAnimatedStyleEntry[]
  }
  export interface GetMatchedStylesForNodeResult {
    inlineStyle: CSSStyle
    attributesStyle: CSSStyle
    matchedCSSRules: RuleMatch[]
    pseudoElements: PseudoElementMatches[]
    inherited: InheritedStyleEntry[]
    inheritedPseudoElements: InheritedPseudoElementMatches[]
    cssKeyframesRules: CSSKeyframesRule[]
    cssPositionTryRules: CSSPositionTryRule[]
    activePositionFallbackIndex: number
    cssPropertyRules: CSSPropertyRule[]
    cssPropertyRegistrations: CSSPropertyRegistration[]
    cssFontPaletteValuesRule: CSSFontPaletteValuesRule
    parentLayoutNodeId: DOM.NodeId
    cssFunctionRules: CSSFunctionRule[]
  }
  export interface GetMediaQueriesResult {
    medias: CSSMedia[]
  }
  export interface GetPlatformFontsForNodeResult {
    fonts: PlatformFontUsage[]
  }
  export interface GetStyleSheetTextResult {
    text: string
  }
  export interface GetLayersForNodeResult {
    rootLayer: CSSLayerData
  }
  export interface GetLocationForSelectorResult {
    ranges: SourceRange[]
  }
  export interface TakeComputedStyleUpdatesResult {
    nodeIds: DOM.NodeId[]
  }
  export interface SetPropertyRulePropertyNameResult {
    propertyName: Value
  }
  export interface SetKeyframeKeyResult {
    keyText: Value
  }
  export interface SetMediaTextResult {
    media: CSSMedia
  }
  export interface SetContainerQueryTextResult {
    containerQuery: CSSContainerQuery
  }
  export interface SetSupportsTextResult {
    supports: CSSSupports
  }
  export interface SetScopeTextResult {
    scope: CSSScope
  }
  export interface SetRuleSelectorResult {
    selectorList: SelectorList
  }
  export interface SetStyleSheetTextResult {
    sourceMapURL: string
  }
  export interface SetStyleTextsResult {
    styles: CSSStyle[]
  }
  export interface StopRuleUsageTrackingResult {
    ruleUsage: RuleUsage[]
  }
  export interface TakeCoverageDeltaResult {
    coverage: RuleUsage[]
    timestamp: number
  }
  export interface FontsUpdatedEvent {
    font: FontFace
  }
  export interface MediaQueryResultChangedEvent {}
  export interface StyleSheetAddedEvent {
    header: CSSStyleSheetHeader
  }
  export interface StyleSheetChangedEvent {
    styleSheetId: StyleSheetId
  }
  export interface StyleSheetRemovedEvent {
    styleSheetId: StyleSheetId
  }
  export interface ComputedStyleUpdatedEvent {
    nodeId: DOM.NodeId
  }
  export interface EventMap {
    fontsUpdated: FontsUpdatedEvent
    mediaQueryResultChanged: MediaQueryResultChangedEvent
    styleSheetAdded: StyleSheetAddedEvent
    styleSheetChanged: StyleSheetChangedEvent
    styleSheetRemoved: StyleSheetRemovedEvent
    computedStyleUpdated: ComputedStyleUpdatedEvent
  }
}
export namespace CacheStorage {
  export type CacheId = string
  export type CachedResponseType =
    | 'basic'
    | 'cors'
    | 'default'
    | 'error'
    | 'opaqueResponse'
    | 'opaqueRedirect'
  export type DataEntry = {
    requestURL: string
    requestMethod: string
    requestHeaders: Header[]
    responseTime: number
    responseStatus: number
    responseStatusText: string
    responseType: CachedResponseType
    responseHeaders: Header[]
  }
  export type Cache = {
    cacheId: CacheId
    securityOrigin: string
    storageKey: string
    storageBucket?: Storage.StorageBucket
    cacheName: string
  }
  export type Header = { name: string; value: string }
  export type CachedResponse = { body: string }
  export interface DeleteEntryArgs {
    cacheId: CacheId
    request: string
  }
  export interface RequestCacheNamesArgs {
    securityOrigin?: string
    storageKey?: string
    storageBucket?: Storage.StorageBucket
  }
  export interface RequestCachedResponseArgs {
    cacheId: CacheId
    requestURL: string
    requestHeaders: Header[]
  }
  export interface RequestEntriesArgs {
    cacheId: CacheId
    skipCount?: number
    pageSize?: number
    pathFilter?: string
  }
  export interface RequestCacheNamesResult {
    caches: Cache[]
  }
  export interface RequestCachedResponseResult {
    response: CachedResponse
  }
  export interface RequestEntriesResult {
    cacheDataEntries: DataEntry[]
    returnCount: number
  }
}
export namespace Cast {
  export type Sink = { name: string; id: string; session?: string }
  export interface SinksUpdatedEvent {
    sinks: Sink[]
  }
  export interface IssueUpdatedEvent {
    issueMessage: string
  }
  export interface EventMap {
    sinksUpdated: SinksUpdatedEvent
    issueUpdated: IssueUpdatedEvent
  }
}
export namespace DOM {
  export type NodeId = number
  export type BackendNodeId = number
  export type BackendNode = {
    nodeType: number
    nodeName: string
    backendNodeId: BackendNodeId
  }
  export type PseudoType =
    | 'first-line'
    | 'first-letter'
    | 'checkmark'
    | 'before'
    | 'after'
    | 'picker-icon'
    | 'marker'
    | 'backdrop'
    | 'column'
    | 'selection'
    | 'search-text'
    | 'target-text'
    | 'spelling-error'
    | 'grammar-error'
    | 'highlight'
    | 'first-line-inherited'
    | 'scroll-marker'
    | 'scroll-marker-group'
    | 'scroll-button'
    | 'scrollbar'
    | 'scrollbar-thumb'
    | 'scrollbar-button'
    | 'scrollbar-track'
    | 'scrollbar-track-piece'
    | 'scrollbar-corner'
    | 'resizer'
    | 'input-list-button'
    | 'view-transition'
    | 'view-transition-group'
    | 'view-transition-image-pair'
    | 'view-transition-group-children'
    | 'view-transition-old'
    | 'view-transition-new'
    | 'placeholder'
    | 'file-selector-button'
    | 'details-content'
    | 'picker'
    | 'permission-icon'
  export type ShadowRootType = 'user-agent' | 'open' | 'closed'
  export type CompatibilityMode =
    | 'QuirksMode'
    | 'LimitedQuirksMode'
    | 'NoQuirksMode'
  export type PhysicalAxes = 'Horizontal' | 'Vertical' | 'Both'
  export type LogicalAxes = 'Inline' | 'Block' | 'Both'
  export type ScrollOrientation = 'horizontal' | 'vertical'
  export type Node = {
    nodeId: NodeId
    parentId?: NodeId
    backendNodeId: BackendNodeId
    nodeType: number
    nodeName: string
    localName: string
    nodeValue: string
    childNodeCount?: number
    children?: Node[]
    attributes?: string[]
    documentURL?: string
    baseURL?: string
    publicId?: string
    systemId?: string
    internalSubset?: string
    xmlVersion?: string
    name?: string
    value?: string
    pseudoType?: PseudoType
    pseudoIdentifier?: string
    shadowRootType?: ShadowRootType
    frameId?: Page.FrameId
    contentDocument?: Node
    shadowRoots?: Node[]
    templateContent?: Node
    pseudoElements?: Node[]
    importedDocument?: Node
    distributedNodes?: BackendNode[]
    isSVG?: boolean
    compatibilityMode?: CompatibilityMode
    assignedSlot?: BackendNode
    isScrollable?: boolean
  }
  export type DetachedElementInfo = {
    treeNode: Node
    retainedNodeIds: NodeId[]
  }
  export type RGBA = { r: number; g: number; b: number; a?: number }
  export type Quad = number[]
  export type BoxModel = {
    content: Quad
    padding: Quad
    border: Quad
    margin: Quad
    width: number
    height: number
    shapeOutside?: ShapeOutsideInfo
  }
  export type ShapeOutsideInfo = {
    bounds: Quad
    shape: unknown[]
    marginShape: unknown[]
  }
  export type Rect = { x: number; y: number; width: number; height: number }
  export type CSSComputedStyleProperty = { name: string; value: string }
  export interface CopyToArgs {
    nodeId: NodeId
    targetNodeId: NodeId
    insertBeforeNodeId?: NodeId
  }
  export interface DescribeNodeArgs {
    nodeId?: NodeId
    backendNodeId?: BackendNodeId
    objectId?: Runtime.RemoteObjectId
    depth?: number
    pierce?: boolean
  }
  export interface ScrollIntoViewIfNeededArgs {
    nodeId?: NodeId
    backendNodeId?: BackendNodeId
    objectId?: Runtime.RemoteObjectId
    rect?: Rect
  }
  export interface FocusArgs {
    nodeId?: NodeId
    backendNodeId?: BackendNodeId
    objectId?: Runtime.RemoteObjectId
  }
  export interface GetBoxModelArgs {
    nodeId?: NodeId
    backendNodeId?: BackendNodeId
    objectId?: Runtime.RemoteObjectId
  }
  export interface GetContentQuadsArgs {
    nodeId?: NodeId
    backendNodeId?: BackendNodeId
    objectId?: Runtime.RemoteObjectId
  }
  export interface GetDocumentArgs {
    depth?: number
    pierce?: boolean
  }
  export interface GetFlattenedDocumentArgs {
    depth?: number
    pierce?: boolean
  }
  export interface GetNodesForSubtreeByStyleArgs {
    nodeId: NodeId
    computedStyles: CSSComputedStyleProperty[]
    pierce?: boolean
  }
  export interface GetNodeForLocationArgs {
    x: number
    y: number
    includeUserAgentShadowDOM?: boolean
    ignorePointerEventsNone?: boolean
  }
  export interface GetOuterHTMLArgs {
    nodeId?: NodeId
    backendNodeId?: BackendNodeId
    objectId?: Runtime.RemoteObjectId
  }
  export interface GetSearchResultsArgs {
    searchId: string
    fromIndex: number
    toIndex: number
  }
  export interface MoveToArgs {
    nodeId: NodeId
    targetNodeId: NodeId
    insertBeforeNodeId?: NodeId
  }
  export interface PerformSearchArgs {
    query: string
    includeUserAgentShadowDOM?: boolean
  }
  export interface QuerySelectorArgs {
    nodeId: NodeId
    selector: string
  }
  export interface QuerySelectorAllArgs {
    nodeId: NodeId
    selector: string
  }
  export interface GetElementByRelationArgs {
    nodeId: NodeId
    relation: 'PopoverTarget' | 'InterestTarget' | 'CommandFor'
  }
  export interface RemoveAttributeArgs {
    nodeId: NodeId
    name: string
  }
  export interface RequestChildNodesArgs {
    nodeId: NodeId
    depth?: number
    pierce?: boolean
  }
  export interface ResolveNodeArgs {
    nodeId?: NodeId
    backendNodeId?: DOM.BackendNodeId
    objectGroup?: string
    executionContextId?: Runtime.ExecutionContextId
  }
  export interface SetAttributeValueArgs {
    nodeId: NodeId
    name: string
    value: string
  }
  export interface SetAttributesAsTextArgs {
    nodeId: NodeId
    text: string
    name?: string
  }
  export interface SetFileInputFilesArgs {
    files: string[]
    nodeId?: NodeId
    backendNodeId?: BackendNodeId
    objectId?: Runtime.RemoteObjectId
  }
  export interface SetNodeNameArgs {
    nodeId: NodeId
    name: string
  }
  export interface SetNodeValueArgs {
    nodeId: NodeId
    value: string
  }
  export interface SetOuterHTMLArgs {
    nodeId: NodeId
    outerHTML: string
  }
  export interface GetContainerForNodeArgs {
    nodeId: NodeId
    containerName?: string
    physicalAxes?: PhysicalAxes
    logicalAxes?: LogicalAxes
    queriesScrollState?: boolean
  }
  export interface GetAnchorElementArgs {
    nodeId: NodeId
    anchorSpecifier?: string
  }
  export interface CollectClassNamesFromSubtreeResult {
    classNames: string[]
  }
  export interface CopyToResult {
    nodeId: NodeId
  }
  export interface DescribeNodeResult {
    node: Node
  }
  export interface GetAttributesResult {
    attributes: string[]
  }
  export interface GetBoxModelResult {
    model: BoxModel
  }
  export interface GetContentQuadsResult {
    quads: Quad[]
  }
  export interface GetDocumentResult {
    root: Node
  }
  export interface GetFlattenedDocumentResult {
    nodes: Node[]
  }
  export interface GetNodesForSubtreeByStyleResult {
    nodeIds: NodeId[]
  }
  export interface GetNodeForLocationResult {
    backendNodeId: BackendNodeId
    frameId: Page.FrameId
    nodeId: NodeId
  }
  export interface GetOuterHTMLResult {
    outerHTML: string
  }
  export interface GetRelayoutBoundaryResult {
    nodeId: NodeId
  }
  export interface GetSearchResultsResult {
    nodeIds: NodeId[]
  }
  export interface MoveToResult {
    nodeId: NodeId
  }
  export interface PerformSearchResult {
    searchId: string
    resultCount: number
  }
  export interface PushNodeByPathToFrontendResult {
    nodeId: NodeId
  }
  export interface PushNodesByBackendIdsToFrontendResult {
    nodeIds: NodeId[]
  }
  export interface QuerySelectorResult {
    nodeId: NodeId
  }
  export interface QuerySelectorAllResult {
    nodeIds: NodeId[]
  }
  export interface GetTopLayerElementsResult {
    nodeIds: NodeId[]
  }
  export interface GetElementByRelationResult {
    nodeId: NodeId
  }
  export interface RequestNodeResult {
    nodeId: NodeId
  }
  export interface ResolveNodeResult {
    object: Runtime.RemoteObject
  }
  export interface GetNodeStackTracesResult {
    creation: Runtime.StackTrace
  }
  export interface GetFileInfoResult {
    path: string
  }
  export interface GetDetachedDomNodesResult {
    detachedNodes: DetachedElementInfo[]
  }
  export interface SetNodeNameResult {
    nodeId: NodeId
  }
  export interface GetFrameOwnerResult {
    backendNodeId: BackendNodeId
    nodeId: NodeId
  }
  export interface GetContainerForNodeResult {
    nodeId: NodeId
  }
  export interface GetQueryingDescendantsForContainerResult {
    nodeIds: NodeId[]
  }
  export interface GetAnchorElementResult {
    nodeId: NodeId
  }
  export interface AttributeModifiedEvent {
    nodeId: NodeId
    name: string
    value: string
  }
  export interface AttributeRemovedEvent {
    nodeId: NodeId
    name: string
  }
  export interface CharacterDataModifiedEvent {
    nodeId: NodeId
    characterData: string
  }
  export interface ChildNodeCountUpdatedEvent {
    nodeId: NodeId
    childNodeCount: number
  }
  export interface ChildNodeInsertedEvent {
    parentNodeId: NodeId
    previousNodeId: NodeId
    node: Node
  }
  export interface ChildNodeRemovedEvent {
    parentNodeId: NodeId
    nodeId: NodeId
  }
  export interface DistributedNodesUpdatedEvent {
    insertionPointId: NodeId
    distributedNodes: BackendNode[]
  }
  export interface DocumentUpdatedEvent {}
  export interface InlineStyleInvalidatedEvent {
    nodeIds: NodeId[]
  }
  export interface PseudoElementAddedEvent {
    parentId: NodeId
    pseudoElement: Node
  }
  export interface TopLayerElementsUpdatedEvent {}
  export interface ScrollableFlagUpdatedEvent {
    nodeId: DOM.NodeId
    isScrollable: boolean
  }
  export interface PseudoElementRemovedEvent {
    parentId: NodeId
    pseudoElementId: NodeId
  }
  export interface SetChildNodesEvent {
    parentId: NodeId
    nodes: Node[]
  }
  export interface ShadowRootPoppedEvent {
    hostId: NodeId
    rootId: NodeId
  }
  export interface ShadowRootPushedEvent {
    hostId: NodeId
    root: Node
  }
  export interface EventMap {
    attributeModified: AttributeModifiedEvent
    attributeRemoved: AttributeRemovedEvent
    characterDataModified: CharacterDataModifiedEvent
    childNodeCountUpdated: ChildNodeCountUpdatedEvent
    childNodeInserted: ChildNodeInsertedEvent
    childNodeRemoved: ChildNodeRemovedEvent
    distributedNodesUpdated: DistributedNodesUpdatedEvent
    documentUpdated: DocumentUpdatedEvent
    inlineStyleInvalidated: InlineStyleInvalidatedEvent
    pseudoElementAdded: PseudoElementAddedEvent
    topLayerElementsUpdated: TopLayerElementsUpdatedEvent
    scrollableFlagUpdated: ScrollableFlagUpdatedEvent
    pseudoElementRemoved: PseudoElementRemovedEvent
    setChildNodes: SetChildNodesEvent
    shadowRootPopped: ShadowRootPoppedEvent
    shadowRootPushed: ShadowRootPushedEvent
  }
}
export namespace DOMDebugger {
  export type DOMBreakpointType =
    | 'subtree-modified'
    | 'attribute-modified'
    | 'node-removed'
  export type CSPViolationType =
    | 'trustedtype-sink-violation'
    | 'trustedtype-policy-violation'
  export type EventListener = {
    type: string
    useCapture: boolean
    passive: boolean
    once: boolean
    scriptId: Runtime.ScriptId
    lineNumber: number
    columnNumber: number
    handler?: Runtime.RemoteObject
    originalHandler?: Runtime.RemoteObject
    backendNodeId?: DOM.BackendNodeId
  }
  export interface GetEventListenersArgs {
    objectId: Runtime.RemoteObjectId
    depth?: number
    pierce?: boolean
  }
  export interface RemoveDOMBreakpointArgs {
    nodeId: DOM.NodeId
    type: DOMBreakpointType
  }
  export interface RemoveEventListenerBreakpointArgs {
    eventName: string
    targetName?: string
  }
  export interface SetDOMBreakpointArgs {
    nodeId: DOM.NodeId
    type: DOMBreakpointType
  }
  export interface SetEventListenerBreakpointArgs {
    eventName: string
    targetName?: string
  }
  export interface GetEventListenersResult {
    listeners: EventListener[]
  }
}
export namespace EventBreakpoints {}
export namespace DOMSnapshot {
  export type DOMNode = {
    nodeType: number
    nodeName: string
    nodeValue: string
    textValue?: string
    inputValue?: string
    inputChecked?: boolean
    optionSelected?: boolean
    backendNodeId: DOM.BackendNodeId
    childNodeIndexes?: number[]
    attributes?: NameValue[]
    pseudoElementIndexes?: number[]
    layoutNodeIndex?: number
    documentURL?: string
    baseURL?: string
    contentLanguage?: string
    documentEncoding?: string
    publicId?: string
    systemId?: string
    frameId?: Page.FrameId
    contentDocumentIndex?: number
    pseudoType?: DOM.PseudoType
    shadowRootType?: DOM.ShadowRootType
    isClickable?: boolean
    eventListeners?: DOMDebugger.EventListener[]
    currentSourceURL?: string
    originURL?: string
    scrollOffsetX?: number
    scrollOffsetY?: number
  }
  export type InlineTextBox = {
    boundingBox: DOM.Rect
    startCharacterIndex: number
    numCharacters: number
  }
  export type LayoutTreeNode = {
    domNodeIndex: number
    boundingBox: DOM.Rect
    layoutText?: string
    inlineTextNodes?: InlineTextBox[]
    styleIndex?: number
    paintOrder?: number
    isStackingContext?: boolean
  }
  export type ComputedStyle = { properties: NameValue[] }
  export type NameValue = { name: string; value: string }
  export type StringIndex = number
  export type ArrayOfStrings = StringIndex[]
  export type RareStringData = { index: number[]; value: StringIndex[] }
  export type RareBooleanData = { index: number[] }
  export type RareIntegerData = { index: number[]; value: number[] }
  export type Rectangle = number[]
  export type DocumentSnapshot = {
    documentURL: StringIndex
    title: StringIndex
    baseURL: StringIndex
    contentLanguage: StringIndex
    encodingName: StringIndex
    publicId: StringIndex
    systemId: StringIndex
    frameId: StringIndex
    nodes: NodeTreeSnapshot
    layout: LayoutTreeSnapshot
    textBoxes: TextBoxSnapshot
    scrollOffsetX?: number
    scrollOffsetY?: number
    contentWidth?: number
    contentHeight?: number
  }
  export type NodeTreeSnapshot = {
    parentIndex?: number[]
    nodeType?: number[]
    shadowRootType?: RareStringData
    nodeName?: StringIndex[]
    nodeValue?: StringIndex[]
    backendNodeId?: DOM.BackendNodeId[]
    attributes?: ArrayOfStrings[]
    textValue?: RareStringData
    inputValue?: RareStringData
    inputChecked?: RareBooleanData
    optionSelected?: RareBooleanData
    contentDocumentIndex?: RareIntegerData
    pseudoType?: RareStringData
    pseudoIdentifier?: RareStringData
    isClickable?: RareBooleanData
    currentSourceURL?: RareStringData
    originURL?: RareStringData
  }
  export type LayoutTreeSnapshot = {
    nodeIndex: number[]
    styles: ArrayOfStrings[]
    bounds: Rectangle[]
    text: StringIndex[]
    stackingContexts: RareBooleanData
    paintOrders?: number[]
    offsetRects?: Rectangle[]
    scrollRects?: Rectangle[]
    clientRects?: Rectangle[]
    blendedBackgroundColors?: StringIndex[]
    textColorOpacities?: number[]
  }
  export type TextBoxSnapshot = {
    layoutIndex: number[]
    bounds: Rectangle[]
    start: number[]
    length: number[]
  }
  export interface GetSnapshotArgs {
    computedStyleWhitelist: string[]
    includeEventListeners?: boolean
    includePaintOrder?: boolean
    includeUserAgentShadowTree?: boolean
  }
  export interface CaptureSnapshotArgs {
    computedStyles: string[]
    includePaintOrder?: boolean
    includeDOMRects?: boolean
    includeBlendedBackgroundColors?: boolean
    includeTextColorOpacities?: boolean
  }
  export interface GetSnapshotResult {
    domNodes: DOMNode[]
    layoutTreeNodes: LayoutTreeNode[]
    computedStyles: ComputedStyle[]
  }
  export interface CaptureSnapshotResult {
    documents: DocumentSnapshot[]
    strings: string[]
  }
}
export namespace DOMStorage {
  export type SerializedStorageKey = string
  export type StorageId = {
    securityOrigin?: string
    storageKey?: SerializedStorageKey
    isLocalStorage: boolean
  }
  export type Item = string[]
  export interface RemoveDOMStorageItemArgs {
    storageId: StorageId
    key: string
  }
  export interface SetDOMStorageItemArgs {
    storageId: StorageId
    key: string
    value: string
  }
  export interface GetDOMStorageItemsResult {
    entries: Item[]
  }
  export interface DomStorageItemAddedEvent {
    storageId: StorageId
    key: string
    newValue: string
  }
  export interface DomStorageItemRemovedEvent {
    storageId: StorageId
    key: string
  }
  export interface DomStorageItemUpdatedEvent {
    storageId: StorageId
    key: string
    oldValue: string
    newValue: string
  }
  export interface DomStorageItemsClearedEvent {
    storageId: StorageId
  }
  export interface EventMap {
    domStorageItemAdded: DomStorageItemAddedEvent
    domStorageItemRemoved: DomStorageItemRemovedEvent
    domStorageItemUpdated: DomStorageItemUpdatedEvent
    domStorageItemsCleared: DomStorageItemsClearedEvent
  }
}
export namespace DeviceOrientation {
  export interface SetDeviceOrientationOverrideArgs {
    alpha: number
    beta: number
    gamma: number
  }
}
export namespace Emulation {
  export type SafeAreaInsets = {
    top?: number
    topMax?: number
    left?: number
    leftMax?: number
    bottom?: number
    bottomMax?: number
    right?: number
    rightMax?: number
  }
  export type ScreenOrientation = {
    type:
      | 'portraitPrimary'
      | 'portraitSecondary'
      | 'landscapePrimary'
      | 'landscapeSecondary'
    angle: number
  }
  export type DisplayFeature = {
    orientation: 'vertical' | 'horizontal'
    offset: number
    maskLength: number
  }
  export type DevicePosture = { type: 'continuous' | 'folded' }
  export type MediaFeature = { name: string; value: string }
  export type VirtualTimePolicy =
    | 'advance'
    | 'pause'
    | 'pauseIfNetworkFetchesPending'
  export type UserAgentBrandVersion = { brand: string; version: string }
  export type UserAgentMetadata = {
    brands?: UserAgentBrandVersion[]
    fullVersionList?: UserAgentBrandVersion[]
    fullVersion?: string
    platform: string
    platformVersion: string
    architecture: string
    model: string
    mobile: boolean
    bitness?: string
    wow64?: boolean
  }
  export type SensorType =
    | 'absolute-orientation'
    | 'accelerometer'
    | 'ambient-light'
    | 'gravity'
    | 'gyroscope'
    | 'linear-acceleration'
    | 'magnetometer'
    | 'relative-orientation'
  export type SensorMetadata = {
    available?: boolean
    minimumFrequency?: number
    maximumFrequency?: number
  }
  export type SensorReadingSingle = { value: number }
  export type SensorReadingXYZ = { x: number; y: number; z: number }
  export type SensorReadingQuaternion = {
    x: number
    y: number
    z: number
    w: number
  }
  export type SensorReading = {
    single?: SensorReadingSingle
    xyz?: SensorReadingXYZ
    quaternion?: SensorReadingQuaternion
  }
  export type PressureSource = 'cpu'
  export type PressureState = 'nominal' | 'fair' | 'serious' | 'critical'
  export type PressureMetadata = { available?: boolean }
  export type DisabledImageType = 'avif' | 'webp'
  export interface SetDeviceMetricsOverrideArgs {
    width: number
    height: number
    deviceScaleFactor: number
    mobile: boolean
    scale?: number
    screenWidth?: number
    screenHeight?: number
    positionX?: number
    positionY?: number
    dontSetVisibleSize?: boolean
    screenOrientation?: ScreenOrientation
    viewport?: Page.Viewport
    displayFeature?: DisplayFeature
    devicePosture?: DevicePosture
  }
  export interface SetEmitTouchEventsForMouseArgs {
    enabled: boolean
    configuration?: 'mobile' | 'desktop'
  }
  export interface SetEmulatedMediaArgs {
    media?: string
    features?: MediaFeature[]
  }
  export interface SetGeolocationOverrideArgs {
    latitude?: number
    longitude?: number
    accuracy?: number
    altitude?: number
    altitudeAccuracy?: number
    heading?: number
    speed?: number
  }
  export interface SetSensorOverrideEnabledArgs {
    enabled: boolean
    type: SensorType
    metadata?: SensorMetadata
  }
  export interface SetSensorOverrideReadingsArgs {
    type: SensorType
    reading: SensorReading
  }
  export interface SetPressureSourceOverrideEnabledArgs {
    enabled: boolean
    source: PressureSource
    metadata?: PressureMetadata
  }
  export interface SetPressureStateOverrideArgs {
    source: PressureSource
    state: PressureState
  }
  export interface SetPressureDataOverrideArgs {
    source: PressureSource
    state: PressureState
    ownContributionEstimate?: number
  }
  export interface SetIdleOverrideArgs {
    isUserActive: boolean
    isScreenUnlocked: boolean
  }
  export interface SetTouchEmulationEnabledArgs {
    enabled: boolean
    maxTouchPoints?: number
  }
  export interface SetVirtualTimePolicyArgs {
    policy: VirtualTimePolicy
    budget?: number
    maxVirtualTimeTaskStarvationCount?: number
    initialVirtualTime?: Network.TimeSinceEpoch
  }
  export interface SetVisibleSizeArgs {
    width: number
    height: number
  }
  export interface SetUserAgentOverrideArgs {
    userAgent: string
    acceptLanguage?: string
    platform?: string
    userAgentMetadata?: UserAgentMetadata
  }
  export interface CanEmulateResult {
    result: boolean
  }
  export interface GetOverriddenSensorInformationResult {
    requestedSamplingFrequency: number
  }
  export interface SetVirtualTimePolicyResult {
    virtualTimeTicksBase: number
  }
  export interface VirtualTimeBudgetExpiredEvent {}
  export interface EventMap {
    virtualTimeBudgetExpired: VirtualTimeBudgetExpiredEvent
  }
}
export namespace HeadlessExperimental {
  export type ScreenshotParams = {
    format?: 'jpeg' | 'png' | 'webp'
    quality?: number
    optimizeForSpeed?: boolean
  }
  export interface BeginFrameArgs {
    frameTimeTicks?: number
    interval?: number
    noDisplayUpdates?: boolean
    screenshot?: ScreenshotParams
  }
  export interface BeginFrameResult {
    hasDamage: boolean
    screenshotData: string
  }
}
export namespace IO {
  export type StreamHandle = string
  export interface ReadArgs {
    handle: StreamHandle
    offset?: number
    size?: number
  }
  export interface ReadResult {
    base64Encoded: boolean
    data: string
    eof: boolean
  }
  export interface ResolveBlobResult {
    uuid: string
  }
}
export namespace FileSystem {
  export type File = {
    name: string
    lastModified: Network.TimeSinceEpoch
    size: number
    type: string
  }
  export type Directory = {
    name: string
    nestedDirectories: string[]
    nestedFiles: File[]
  }
  export type BucketFileSystemLocator = {
    storageKey: Storage.SerializedStorageKey
    bucketName?: string
    pathComponents: string[]
  }
  export interface GetDirectoryResult {
    directory: Directory
  }
}
export namespace IndexedDB {
  export type DatabaseWithObjectStores = {
    name: string
    version: number
    objectStores: ObjectStore[]
  }
  export type ObjectStore = {
    name: string
    keyPath: KeyPath
    autoIncrement: boolean
    indexes: ObjectStoreIndex[]
  }
  export type ObjectStoreIndex = {
    name: string
    keyPath: KeyPath
    unique: boolean
    multiEntry: boolean
  }
  export type Key = {
    type: 'number' | 'string' | 'date' | 'array'
    number?: number
    string?: string
    date?: number
    array?: Key[]
  }
  export type KeyRange = {
    lower?: Key
    upper?: Key
    lowerOpen: boolean
    upperOpen: boolean
  }
  export type DataEntry = {
    key: Runtime.RemoteObject
    primaryKey: Runtime.RemoteObject
    value: Runtime.RemoteObject
  }
  export type KeyPath = {
    type: 'null' | 'string' | 'array'
    string?: string
    array?: string[]
  }
  export interface ClearObjectStoreArgs {
    securityOrigin?: string
    storageKey?: string
    storageBucket?: Storage.StorageBucket
    databaseName: string
    objectStoreName: string
  }
  export interface DeleteDatabaseArgs {
    securityOrigin?: string
    storageKey?: string
    storageBucket?: Storage.StorageBucket
    databaseName: string
  }
  export interface DeleteObjectStoreEntriesArgs {
    securityOrigin?: string
    storageKey?: string
    storageBucket?: Storage.StorageBucket
    databaseName: string
    objectStoreName: string
    keyRange: KeyRange
  }
  export interface RequestDataArgs {
    securityOrigin?: string
    storageKey?: string
    storageBucket?: Storage.StorageBucket
    databaseName: string
    objectStoreName: string
    indexName: string
    skipCount: number
    pageSize: number
    keyRange?: KeyRange
  }
  export interface GetMetadataArgs {
    securityOrigin?: string
    storageKey?: string
    storageBucket?: Storage.StorageBucket
    databaseName: string
    objectStoreName: string
  }
  export interface RequestDatabaseArgs {
    securityOrigin?: string
    storageKey?: string
    storageBucket?: Storage.StorageBucket
    databaseName: string
  }
  export interface RequestDatabaseNamesArgs {
    securityOrigin?: string
    storageKey?: string
    storageBucket?: Storage.StorageBucket
  }
  export interface RequestDataResult {
    objectStoreDataEntries: DataEntry[]
    hasMore: boolean
  }
  export interface GetMetadataResult {
    entriesCount: number
    keyGeneratorValue: number
  }
  export interface RequestDatabaseResult {
    databaseWithObjectStores: DatabaseWithObjectStores
  }
  export interface RequestDatabaseNamesResult {
    databaseNames: string[]
  }
}
export namespace Input {
  export type TouchPoint = {
    x: number
    y: number
    radiusX?: number
    radiusY?: number
    rotationAngle?: number
    force?: number
    tangentialPressure?: number
    tiltX?: number
    tiltY?: number
    twist?: number
    id?: number
  }
  export type GestureSourceType = 'default' | 'touch' | 'mouse'
  export type MouseButton =
    | 'none'
    | 'left'
    | 'middle'
    | 'right'
    | 'back'
    | 'forward'
  export type TimeSinceEpoch = number
  export type DragDataItem = {
    mimeType: string
    data: string
    title?: string
    baseURL?: string
  }
  export type DragData = {
    items: DragDataItem[]
    files?: string[]
    dragOperationsMask: number
  }
  export interface DispatchDragEventArgs {
    type: 'dragEnter' | 'dragOver' | 'drop' | 'dragCancel'
    x: number
    y: number
    data: DragData
    modifiers?: number
  }
  export interface DispatchKeyEventArgs {
    type: 'keyDown' | 'keyUp' | 'rawKeyDown' | 'char'
    modifiers?: number
    timestamp?: TimeSinceEpoch
    text?: string
    unmodifiedText?: string
    keyIdentifier?: string
    code?: string
    key?: string
    windowsVirtualKeyCode?: number
    nativeVirtualKeyCode?: number
    autoRepeat?: boolean
    isKeypad?: boolean
    isSystemKey?: boolean
    location?: number
    commands?: string[]
  }
  export interface ImeSetCompositionArgs {
    text: string
    selectionStart: number
    selectionEnd: number
    replacementStart?: number
    replacementEnd?: number
  }
  export interface DispatchMouseEventArgs {
    type: 'mousePressed' | 'mouseReleased' | 'mouseMoved' | 'mouseWheel'
    x: number
    y: number
    modifiers?: number
    timestamp?: TimeSinceEpoch
    button?: MouseButton
    buttons?: number
    clickCount?: number
    force?: number
    tangentialPressure?: number
    tiltX?: number
    tiltY?: number
    twist?: number
    deltaX?: number
    deltaY?: number
    pointerType?: 'mouse' | 'pen'
  }
  export interface DispatchTouchEventArgs {
    type: 'touchStart' | 'touchEnd' | 'touchMove' | 'touchCancel'
    touchPoints: TouchPoint[]
    modifiers?: number
    timestamp?: TimeSinceEpoch
  }
  export interface EmulateTouchFromMouseEventArgs {
    type: 'mousePressed' | 'mouseReleased' | 'mouseMoved' | 'mouseWheel'
    x: number
    y: number
    button: MouseButton
    timestamp?: TimeSinceEpoch
    deltaX?: number
    deltaY?: number
    modifiers?: number
    clickCount?: number
  }
  export interface SynthesizePinchGestureArgs {
    x: number
    y: number
    scaleFactor: number
    relativeSpeed?: number
    gestureSourceType?: GestureSourceType
  }
  export interface SynthesizeScrollGestureArgs {
    x: number
    y: number
    xDistance?: number
    yDistance?: number
    xOverscroll?: number
    yOverscroll?: number
    preventFling?: boolean
    speed?: number
    gestureSourceType?: GestureSourceType
    repeatCount?: number
    repeatDelayMs?: number
    interactionMarkerName?: string
  }
  export interface SynthesizeTapGestureArgs {
    x: number
    y: number
    duration?: number
    tapCount?: number
    gestureSourceType?: GestureSourceType
  }
  export interface DragInterceptedEvent {
    data: DragData
  }
  export interface EventMap {
    dragIntercepted: DragInterceptedEvent
  }
}
export namespace Inspector {
  export interface DetachedEvent {
    reason: string
  }
  export interface TargetCrashedEvent {}
  export interface TargetReloadedAfterCrashEvent {}
  export interface EventMap {
    detached: DetachedEvent
    targetCrashed: TargetCrashedEvent
    targetReloadedAfterCrash: TargetReloadedAfterCrashEvent
  }
}
export namespace LayerTree {
  export type LayerId = string
  export type SnapshotId = string
  export type ScrollRect = {
    rect: DOM.Rect
    type: 'RepaintsOnScroll' | 'TouchEventHandler' | 'WheelEventHandler'
  }
  export type StickyPositionConstraint = {
    stickyBoxRect: DOM.Rect
    containingBlockRect: DOM.Rect
    nearestLayerShiftingStickyBox?: LayerId
    nearestLayerShiftingContainingBlock?: LayerId
  }
  export type PictureTile = { x: number; y: number; picture: string }
  export type Layer = {
    layerId: LayerId
    parentLayerId?: LayerId
    backendNodeId?: DOM.BackendNodeId
    offsetX: number
    offsetY: number
    width: number
    height: number
    transform?: number[]
    anchorX?: number
    anchorY?: number
    anchorZ?: number
    paintCount: number
    drawsContent: boolean
    invisible?: boolean
    scrollRects?: ScrollRect[]
    stickyPositionConstraint?: StickyPositionConstraint
  }
  export type PaintProfile = number[]
  export interface ProfileSnapshotArgs {
    snapshotId: SnapshotId
    minRepeatCount?: number
    minDuration?: number
    clipRect?: DOM.Rect
  }
  export interface ReplaySnapshotArgs {
    snapshotId: SnapshotId
    fromStep?: number
    toStep?: number
    scale?: number
  }
  export interface CompositingReasonsResult {
    compositingReasons: string[]
    compositingReasonIds: string[]
  }
  export interface LoadSnapshotResult {
    snapshotId: SnapshotId
  }
  export interface MakeSnapshotResult {
    snapshotId: SnapshotId
  }
  export interface ProfileSnapshotResult {
    timings: PaintProfile[]
  }
  export interface ReplaySnapshotResult {
    dataURL: string
  }
  export interface SnapshotCommandLogResult {
    commandLog: Record<string, unknown>[]
  }
  export interface LayerPaintedEvent {
    layerId: LayerId
    clip: DOM.Rect
  }
  export interface LayerTreeDidChangeEvent {
    layers: Layer[]
  }
  export interface EventMap {
    layerPainted: LayerPaintedEvent
    layerTreeDidChange: LayerTreeDidChangeEvent
  }
}
export namespace Log {
  export type LogEntry = {
    source:
      | 'xml'
      | 'javascript'
      | 'network'
      | 'storage'
      | 'appcache'
      | 'rendering'
      | 'security'
      | 'deprecation'
      | 'worker'
      | 'violation'
      | 'intervention'
      | 'recommendation'
      | 'other'
    level: 'verbose' | 'info' | 'warning' | 'error'
    text: string
    category?: 'cors'
    timestamp: Runtime.Timestamp
    url?: string
    lineNumber?: number
    stackTrace?: Runtime.StackTrace
    networkRequestId?: Network.RequestId
    workerId?: string
    args?: Runtime.RemoteObject[]
  }
  export type ViolationSetting = {
    name:
      | 'longTask'
      | 'longLayout'
      | 'blockedEvent'
      | 'blockedParser'
      | 'discouragedAPIUse'
      | 'handler'
      | 'recurringHandler'
    threshold: number
  }
  export interface EntryAddedEvent {
    entry: LogEntry
  }
  export interface EventMap {
    entryAdded: EntryAddedEvent
  }
}
export namespace Memory {
  export type PressureLevel = 'moderate' | 'critical'
  export type SamplingProfileNode = {
    size: number
    total: number
    stack: string[]
  }
  export type SamplingProfile = {
    samples: SamplingProfileNode[]
    modules: Module[]
  }
  export type Module = {
    name: string
    uuid: string
    baseAddress: string
    size: number
  }
  export type DOMCounter = { name: string; count: number }
  export interface StartSamplingArgs {
    samplingInterval?: number
    suppressRandomness?: boolean
  }
  export interface GetDOMCountersResult {
    documents: number
    nodes: number
    jsEventListeners: number
  }
  export interface GetDOMCountersForLeakDetectionResult {
    counters: DOMCounter[]
  }
  export interface GetAllTimeSamplingProfileResult {
    profile: SamplingProfile
  }
  export interface GetBrowserSamplingProfileResult {
    profile: SamplingProfile
  }
  export interface GetSamplingProfileResult {
    profile: SamplingProfile
  }
}
export namespace Network {
  export type ResourceType =
    | 'Document'
    | 'Stylesheet'
    | 'Image'
    | 'Media'
    | 'Font'
    | 'Script'
    | 'TextTrack'
    | 'XHR'
    | 'Fetch'
    | 'Prefetch'
    | 'EventSource'
    | 'WebSocket'
    | 'Manifest'
    | 'SignedExchange'
    | 'Ping'
    | 'CSPViolationReport'
    | 'Preflight'
    | 'FedCM'
    | 'Other'
  export type LoaderId = string
  export type RequestId = string
  export type InterceptionId = string
  export type ErrorReason =
    | 'Failed'
    | 'Aborted'
    | 'TimedOut'
    | 'AccessDenied'
    | 'ConnectionClosed'
    | 'ConnectionReset'
    | 'ConnectionRefused'
    | 'ConnectionAborted'
    | 'ConnectionFailed'
    | 'NameNotResolved'
    | 'InternetDisconnected'
    | 'AddressUnreachable'
    | 'BlockedByClient'
    | 'BlockedByResponse'
  export type TimeSinceEpoch = number
  export type MonotonicTime = number
  export type Headers = Record<string, string>
  export type ConnectionType =
    | 'none'
    | 'cellular2g'
    | 'cellular3g'
    | 'cellular4g'
    | 'bluetooth'
    | 'ethernet'
    | 'wifi'
    | 'wimax'
    | 'other'
  export type CookieSameSite = 'Strict' | 'Lax' | 'None'
  export type CookiePriority = 'Low' | 'Medium' | 'High'
  export type CookieSourceScheme = 'Unset' | 'NonSecure' | 'Secure'
  export type ResourceTiming = {
    requestTime: number
    proxyStart: number
    proxyEnd: number
    dnsStart: number
    dnsEnd: number
    connectStart: number
    connectEnd: number
    sslStart: number
    sslEnd: number
    workerStart: number
    workerReady: number
    workerFetchStart: number
    workerRespondWithSettled: number
    workerRouterEvaluationStart?: number
    workerCacheLookupStart?: number
    sendStart: number
    sendEnd: number
    pushStart: number
    pushEnd: number
    receiveHeadersStart: number
    receiveHeadersEnd: number
  }
  export type ResourcePriority =
    | 'VeryLow'
    | 'Low'
    | 'Medium'
    | 'High'
    | 'VeryHigh'
  export type PostDataEntry = { bytes?: string }
  export type Request = {
    url: string
    urlFragment?: string
    method: string
    headers: Headers
    postData?: string
    hasPostData?: boolean
    postDataEntries?: PostDataEntry[]
    mixedContentType?: Security.MixedContentType
    initialPriority: ResourcePriority
    referrerPolicy:
      | 'unsafe-url'
      | 'no-referrer-when-downgrade'
      | 'no-referrer'
      | 'origin'
      | 'origin-when-cross-origin'
      | 'same-origin'
      | 'strict-origin'
      | 'strict-origin-when-cross-origin'
    isLinkPreload?: boolean
    trustTokenParams?: TrustTokenParams
    isSameSite?: boolean
  }
  export type SignedCertificateTimestamp = {
    status: string
    origin: string
    logDescription: string
    logId: string
    timestamp: number
    hashAlgorithm: string
    signatureAlgorithm: string
    signatureData: string
  }
  export type SecurityDetails = {
    protocol: string
    keyExchange: string
    keyExchangeGroup?: string
    cipher: string
    mac?: string
    certificateId: Security.CertificateId
    subjectName: string
    sanList: string[]
    issuer: string
    validFrom: TimeSinceEpoch
    validTo: TimeSinceEpoch
    signedCertificateTimestampList: SignedCertificateTimestamp[]
    certificateTransparencyCompliance: CertificateTransparencyCompliance
    serverSignatureAlgorithm?: number
    encryptedClientHello: boolean
  }
  export type CertificateTransparencyCompliance =
    | 'unknown'
    | 'not-compliant'
    | 'compliant'
  export type BlockedReason =
    | 'other'
    | 'csp'
    | 'mixed-content'
    | 'origin'
    | 'inspector'
    | 'integrity'
    | 'subresource-filter'
    | 'content-type'
    | 'coep-frame-resource-needs-coep-header'
    | 'coop-sandboxed-iframe-cannot-navigate-to-coop-page'
    | 'corp-not-same-origin'
    | 'corp-not-same-origin-after-defaulted-to-same-origin-by-coep'
    | 'corp-not-same-origin-after-defaulted-to-same-origin-by-dip'
    | 'corp-not-same-origin-after-defaulted-to-same-origin-by-coep-and-dip'
    | 'corp-not-same-site'
    | 'sri-message-signature-mismatch'
  export type CorsError =
    | 'DisallowedByMode'
    | 'InvalidResponse'
    | 'WildcardOriginNotAllowed'
    | 'MissingAllowOriginHeader'
    | 'MultipleAllowOriginValues'
    | 'InvalidAllowOriginValue'
    | 'AllowOriginMismatch'
    | 'InvalidAllowCredentials'
    | 'CorsDisabledScheme'
    | 'PreflightInvalidStatus'
    | 'PreflightDisallowedRedirect'
    | 'PreflightWildcardOriginNotAllowed'
    | 'PreflightMissingAllowOriginHeader'
    | 'PreflightMultipleAllowOriginValues'
    | 'PreflightInvalidAllowOriginValue'
    | 'PreflightAllowOriginMismatch'
    | 'PreflightInvalidAllowCredentials'
    | 'PreflightMissingAllowExternal'
    | 'PreflightInvalidAllowExternal'
    | 'PreflightMissingAllowPrivateNetwork'
    | 'PreflightInvalidAllowPrivateNetwork'
    | 'InvalidAllowMethodsPreflightResponse'
    | 'InvalidAllowHeadersPreflightResponse'
    | 'MethodDisallowedByPreflightResponse'
    | 'HeaderDisallowedByPreflightResponse'
    | 'RedirectContainsCredentials'
    | 'InsecurePrivateNetwork'
    | 'InvalidPrivateNetworkAccess'
    | 'UnexpectedPrivateNetworkAccess'
    | 'NoCorsRedirectModeNotFollow'
    | 'PreflightMissingPrivateNetworkAccessId'
    | 'PreflightMissingPrivateNetworkAccessName'
    | 'PrivateNetworkAccessPermissionUnavailable'
    | 'PrivateNetworkAccessPermissionDenied'
    | 'LocalNetworkAccessPermissionDenied'
  export type CorsErrorStatus = {
    corsError: CorsError
    failedParameter: string
  }
  export type ServiceWorkerResponseSource =
    | 'cache-storage'
    | 'http-cache'
    | 'fallback-code'
    | 'network'
  export type TrustTokenParams = {
    operation: TrustTokenOperationType
    refreshPolicy: 'UseCached' | 'Refresh'
    issuers?: string[]
  }
  export type TrustTokenOperationType = 'Issuance' | 'Redemption' | 'Signing'
  export type AlternateProtocolUsage =
    | 'alternativeJobWonWithoutRace'
    | 'alternativeJobWonRace'
    | 'mainJobWonRace'
    | 'mappingMissing'
    | 'broken'
    | 'dnsAlpnH3JobWonWithoutRace'
    | 'dnsAlpnH3JobWonRace'
    | 'unspecifiedReason'
  export type ServiceWorkerRouterSource =
    | 'network'
    | 'cache'
    | 'fetch-event'
    | 'race-network-and-fetch-handler'
    | 'race-network-and-cache'
  export type ServiceWorkerRouterInfo = {
    ruleIdMatched?: number
    matchedSourceType?: ServiceWorkerRouterSource
    actualSourceType?: ServiceWorkerRouterSource
  }
  export type Response = {
    url: string
    status: number
    statusText: string
    headers: Headers
    headersText?: string
    mimeType: string
    charset: string
    requestHeaders?: Headers
    requestHeadersText?: string
    connectionReused: boolean
    connectionId: number
    remoteIPAddress?: string
    remotePort?: number
    fromDiskCache?: boolean
    fromServiceWorker?: boolean
    fromPrefetchCache?: boolean
    fromEarlyHints?: boolean
    serviceWorkerRouterInfo?: ServiceWorkerRouterInfo
    encodedDataLength: number
    timing?: ResourceTiming
    serviceWorkerResponseSource?: ServiceWorkerResponseSource
    responseTime?: TimeSinceEpoch
    cacheStorageCacheName?: string
    protocol?: string
    alternateProtocolUsage?: AlternateProtocolUsage
    securityState: Security.SecurityState
    securityDetails?: SecurityDetails
  }
  export type WebSocketRequest = { headers: Headers }
  export type WebSocketResponse = {
    status: number
    statusText: string
    headers: Headers
    headersText?: string
    requestHeaders?: Headers
    requestHeadersText?: string
  }
  export type WebSocketFrame = {
    opcode: number
    mask: boolean
    payloadData: string
  }
  export type CachedResource = {
    url: string
    type: ResourceType
    response?: Response
    bodySize: number
  }
  export type Initiator = {
    type:
      | 'parser'
      | 'script'
      | 'preload'
      | 'SignedExchange'
      | 'preflight'
      | 'other'
    stack?: Runtime.StackTrace
    url?: string
    lineNumber?: number
    columnNumber?: number
    requestId?: RequestId
  }
  export type CookiePartitionKey = {
    topLevelSite: string
    hasCrossSiteAncestor: boolean
  }
  export type Cookie = {
    name: string
    value: string
    domain: string
    path: string
    expires: number
    size: number
    httpOnly: boolean
    secure: boolean
    session: boolean
    sameSite?: CookieSameSite
    priority: CookiePriority
    sameParty: boolean
    sourceScheme: CookieSourceScheme
    sourcePort: number
    partitionKey?: CookiePartitionKey
    partitionKeyOpaque?: boolean
  }
  export type SetCookieBlockedReason =
    | 'SecureOnly'
    | 'SameSiteStrict'
    | 'SameSiteLax'
    | 'SameSiteUnspecifiedTreatedAsLax'
    | 'SameSiteNoneInsecure'
    | 'UserPreferences'
    | 'ThirdPartyPhaseout'
    | 'ThirdPartyBlockedInFirstPartySet'
    | 'SyntaxError'
    | 'SchemeNotSupported'
    | 'OverwriteSecure'
    | 'InvalidDomain'
    | 'InvalidPrefix'
    | 'UnknownError'
    | 'SchemefulSameSiteStrict'
    | 'SchemefulSameSiteLax'
    | 'SchemefulSameSiteUnspecifiedTreatedAsLax'
    | 'SamePartyFromCrossPartyContext'
    | 'SamePartyConflictsWithOtherAttributes'
    | 'NameValuePairExceedsMaxSize'
    | 'DisallowedCharacter'
    | 'NoCookieContent'
  export type CookieBlockedReason =
    | 'SecureOnly'
    | 'NotOnPath'
    | 'DomainMismatch'
    | 'SameSiteStrict'
    | 'SameSiteLax'
    | 'SameSiteUnspecifiedTreatedAsLax'
    | 'SameSiteNoneInsecure'
    | 'UserPreferences'
    | 'ThirdPartyPhaseout'
    | 'ThirdPartyBlockedInFirstPartySet'
    | 'UnknownError'
    | 'SchemefulSameSiteStrict'
    | 'SchemefulSameSiteLax'
    | 'SchemefulSameSiteUnspecifiedTreatedAsLax'
    | 'SamePartyFromCrossPartyContext'
    | 'NameValuePairExceedsMaxSize'
    | 'PortMismatch'
    | 'SchemeMismatch'
    | 'AnonymousContext'
  export type CookieExemptionReason =
    | 'None'
    | 'UserSetting'
    | 'TPCDMetadata'
    | 'TPCDDeprecationTrial'
    | 'TopLevelTPCDDeprecationTrial'
    | 'TPCDHeuristics'
    | 'EnterprisePolicy'
    | 'StorageAccess'
    | 'TopLevelStorageAccess'
    | 'Scheme'
    | 'SameSiteNoneCookiesInSandbox'
  export type BlockedSetCookieWithReason = {
    blockedReasons: SetCookieBlockedReason[]
    cookieLine: string
    cookie?: Cookie
  }
  export type ExemptedSetCookieWithReason = {
    exemptionReason: CookieExemptionReason
    cookieLine: string
    cookie: Cookie
  }
  export type AssociatedCookie = {
    cookie: Cookie
    blockedReasons: CookieBlockedReason[]
    exemptionReason?: CookieExemptionReason
  }
  export type CookieParam = {
    name: string
    value: string
    url?: string
    domain?: string
    path?: string
    secure?: boolean
    httpOnly?: boolean
    sameSite?: CookieSameSite
    expires?: TimeSinceEpoch
    priority?: CookiePriority
    sameParty?: boolean
    sourceScheme?: CookieSourceScheme
    sourcePort?: number
    partitionKey?: CookiePartitionKey
  }
  export type AuthChallenge = {
    source?: 'Server' | 'Proxy'
    origin: string
    scheme: string
    realm: string
  }
  export type AuthChallengeResponse = {
    response: 'Default' | 'CancelAuth' | 'ProvideCredentials'
    username?: string
    password?: string
  }
  export type InterceptionStage = 'Request' | 'HeadersReceived'
  export type RequestPattern = {
    urlPattern?: string
    resourceType?: ResourceType
    interceptionStage?: InterceptionStage
  }
  export type SignedExchangeSignature = {
    label: string
    signature: string
    integrity: string
    certUrl?: string
    certSha256?: string
    validityUrl: string
    date: number
    expires: number
    certificates?: string[]
  }
  export type SignedExchangeHeader = {
    requestUrl: string
    responseCode: number
    responseHeaders: Headers
    signatures: SignedExchangeSignature[]
    headerIntegrity: string
  }
  export type SignedExchangeErrorField =
    | 'signatureSig'
    | 'signatureIntegrity'
    | 'signatureCertUrl'
    | 'signatureCertSha256'
    | 'signatureValidityUrl'
    | 'signatureTimestamps'
  export type SignedExchangeError = {
    message: string
    signatureIndex?: number
    errorField?: SignedExchangeErrorField
  }
  export type SignedExchangeInfo = {
    outerResponse: Response
    header?: SignedExchangeHeader
    securityDetails?: SecurityDetails
    errors?: SignedExchangeError[]
  }
  export type ContentEncoding = 'deflate' | 'gzip' | 'br' | 'zstd'
  export type DirectSocketDnsQueryType = 'ipv4' | 'ipv6'
  export type DirectTCPSocketOptions = {
    noDelay: boolean
    keepAliveDelay?: number
    sendBufferSize?: number
    receiveBufferSize?: number
    dnsQueryType?: DirectSocketDnsQueryType
  }
  export type DirectUDPSocketOptions = {
    remoteAddr?: string
    remotePort?: number
    localAddr?: string
    localPort?: number
    dnsQueryType?: DirectSocketDnsQueryType
    sendBufferSize?: number
    receiveBufferSize?: number
  }
  export type DirectUDPMessage = {
    data: string
    remoteAddr?: string
    remotePort?: number
  }
  export type PrivateNetworkRequestPolicy =
    | 'Allow'
    | 'BlockFromInsecureToMorePrivate'
    | 'WarnFromInsecureToMorePrivate'
    | 'PreflightBlock'
    | 'PreflightWarn'
    | 'PermissionBlock'
    | 'PermissionWarn'
  export type IPAddressSpace = 'Local' | 'Private' | 'Public' | 'Unknown'
  export type ConnectTiming = { requestTime: number }
  export type ClientSecurityState = {
    initiatorIsSecureContext: boolean
    initiatorIPAddressSpace: IPAddressSpace
    privateNetworkRequestPolicy: PrivateNetworkRequestPolicy
  }
  export type CrossOriginOpenerPolicyValue =
    | 'SameOrigin'
    | 'SameOriginAllowPopups'
    | 'RestrictProperties'
    | 'UnsafeNone'
    | 'SameOriginPlusCoep'
    | 'RestrictPropertiesPlusCoep'
    | 'NoopenerAllowPopups'
  export type CrossOriginOpenerPolicyStatus = {
    value: CrossOriginOpenerPolicyValue
    reportOnlyValue: CrossOriginOpenerPolicyValue
    reportingEndpoint?: string
    reportOnlyReportingEndpoint?: string
  }
  export type CrossOriginEmbedderPolicyValue =
    | 'None'
    | 'Credentialless'
    | 'RequireCorp'
  export type CrossOriginEmbedderPolicyStatus = {
    value: CrossOriginEmbedderPolicyValue
    reportOnlyValue: CrossOriginEmbedderPolicyValue
    reportingEndpoint?: string
    reportOnlyReportingEndpoint?: string
  }
  export type ContentSecurityPolicySource = 'HTTP' | 'Meta'
  export type ContentSecurityPolicyStatus = {
    effectiveDirectives: string
    isEnforced: boolean
    source: ContentSecurityPolicySource
  }
  export type SecurityIsolationStatus = {
    coop?: CrossOriginOpenerPolicyStatus
    coep?: CrossOriginEmbedderPolicyStatus
    csp?: ContentSecurityPolicyStatus[]
  }
  export type ReportStatus =
    | 'Queued'
    | 'Pending'
    | 'MarkedForRemoval'
    | 'Success'
  export type ReportId = string
  export type ReportingApiReport = {
    id: ReportId
    initiatorUrl: string
    destination: string
    type: string
    timestamp: Network.TimeSinceEpoch
    depth: number
    completedAttempts: number
    body: Record<string, unknown>
    status: ReportStatus
  }
  export type ReportingApiEndpoint = { url: string; groupName: string }
  export type LoadNetworkResourcePageResult = {
    success: boolean
    netError?: number
    netErrorName?: string
    httpStatusCode?: number
    stream?: IO.StreamHandle
    headers?: Network.Headers
  }
  export type LoadNetworkResourceOptions = {
    disableCache: boolean
    includeCredentials: boolean
  }
  export interface ContinueInterceptedRequestArgs {
    interceptionId: InterceptionId
    errorReason?: ErrorReason
    rawResponse?: string
    url?: string
    method?: string
    postData?: string
    headers?: Headers
    authChallengeResponse?: AuthChallengeResponse
  }
  export interface DeleteCookiesArgs {
    name: string
    url?: string
    domain?: string
    path?: string
    partitionKey?: CookiePartitionKey
  }
  export interface EmulateNetworkConditionsArgs {
    offline: boolean
    latency: number
    downloadThroughput: number
    uploadThroughput: number
    connectionType?: ConnectionType
    packetLoss?: number
    packetQueueLength?: number
    packetReordering?: boolean
  }
  export interface EnableArgs {
    maxTotalBufferSize?: number
    maxResourceBufferSize?: number
    maxPostDataSize?: number
    reportDirectSocketTraffic?: boolean
  }
  export interface SearchInResponseBodyArgs {
    requestId: RequestId
    query: string
    caseSensitive?: boolean
    isRegex?: boolean
  }
  export interface SetCookieArgs {
    name: string
    value: string
    url?: string
    domain?: string
    path?: string
    secure?: boolean
    httpOnly?: boolean
    sameSite?: CookieSameSite
    expires?: TimeSinceEpoch
    priority?: CookiePriority
    sameParty?: boolean
    sourceScheme?: CookieSourceScheme
    sourcePort?: number
    partitionKey?: CookiePartitionKey
  }
  export interface SetUserAgentOverrideArgs {
    userAgent: string
    acceptLanguage?: string
    platform?: string
    userAgentMetadata?: Emulation.UserAgentMetadata
  }
  export interface LoadNetworkResourceArgs {
    frameId?: Page.FrameId
    url: string
    options: LoadNetworkResourceOptions
  }
  export interface SetCookieControlsArgs {
    enableThirdPartyCookieRestriction: boolean
    disableThirdPartyCookieMetadata: boolean
    disableThirdPartyCookieHeuristics: boolean
  }
  export interface CanClearBrowserCacheResult {
    result: boolean
  }
  export interface CanClearBrowserCookiesResult {
    result: boolean
  }
  export interface CanEmulateNetworkConditionsResult {
    result: boolean
  }
  export interface GetAllCookiesResult {
    cookies: Cookie[]
  }
  export interface GetCertificateResult {
    tableNames: string[]
  }
  export interface GetCookiesResult {
    cookies: Cookie[]
  }
  export interface GetResponseBodyResult {
    body: string
    base64Encoded: boolean
  }
  export interface GetRequestPostDataResult {
    postData: string
  }
  export interface GetResponseBodyForInterceptionResult {
    body: string
    base64Encoded: boolean
  }
  export interface TakeResponseBodyForInterceptionAsStreamResult {
    stream: IO.StreamHandle
  }
  export interface SearchInResponseBodyResult {
    result: Debugger.SearchMatch[]
  }
  export interface SetCookieResult {
    success: boolean
  }
  export interface StreamResourceContentResult {
    bufferedData: string
  }
  export interface GetSecurityIsolationStatusResult {
    status: SecurityIsolationStatus
  }
  export interface LoadNetworkResourceResult {
    resource: LoadNetworkResourcePageResult
  }
  export interface DataReceivedEvent {
    requestId: RequestId
    timestamp: MonotonicTime
    dataLength: number
    encodedDataLength: number
    data: string
  }
  export interface EventSourceMessageReceivedEvent {
    requestId: RequestId
    timestamp: MonotonicTime
    eventName: string
    eventId: string
    data: string
  }
  export interface LoadingFailedEvent {
    requestId: RequestId
    timestamp: MonotonicTime
    type: ResourceType
    errorText: string
    canceled: boolean
    blockedReason: BlockedReason
    corsErrorStatus: CorsErrorStatus
  }
  export interface LoadingFinishedEvent {
    requestId: RequestId
    timestamp: MonotonicTime
    encodedDataLength: number
  }
  export interface RequestInterceptedEvent {
    interceptionId: InterceptionId
    request: Request
    frameId: Page.FrameId
    resourceType: ResourceType
    isNavigationRequest: boolean
    isDownload: boolean
    redirectUrl: string
    authChallenge: AuthChallenge
    responseErrorReason: ErrorReason
    responseStatusCode: number
    responseHeaders: Headers
    requestId: RequestId
  }
  export interface RequestServedFromCacheEvent {
    requestId: RequestId
  }
  export interface RequestWillBeSentEvent {
    requestId: RequestId
    loaderId: LoaderId
    documentURL: string
    request: Request
    timestamp: MonotonicTime
    wallTime: TimeSinceEpoch
    initiator: Initiator
    redirectHasExtraInfo: boolean
    redirectResponse: Response
    type: ResourceType
    frameId: Page.FrameId
    hasUserGesture: boolean
  }
  export interface ResourceChangedPriorityEvent {
    requestId: RequestId
    newPriority: ResourcePriority
    timestamp: MonotonicTime
  }
  export interface SignedExchangeReceivedEvent {
    requestId: RequestId
    info: SignedExchangeInfo
  }
  export interface ResponseReceivedEvent {
    requestId: RequestId
    loaderId: LoaderId
    timestamp: MonotonicTime
    type: ResourceType
    response: Response
    hasExtraInfo: boolean
    frameId: Page.FrameId
  }
  export interface WebSocketClosedEvent {
    requestId: RequestId
    timestamp: MonotonicTime
  }
  export interface WebSocketCreatedEvent {
    requestId: RequestId
    url: string
    initiator: Initiator
  }
  export interface WebSocketFrameErrorEvent {
    requestId: RequestId
    timestamp: MonotonicTime
    errorMessage: string
  }
  export interface WebSocketFrameReceivedEvent {
    requestId: RequestId
    timestamp: MonotonicTime
    response: WebSocketFrame
  }
  export interface WebSocketFrameSentEvent {
    requestId: RequestId
    timestamp: MonotonicTime
    response: WebSocketFrame
  }
  export interface WebSocketHandshakeResponseReceivedEvent {
    requestId: RequestId
    timestamp: MonotonicTime
    response: WebSocketResponse
  }
  export interface WebSocketWillSendHandshakeRequestEvent {
    requestId: RequestId
    timestamp: MonotonicTime
    wallTime: TimeSinceEpoch
    request: WebSocketRequest
  }
  export interface WebTransportCreatedEvent {
    transportId: RequestId
    url: string
    timestamp: MonotonicTime
    initiator: Initiator
  }
  export interface WebTransportConnectionEstablishedEvent {
    transportId: RequestId
    timestamp: MonotonicTime
  }
  export interface WebTransportClosedEvent {
    transportId: RequestId
    timestamp: MonotonicTime
  }
  export interface DirectTCPSocketCreatedEvent {
    identifier: RequestId
    remoteAddr: string
    remotePort: number
    options: DirectTCPSocketOptions
    timestamp: MonotonicTime
    initiator: Initiator
  }
  export interface DirectTCPSocketOpenedEvent {
    identifier: RequestId
    remoteAddr: string
    remotePort: number
    timestamp: MonotonicTime
    localAddr: string
    localPort: number
  }
  export interface DirectTCPSocketAbortedEvent {
    identifier: RequestId
    errorMessage: string
    timestamp: MonotonicTime
  }
  export interface DirectTCPSocketClosedEvent {
    identifier: RequestId
    timestamp: MonotonicTime
  }
  export interface DirectTCPSocketChunkSentEvent {
    identifier: RequestId
    data: string
    timestamp: MonotonicTime
  }
  export interface DirectTCPSocketChunkReceivedEvent {
    identifier: RequestId
    data: string
    timestamp: MonotonicTime
  }
  export interface DirectUDPSocketCreatedEvent {
    identifier: RequestId
    options: DirectUDPSocketOptions
    timestamp: MonotonicTime
    initiator: Initiator
  }
  export interface DirectUDPSocketOpenedEvent {
    identifier: RequestId
    localAddr: string
    localPort: number
    timestamp: MonotonicTime
    remoteAddr: string
    remotePort: number
  }
  export interface DirectUDPSocketAbortedEvent {
    identifier: RequestId
    errorMessage: string
    timestamp: MonotonicTime
  }
  export interface DirectUDPSocketClosedEvent {
    identifier: RequestId
    timestamp: MonotonicTime
  }
  export interface DirectUDPSocketChunkSentEvent {
    identifier: RequestId
    message: DirectUDPMessage
    timestamp: MonotonicTime
  }
  export interface DirectUDPSocketChunkReceivedEvent {
    identifier: RequestId
    message: DirectUDPMessage
    timestamp: MonotonicTime
  }
  export interface RequestWillBeSentExtraInfoEvent {
    requestId: RequestId
    associatedCookies: AssociatedCookie[]
    headers: Headers
    connectTiming: ConnectTiming
    clientSecurityState: ClientSecurityState
    siteHasCookieInOtherPartition: boolean
  }
  export interface ResponseReceivedExtraInfoEvent {
    requestId: RequestId
    blockedCookies: BlockedSetCookieWithReason[]
    headers: Headers
    resourceIPAddressSpace: IPAddressSpace
    statusCode: number
    headersText: string
    cookiePartitionKey: CookiePartitionKey
    cookiePartitionKeyOpaque: boolean
    exemptedCookies: ExemptedSetCookieWithReason[]
  }
  export interface ResponseReceivedEarlyHintsEvent {
    requestId: RequestId
    headers: Headers
  }
  export interface TrustTokenOperationDoneEvent {
    status:
      | 'Ok'
      | 'InvalidArgument'
      | 'MissingIssuerKeys'
      | 'FailedPrecondition'
      | 'ResourceExhausted'
      | 'AlreadyExists'
      | 'ResourceLimited'
      | 'Unauthorized'
      | 'BadResponse'
      | 'InternalError'
      | 'UnknownError'
      | 'FulfilledLocally'
      | 'SiteIssuerLimit'
    type: TrustTokenOperationType
    requestId: RequestId
    topLevelOrigin: string
    issuerOrigin: string
    issuedTokenCount: number
  }
  export interface PolicyUpdatedEvent {}
  export interface SubresourceWebBundleMetadataReceivedEvent {
    requestId: RequestId
    urls: string[]
  }
  export interface SubresourceWebBundleMetadataErrorEvent {
    requestId: RequestId
    errorMessage: string
  }
  export interface SubresourceWebBundleInnerResponseParsedEvent {
    innerRequestId: RequestId
    innerRequestURL: string
    bundleRequestId: RequestId
  }
  export interface SubresourceWebBundleInnerResponseErrorEvent {
    innerRequestId: RequestId
    innerRequestURL: string
    errorMessage: string
    bundleRequestId: RequestId
  }
  export interface ReportingApiReportAddedEvent {
    report: ReportingApiReport
  }
  export interface ReportingApiReportUpdatedEvent {
    report: ReportingApiReport
  }
  export interface ReportingApiEndpointsChangedForOriginEvent {
    origin: string
    endpoints: ReportingApiEndpoint[]
  }
  export interface EventMap {
    dataReceived: DataReceivedEvent
    eventSourceMessageReceived: EventSourceMessageReceivedEvent
    loadingFailed: LoadingFailedEvent
    loadingFinished: LoadingFinishedEvent
    requestIntercepted: RequestInterceptedEvent
    requestServedFromCache: RequestServedFromCacheEvent
    requestWillBeSent: RequestWillBeSentEvent
    resourceChangedPriority: ResourceChangedPriorityEvent
    signedExchangeReceived: SignedExchangeReceivedEvent
    responseReceived: ResponseReceivedEvent
    webSocketClosed: WebSocketClosedEvent
    webSocketCreated: WebSocketCreatedEvent
    webSocketFrameError: WebSocketFrameErrorEvent
    webSocketFrameReceived: WebSocketFrameReceivedEvent
    webSocketFrameSent: WebSocketFrameSentEvent
    webSocketHandshakeResponseReceived: WebSocketHandshakeResponseReceivedEvent
    webSocketWillSendHandshakeRequest: WebSocketWillSendHandshakeRequestEvent
    webTransportCreated: WebTransportCreatedEvent
    webTransportConnectionEstablished: WebTransportConnectionEstablishedEvent
    webTransportClosed: WebTransportClosedEvent
    directTCPSocketCreated: DirectTCPSocketCreatedEvent
    directTCPSocketOpened: DirectTCPSocketOpenedEvent
    directTCPSocketAborted: DirectTCPSocketAbortedEvent
    directTCPSocketClosed: DirectTCPSocketClosedEvent
    directTCPSocketChunkSent: DirectTCPSocketChunkSentEvent
    directTCPSocketChunkReceived: DirectTCPSocketChunkReceivedEvent
    directUDPSocketCreated: DirectUDPSocketCreatedEvent
    directUDPSocketOpened: DirectUDPSocketOpenedEvent
    directUDPSocketAborted: DirectUDPSocketAbortedEvent
    directUDPSocketClosed: DirectUDPSocketClosedEvent
    directUDPSocketChunkSent: DirectUDPSocketChunkSentEvent
    directUDPSocketChunkReceived: DirectUDPSocketChunkReceivedEvent
    requestWillBeSentExtraInfo: RequestWillBeSentExtraInfoEvent
    responseReceivedExtraInfo: ResponseReceivedExtraInfoEvent
    responseReceivedEarlyHints: ResponseReceivedEarlyHintsEvent
    trustTokenOperationDone: TrustTokenOperationDoneEvent
    policyUpdated: PolicyUpdatedEvent
    subresourceWebBundleMetadataReceived: SubresourceWebBundleMetadataReceivedEvent
    subresourceWebBundleMetadataError: SubresourceWebBundleMetadataErrorEvent
    subresourceWebBundleInnerResponseParsed: SubresourceWebBundleInnerResponseParsedEvent
    subresourceWebBundleInnerResponseError: SubresourceWebBundleInnerResponseErrorEvent
    reportingApiReportAdded: ReportingApiReportAddedEvent
    reportingApiReportUpdated: ReportingApiReportUpdatedEvent
    reportingApiEndpointsChangedForOrigin: ReportingApiEndpointsChangedForOriginEvent
  }
}
export namespace Overlay {
  export type SourceOrderConfig = {
    parentOutlineColor: DOM.RGBA
    childOutlineColor: DOM.RGBA
  }
  export type GridHighlightConfig = {
    showGridExtensionLines?: boolean
    showPositiveLineNumbers?: boolean
    showNegativeLineNumbers?: boolean
    showAreaNames?: boolean
    showLineNames?: boolean
    showTrackSizes?: boolean
    gridBorderColor?: DOM.RGBA
    cellBorderColor?: DOM.RGBA
    rowLineColor?: DOM.RGBA
    columnLineColor?: DOM.RGBA
    gridBorderDash?: boolean
    cellBorderDash?: boolean
    rowLineDash?: boolean
    columnLineDash?: boolean
    rowGapColor?: DOM.RGBA
    rowHatchColor?: DOM.RGBA
    columnGapColor?: DOM.RGBA
    columnHatchColor?: DOM.RGBA
    areaBorderColor?: DOM.RGBA
    gridBackgroundColor?: DOM.RGBA
  }
  export type FlexContainerHighlightConfig = {
    containerBorder?: LineStyle
    lineSeparator?: LineStyle
    itemSeparator?: LineStyle
    mainDistributedSpace?: BoxStyle
    crossDistributedSpace?: BoxStyle
    rowGapSpace?: BoxStyle
    columnGapSpace?: BoxStyle
    crossAlignment?: LineStyle
  }
  export type FlexItemHighlightConfig = {
    baseSizeBox?: BoxStyle
    baseSizeBorder?: LineStyle
    flexibilityArrow?: LineStyle
  }
  export type LineStyle = { color?: DOM.RGBA; pattern?: 'dashed' | 'dotted' }
  export type BoxStyle = { fillColor?: DOM.RGBA; hatchColor?: DOM.RGBA }
  export type ContrastAlgorithm = 'aa' | 'aaa' | 'apca'
  export type HighlightConfig = {
    showInfo?: boolean
    showStyles?: boolean
    showRulers?: boolean
    showAccessibilityInfo?: boolean
    showExtensionLines?: boolean
    contentColor?: DOM.RGBA
    paddingColor?: DOM.RGBA
    borderColor?: DOM.RGBA
    marginColor?: DOM.RGBA
    eventTargetColor?: DOM.RGBA
    shapeColor?: DOM.RGBA
    shapeMarginColor?: DOM.RGBA
    cssGridColor?: DOM.RGBA
    colorFormat?: ColorFormat
    gridHighlightConfig?: GridHighlightConfig
    flexContainerHighlightConfig?: FlexContainerHighlightConfig
    flexItemHighlightConfig?: FlexItemHighlightConfig
    contrastAlgorithm?: ContrastAlgorithm
    containerQueryContainerHighlightConfig?: ContainerQueryContainerHighlightConfig
  }
  export type ColorFormat = 'rgb' | 'hsl' | 'hwb' | 'hex'
  export type GridNodeHighlightConfig = {
    gridHighlightConfig: GridHighlightConfig
    nodeId: DOM.NodeId
  }
  export type FlexNodeHighlightConfig = {
    flexContainerHighlightConfig: FlexContainerHighlightConfig
    nodeId: DOM.NodeId
  }
  export type ScrollSnapContainerHighlightConfig = {
    snapportBorder?: LineStyle
    snapAreaBorder?: LineStyle
    scrollMarginColor?: DOM.RGBA
    scrollPaddingColor?: DOM.RGBA
  }
  export type ScrollSnapHighlightConfig = {
    scrollSnapContainerHighlightConfig: ScrollSnapContainerHighlightConfig
    nodeId: DOM.NodeId
  }
  export type HingeConfig = {
    rect: DOM.Rect
    contentColor?: DOM.RGBA
    outlineColor?: DOM.RGBA
  }
  export type WindowControlsOverlayConfig = {
    showCSS: boolean
    selectedPlatform: string
    themeColor: string
  }
  export type ContainerQueryHighlightConfig = {
    containerQueryContainerHighlightConfig: ContainerQueryContainerHighlightConfig
    nodeId: DOM.NodeId
  }
  export type ContainerQueryContainerHighlightConfig = {
    containerBorder?: LineStyle
    descendantBorder?: LineStyle
  }
  export type IsolatedElementHighlightConfig = {
    isolationModeHighlightConfig: IsolationModeHighlightConfig
    nodeId: DOM.NodeId
  }
  export type IsolationModeHighlightConfig = {
    resizerColor?: DOM.RGBA
    resizerHandleColor?: DOM.RGBA
    maskColor?: DOM.RGBA
  }
  export type InspectMode =
    | 'searchForNode'
    | 'searchForUAShadowDOM'
    | 'captureAreaScreenshot'
    | 'showDistances'
    | 'none'
  export interface GetHighlightObjectForTestArgs {
    nodeId: DOM.NodeId
    includeDistance?: boolean
    includeStyle?: boolean
    colorFormat?: ColorFormat
    showAccessibilityInfo?: boolean
  }
  export interface HighlightFrameArgs {
    frameId: Page.FrameId
    contentColor?: DOM.RGBA
    contentOutlineColor?: DOM.RGBA
  }
  export interface HighlightNodeArgs {
    highlightConfig: HighlightConfig
    nodeId?: DOM.NodeId
    backendNodeId?: DOM.BackendNodeId
    objectId?: Runtime.RemoteObjectId
    selector?: string
  }
  export interface HighlightQuadArgs {
    quad: DOM.Quad
    color?: DOM.RGBA
    outlineColor?: DOM.RGBA
  }
  export interface HighlightRectArgs {
    x: number
    y: number
    width: number
    height: number
    color?: DOM.RGBA
    outlineColor?: DOM.RGBA
  }
  export interface HighlightSourceOrderArgs {
    sourceOrderConfig: SourceOrderConfig
    nodeId?: DOM.NodeId
    backendNodeId?: DOM.BackendNodeId
    objectId?: Runtime.RemoteObjectId
  }
  export interface SetInspectModeArgs {
    mode: InspectMode
    highlightConfig?: HighlightConfig
  }
  export interface GetHighlightObjectForTestResult {
    highlight: Record<string, unknown>
  }
  export interface GetGridHighlightObjectsForTestResult {
    highlights: Record<string, unknown>
  }
  export interface GetSourceOrderHighlightObjectForTestResult {
    highlight: Record<string, unknown>
  }
  export interface InspectNodeRequestedEvent {
    backendNodeId: DOM.BackendNodeId
  }
  export interface NodeHighlightRequestedEvent {
    nodeId: DOM.NodeId
  }
  export interface ScreenshotRequestedEvent {
    viewport: Page.Viewport
  }
  export interface InspectModeCanceledEvent {}
  export interface EventMap {
    inspectNodeRequested: InspectNodeRequestedEvent
    nodeHighlightRequested: NodeHighlightRequestedEvent
    screenshotRequested: ScreenshotRequestedEvent
    inspectModeCanceled: InspectModeCanceledEvent
  }
}
export namespace Page {
  export type FrameId = string
  export type AdFrameType = 'none' | 'child' | 'root'
  export type AdFrameExplanation =
    | 'ParentIsAd'
    | 'CreatedByAdScript'
    | 'MatchedBlockingRule'
  export type AdFrameStatus = {
    adFrameType: AdFrameType
    explanations?: AdFrameExplanation[]
  }
  export type AdScriptId = {
    scriptId: Runtime.ScriptId
    debuggerId: Runtime.UniqueDebuggerId
  }
  export type AdScriptAncestry = {
    ancestryChain: AdScriptId[]
    rootScriptFilterlistRule?: string
  }
  export type SecureContextType =
    | 'Secure'
    | 'SecureLocalhost'
    | 'InsecureScheme'
    | 'InsecureAncestor'
  export type CrossOriginIsolatedContextType =
    | 'Isolated'
    | 'NotIsolated'
    | 'NotIsolatedFeatureDisabled'
  export type GatedAPIFeatures =
    | 'SharedArrayBuffers'
    | 'SharedArrayBuffersTransferAllowed'
    | 'PerformanceMeasureMemory'
    | 'PerformanceProfile'
  export type PermissionsPolicyFeature =
    | 'accelerometer'
    | 'all-screens-capture'
    | 'ambient-light-sensor'
    | 'attribution-reporting'
    | 'autoplay'
    | 'bluetooth'
    | 'browsing-topics'
    | 'camera'
    | 'captured-surface-control'
    | 'ch-dpr'
    | 'ch-device-memory'
    | 'ch-downlink'
    | 'ch-ect'
    | 'ch-prefers-color-scheme'
    | 'ch-prefers-reduced-motion'
    | 'ch-prefers-reduced-transparency'
    | 'ch-rtt'
    | 'ch-save-data'
    | 'ch-ua'
    | 'ch-ua-arch'
    | 'ch-ua-bitness'
    | 'ch-ua-high-entropy-values'
    | 'ch-ua-platform'
    | 'ch-ua-model'
    | 'ch-ua-mobile'
    | 'ch-ua-form-factors'
    | 'ch-ua-full-version'
    | 'ch-ua-full-version-list'
    | 'ch-ua-platform-version'
    | 'ch-ua-wow64'
    | 'ch-viewport-height'
    | 'ch-viewport-width'
    | 'ch-width'
    | 'clipboard-read'
    | 'clipboard-write'
    | 'compute-pressure'
    | 'controlled-frame'
    | 'cross-origin-isolated'
    | 'deferred-fetch'
    | 'deferred-fetch-minimal'
    | 'device-attributes'
    | 'digital-credentials-get'
    | 'direct-sockets'
    | 'direct-sockets-private'
    | 'display-capture'
    | 'document-domain'
    | 'encrypted-media'
    | 'execution-while-out-of-viewport'
    | 'execution-while-not-rendered'
    | 'fenced-unpartitioned-storage-read'
    | 'focus-without-user-activation'
    | 'fullscreen'
    | 'frobulate'
    | 'gamepad'
    | 'geolocation'
    | 'gyroscope'
    | 'hid'
    | 'identity-credentials-get'
    | 'idle-detection'
    | 'interest-cohort'
    | 'join-ad-interest-group'
    | 'keyboard-map'
    | 'language-detector'
    | 'local-fonts'
    | 'local-network-access'
    | 'magnetometer'
    | 'media-playback-while-not-visible'
    | 'microphone'
    | 'midi'
    | 'on-device-speech-recognition'
    | 'otp-credentials'
    | 'payment'
    | 'picture-in-picture'
    | 'popins'
    | 'private-aggregation'
    | 'private-state-token-issuance'
    | 'private-state-token-redemption'
    | 'publickey-credentials-create'
    | 'publickey-credentials-get'
    | 'record-ad-auction-events'
    | 'rewriter'
    | 'run-ad-auction'
    | 'screen-wake-lock'
    | 'serial'
    | 'shared-autofill'
    | 'shared-storage'
    | 'shared-storage-select-url'
    | 'smart-card'
    | 'speaker-selection'
    | 'storage-access'
    | 'sub-apps'
    | 'summarizer'
    | 'sync-xhr'
    | 'translator'
    | 'unload'
    | 'usb'
    | 'usb-unrestricted'
    | 'vertical-scroll'
    | 'web-app-installation'
    | 'web-printing'
    | 'web-share'
    | 'window-management'
    | 'writer'
    | 'xr-spatial-tracking'
  export type PermissionsPolicyBlockReason =
    | 'Header'
    | 'IframeAttribute'
    | 'InFencedFrameTree'
    | 'InIsolatedApp'
  export type PermissionsPolicyBlockLocator = {
    frameId: FrameId
    blockReason: PermissionsPolicyBlockReason
  }
  export type PermissionsPolicyFeatureState = {
    feature: PermissionsPolicyFeature
    allowed: boolean
    locator?: PermissionsPolicyBlockLocator
  }
  export type OriginTrialTokenStatus =
    | 'Success'
    | 'NotSupported'
    | 'Insecure'
    | 'Expired'
    | 'WrongOrigin'
    | 'InvalidSignature'
    | 'Malformed'
    | 'WrongVersion'
    | 'FeatureDisabled'
    | 'TokenDisabled'
    | 'FeatureDisabledForUser'
    | 'UnknownTrial'
  export type OriginTrialStatus =
    | 'Enabled'
    | 'ValidTokenNotProvided'
    | 'OSNotSupported'
    | 'TrialNotAllowed'
  export type OriginTrialUsageRestriction = 'None' | 'Subset'
  export type OriginTrialToken = {
    origin: string
    matchSubDomains: boolean
    trialName: string
    expiryTime: Network.TimeSinceEpoch
    isThirdParty: boolean
    usageRestriction: OriginTrialUsageRestriction
  }
  export type OriginTrialTokenWithStatus = {
    rawTokenText: string
    parsedToken?: OriginTrialToken
    status: OriginTrialTokenStatus
  }
  export type OriginTrial = {
    trialName: string
    status: OriginTrialStatus
    tokensWithStatus: OriginTrialTokenWithStatus[]
  }
  export type SecurityOriginDetails = { isLocalhost: boolean }
  export type Frame = {
    id: FrameId
    parentId?: FrameId
    loaderId: Network.LoaderId
    name?: string
    url: string
    urlFragment?: string
    domainAndRegistry: string
    securityOrigin: string
    securityOriginDetails?: SecurityOriginDetails
    mimeType: string
    unreachableUrl?: string
    adFrameStatus?: AdFrameStatus
    secureContextType: SecureContextType
    crossOriginIsolatedContextType: CrossOriginIsolatedContextType
    gatedAPIFeatures: GatedAPIFeatures[]
  }
  export type FrameResource = {
    url: string
    type: Network.ResourceType
    mimeType: string
    lastModified?: Network.TimeSinceEpoch
    contentSize?: number
    failed?: boolean
    canceled?: boolean
  }
  export type FrameResourceTree = {
    frame: Frame
    childFrames?: FrameResourceTree[]
    resources: FrameResource[]
  }
  export type FrameTree = { frame: Frame; childFrames?: FrameTree[] }
  export type ScriptIdentifier = string
  export type TransitionType =
    | 'link'
    | 'typed'
    | 'address_bar'
    | 'auto_bookmark'
    | 'auto_subframe'
    | 'manual_subframe'
    | 'generated'
    | 'auto_toplevel'
    | 'form_submit'
    | 'reload'
    | 'keyword'
    | 'keyword_generated'
    | 'other'
  export type NavigationEntry = {
    id: number
    url: string
    userTypedURL: string
    title: string
    transitionType: TransitionType
  }
  export type ScreencastFrameMetadata = {
    offsetTop: number
    pageScaleFactor: number
    deviceWidth: number
    deviceHeight: number
    scrollOffsetX: number
    scrollOffsetY: number
    timestamp?: Network.TimeSinceEpoch
  }
  export type DialogType = 'alert' | 'confirm' | 'prompt' | 'beforeunload'
  export type AppManifestError = {
    message: string
    critical: number
    line: number
    column: number
  }
  export type AppManifestParsedProperties = { scope: string }
  export type LayoutViewport = {
    pageX: number
    pageY: number
    clientWidth: number
    clientHeight: number
  }
  export type VisualViewport = {
    offsetX: number
    offsetY: number
    pageX: number
    pageY: number
    clientWidth: number
    clientHeight: number
    scale: number
    zoom?: number
  }
  export type Viewport = {
    x: number
    y: number
    width: number
    height: number
    scale: number
  }
  export type FontFamilies = {
    standard?: string
    fixed?: string
    serif?: string
    sansSerif?: string
    cursive?: string
    fantasy?: string
    math?: string
  }
  export type ScriptFontFamilies = {
    script: string
    fontFamilies: FontFamilies
  }
  export type FontSizes = { standard?: number; fixed?: number }
  export type ClientNavigationReason =
    | 'anchorClick'
    | 'formSubmissionGet'
    | 'formSubmissionPost'
    | 'httpHeaderRefresh'
    | 'initialFrameNavigation'
    | 'metaTagRefresh'
    | 'other'
    | 'pageBlockInterstitial'
    | 'reload'
    | 'scriptInitiated'
  export type ClientNavigationDisposition =
    | 'currentTab'
    | 'newTab'
    | 'newWindow'
    | 'download'
  export type InstallabilityErrorArgument = { name: string; value: string }
  export type InstallabilityError = {
    errorId: string
    errorArguments: InstallabilityErrorArgument[]
  }
  export type ReferrerPolicy =
    | 'noReferrer'
    | 'noReferrerWhenDowngrade'
    | 'origin'
    | 'originWhenCrossOrigin'
    | 'sameOrigin'
    | 'strictOrigin'
    | 'strictOriginWhenCrossOrigin'
    | 'unsafeUrl'
  export type CompilationCacheParams = { url: string; eager?: boolean }
  export type FileFilter = { name?: string; accepts?: string[] }
  export type FileHandler = {
    action: string
    name: string
    icons?: ImageResource[]
    accepts?: FileFilter[]
    launchType: string
  }
  export type ImageResource = { url: string; sizes?: string; type?: string }
  export type LaunchHandler = { clientMode: string }
  export type ProtocolHandler = { protocol: string; url: string }
  export type RelatedApplication = { id?: string; url: string }
  export type ScopeExtension = { origin: string; hasOriginWildcard: boolean }
  export type Screenshot = {
    image: ImageResource
    formFactor: string
    label?: string
  }
  export type ShareTarget = {
    action: string
    method: string
    enctype: string
    title?: string
    text?: string
    url?: string
    files?: FileFilter[]
  }
  export type Shortcut = { name: string; url: string }
  export type WebAppManifest = {
    backgroundColor?: string
    description?: string
    dir?: string
    display?: string
    displayOverrides?: string[]
    fileHandlers?: FileHandler[]
    icons?: ImageResource[]
    id?: string
    lang?: string
    launchHandler?: LaunchHandler
    name?: string
    orientation?: string
    preferRelatedApplications?: boolean
    protocolHandlers?: ProtocolHandler[]
    relatedApplications?: RelatedApplication[]
    scope?: string
    scopeExtensions?: ScopeExtension[]
    screenshots?: Screenshot[]
    shareTarget?: ShareTarget
    shortName?: string
    shortcuts?: Shortcut[]
    startUrl?: string
    themeColor?: string
  }
  export type AutoResponseMode =
    | 'none'
    | 'autoAccept'
    | 'autoReject'
    | 'autoOptOut'
  export type NavigationType = 'Navigation' | 'BackForwardCacheRestore'
  export type BackForwardCacheNotRestoredReason =
    | 'NotPrimaryMainFrame'
    | 'BackForwardCacheDisabled'
    | 'RelatedActiveContentsExist'
    | 'HTTPStatusNotOK'
    | 'SchemeNotHTTPOrHTTPS'
    | 'Loading'
    | 'WasGrantedMediaAccess'
    | 'DisableForRenderFrameHostCalled'
    | 'DomainNotAllowed'
    | 'HTTPMethodNotGET'
    | 'SubframeIsNavigating'
    | 'Timeout'
    | 'CacheLimit'
    | 'JavaScriptExecution'
    | 'RendererProcessKilled'
    | 'RendererProcessCrashed'
    | 'SchedulerTrackedFeatureUsed'
    | 'ConflictingBrowsingInstance'
    | 'CacheFlushed'
    | 'ServiceWorkerVersionActivation'
    | 'SessionRestored'
    | 'ServiceWorkerPostMessage'
    | 'EnteredBackForwardCacheBeforeServiceWorkerHostAdded'
    | 'RenderFrameHostReused_SameSite'
    | 'RenderFrameHostReused_CrossSite'
    | 'ServiceWorkerClaim'
    | 'IgnoreEventAndEvict'
    | 'HaveInnerContents'
    | 'TimeoutPuttingInCache'
    | 'BackForwardCacheDisabledByLowMemory'
    | 'BackForwardCacheDisabledByCommandLine'
    | 'NetworkRequestDatapipeDrainedAsBytesConsumer'
    | 'NetworkRequestRedirected'
    | 'NetworkRequestTimeout'
    | 'NetworkExceedsBufferLimit'
    | 'NavigationCancelledWhileRestoring'
    | 'NotMostRecentNavigationEntry'
    | 'BackForwardCacheDisabledForPrerender'
    | 'UserAgentOverrideDiffers'
    | 'ForegroundCacheLimit'
    | 'BrowsingInstanceNotSwapped'
    | 'BackForwardCacheDisabledForDelegate'
    | 'UnloadHandlerExistsInMainFrame'
    | 'UnloadHandlerExistsInSubFrame'
    | 'ServiceWorkerUnregistration'
    | 'CacheControlNoStore'
    | 'CacheControlNoStoreCookieModified'
    | 'CacheControlNoStoreHTTPOnlyCookieModified'
    | 'NoResponseHead'
    | 'Unknown'
    | 'ActivationNavigationsDisallowedForBug1234857'
    | 'ErrorDocument'
    | 'FencedFramesEmbedder'
    | 'CookieDisabled'
    | 'HTTPAuthRequired'
    | 'CookieFlushed'
    | 'BroadcastChannelOnMessage'
    | 'WebViewSettingsChanged'
    | 'WebViewJavaScriptObjectChanged'
    | 'WebViewMessageListenerInjected'
    | 'WebViewSafeBrowsingAllowlistChanged'
    | 'WebViewDocumentStartJavascriptChanged'
    | 'WebSocket'
    | 'WebTransport'
    | 'WebRTC'
    | 'MainResourceHasCacheControlNoStore'
    | 'MainResourceHasCacheControlNoCache'
    | 'SubresourceHasCacheControlNoStore'
    | 'SubresourceHasCacheControlNoCache'
    | 'ContainsPlugins'
    | 'DocumentLoaded'
    | 'OutstandingNetworkRequestOthers'
    | 'RequestedMIDIPermission'
    | 'RequestedAudioCapturePermission'
    | 'RequestedVideoCapturePermission'
    | 'RequestedBackForwardCacheBlockedSensors'
    | 'RequestedBackgroundWorkPermission'
    | 'BroadcastChannel'
    | 'WebXR'
    | 'SharedWorker'
    | 'WebLocks'
    | 'WebHID'
    | 'WebShare'
    | 'RequestedStorageAccessGrant'
    | 'WebNfc'
    | 'OutstandingNetworkRequestFetch'
    | 'OutstandingNetworkRequestXHR'
    | 'AppBanner'
    | 'Printing'
    | 'WebDatabase'
    | 'PictureInPicture'
    | 'SpeechRecognizer'
    | 'IdleManager'
    | 'PaymentManager'
    | 'SpeechSynthesis'
    | 'KeyboardLock'
    | 'WebOTPService'
    | 'OutstandingNetworkRequestDirectSocket'
    | 'InjectedJavascript'
    | 'InjectedStyleSheet'
    | 'KeepaliveRequest'
    | 'IndexedDBEvent'
    | 'Dummy'
    | 'JsNetworkRequestReceivedCacheControlNoStoreResource'
    | 'WebRTCSticky'
    | 'WebTransportSticky'
    | 'WebSocketSticky'
    | 'SmartCard'
    | 'LiveMediaStreamTrack'
    | 'UnloadHandler'
    | 'ParserAborted'
    | 'ContentSecurityHandler'
    | 'ContentWebAuthenticationAPI'
    | 'ContentFileChooser'
    | 'ContentSerial'
    | 'ContentFileSystemAccess'
    | 'ContentMediaDevicesDispatcherHost'
    | 'ContentWebBluetooth'
    | 'ContentWebUSB'
    | 'ContentMediaSessionService'
    | 'ContentScreenReader'
    | 'ContentDiscarded'
    | 'EmbedderPopupBlockerTabHelper'
    | 'EmbedderSafeBrowsingTriggeredPopupBlocker'
    | 'EmbedderSafeBrowsingThreatDetails'
    | 'EmbedderAppBannerManager'
    | 'EmbedderDomDistillerViewerSource'
    | 'EmbedderDomDistillerSelfDeletingRequestDelegate'
    | 'EmbedderOomInterventionTabHelper'
    | 'EmbedderOfflinePage'
    | 'EmbedderChromePasswordManagerClientBindCredentialManager'
    | 'EmbedderPermissionRequestManager'
    | 'EmbedderModalDialog'
    | 'EmbedderExtensions'
    | 'EmbedderExtensionMessaging'
    | 'EmbedderExtensionMessagingForOpenPort'
    | 'EmbedderExtensionSentMessageToCachedFrame'
    | 'RequestedByWebViewClient'
    | 'PostMessageByWebViewClient'
    | 'CacheControlNoStoreDeviceBoundSessionTerminated'
    | 'CacheLimitPrunedOnModerateMemoryPressure'
    | 'CacheLimitPrunedOnCriticalMemoryPressure'
  export type BackForwardCacheNotRestoredReasonType =
    | 'SupportPending'
    | 'PageSupportNeeded'
    | 'Circumstantial'
  export type BackForwardCacheBlockingDetails = {
    url?: string
    function?: string
    lineNumber: number
    columnNumber: number
  }
  export type BackForwardCacheNotRestoredExplanation = {
    type: BackForwardCacheNotRestoredReasonType
    reason: BackForwardCacheNotRestoredReason
    context?: string
    details?: BackForwardCacheBlockingDetails[]
  }
  export type BackForwardCacheNotRestoredExplanationTree = {
    url: string
    explanations: BackForwardCacheNotRestoredExplanation[]
    children: BackForwardCacheNotRestoredExplanationTree[]
  }
  export interface AddScriptToEvaluateOnNewDocumentArgs {
    source: string
    worldName?: string
    includeCommandLineAPI?: boolean
    runImmediately?: boolean
  }
  export interface CaptureScreenshotArgs {
    format?: 'jpeg' | 'png' | 'webp'
    quality?: number
    clip?: Viewport
    fromSurface?: boolean
    captureBeyondViewport?: boolean
    optimizeForSpeed?: boolean
  }
  export interface CreateIsolatedWorldArgs {
    frameId: FrameId
    worldName?: string
    grantUniveralAccess?: boolean
  }
  export interface DeleteCookieArgs {
    cookieName: string
    url: string
  }
  export interface GetResourceContentArgs {
    frameId: FrameId
    url: string
  }
  export interface HandleJavaScriptDialogArgs {
    accept: boolean
    promptText?: string
  }
  export interface NavigateArgs {
    url: string
    referrer?: string
    transitionType?: TransitionType
    frameId?: FrameId
    referrerPolicy?: ReferrerPolicy
  }
  export interface PrintToPDFArgs {
    landscape?: boolean
    displayHeaderFooter?: boolean
    printBackground?: boolean
    scale?: number
    paperWidth?: number
    paperHeight?: number
    marginTop?: number
    marginBottom?: number
    marginLeft?: number
    marginRight?: number
    pageRanges?: string
    headerTemplate?: string
    footerTemplate?: string
    preferCSSPageSize?: boolean
    transferMode?: 'ReturnAsBase64' | 'ReturnAsStream'
    generateTaggedPDF?: boolean
    generateDocumentOutline?: boolean
  }
  export interface ReloadArgs {
    ignoreCache?: boolean
    scriptToEvaluateOnLoad?: string
    loaderId?: Network.LoaderId
  }
  export interface SearchInResourceArgs {
    frameId: FrameId
    url: string
    query: string
    caseSensitive?: boolean
    isRegex?: boolean
  }
  export interface SetDeviceMetricsOverrideArgs {
    width: number
    height: number
    deviceScaleFactor: number
    mobile: boolean
    scale?: number
    screenWidth?: number
    screenHeight?: number
    positionX?: number
    positionY?: number
    dontSetVisibleSize?: boolean
    screenOrientation?: Emulation.ScreenOrientation
    viewport?: Viewport
  }
  export interface SetDeviceOrientationOverrideArgs {
    alpha: number
    beta: number
    gamma: number
  }
  export interface SetFontFamiliesArgs {
    fontFamilies: FontFamilies
    forScripts?: ScriptFontFamilies[]
  }
  export interface SetDocumentContentArgs {
    frameId: FrameId
    html: string
  }
  export interface SetDownloadBehaviorArgs {
    behavior: 'deny' | 'allow' | 'default'
    downloadPath?: string
  }
  export interface SetGeolocationOverrideArgs {
    latitude?: number
    longitude?: number
    accuracy?: number
  }
  export interface SetTouchEmulationEnabledArgs {
    enabled: boolean
    configuration?: 'mobile' | 'desktop'
  }
  export interface StartScreencastArgs {
    format?: 'jpeg' | 'png'
    quality?: number
    maxWidth?: number
    maxHeight?: number
    everyNthFrame?: number
  }
  export interface AddCompilationCacheArgs {
    url: string
    data: string
  }
  export interface GenerateTestReportArgs {
    message: string
    group?: string
  }
  export interface SetInterceptFileChooserDialogArgs {
    enabled: boolean
    cancel?: boolean
  }
  export interface AddScriptToEvaluateOnLoadResult {
    identifier: ScriptIdentifier
  }
  export interface AddScriptToEvaluateOnNewDocumentResult {
    identifier: ScriptIdentifier
  }
  export interface CaptureScreenshotResult {
    data: string
  }
  export interface CaptureSnapshotResult {
    data: string
  }
  export interface CreateIsolatedWorldResult {
    executionContextId: Runtime.ExecutionContextId
  }
  export interface GetAppManifestResult {
    url: string
    errors: AppManifestError[]
    data: string
    parsed: AppManifestParsedProperties
    manifest: WebAppManifest
  }
  export interface GetInstallabilityErrorsResult {
    installabilityErrors: InstallabilityError[]
  }
  export interface GetManifestIconsResult {
    primaryIcon: string
  }
  export interface GetAppIdResult {
    appId: string
    recommendedId: string
  }
  export interface GetAdScriptAncestryResult {
    adScriptAncestry: AdScriptAncestry
  }
  export interface GetFrameTreeResult {
    frameTree: FrameTree
  }
  export interface GetLayoutMetricsResult {
    layoutViewport: LayoutViewport
    visualViewport: VisualViewport
    contentSize: DOM.Rect
    cssLayoutViewport: LayoutViewport
    cssVisualViewport: VisualViewport
    cssContentSize: DOM.Rect
  }
  export interface GetNavigationHistoryResult {
    currentIndex: number
    entries: NavigationEntry[]
  }
  export interface GetResourceContentResult {
    content: string
    base64Encoded: boolean
  }
  export interface GetResourceTreeResult {
    frameTree: FrameResourceTree
  }
  export interface NavigateResult {
    frameId: FrameId
    loaderId: Network.LoaderId
    errorText: string
  }
  export interface PrintToPDFResult {
    data: string
    stream: IO.StreamHandle
  }
  export interface SearchInResourceResult {
    result: Debugger.SearchMatch[]
  }
  export interface GetPermissionsPolicyStateResult {
    states: PermissionsPolicyFeatureState[]
  }
  export interface GetOriginTrialsResult {
    originTrials: OriginTrial[]
  }
  export interface DomContentEventFiredEvent {
    timestamp: Network.MonotonicTime
  }
  export interface FileChooserOpenedEvent {
    frameId: FrameId
    mode: 'selectSingle' | 'selectMultiple'
    backendNodeId: DOM.BackendNodeId
  }
  export interface FrameAttachedEvent {
    frameId: FrameId
    parentFrameId: FrameId
    stack: Runtime.StackTrace
  }
  export interface FrameClearedScheduledNavigationEvent {
    frameId: FrameId
  }
  export interface FrameDetachedEvent {
    frameId: FrameId
    reason: 'remove' | 'swap'
  }
  export interface FrameSubtreeWillBeDetachedEvent {
    frameId: FrameId
  }
  export interface FrameNavigatedEvent {
    frame: Frame
    type: NavigationType
  }
  export interface DocumentOpenedEvent {
    frame: Frame
  }
  export interface FrameResizedEvent {}
  export interface FrameStartedNavigatingEvent {
    frameId: FrameId
    url: string
    loaderId: Network.LoaderId
    navigationType:
      | 'reload'
      | 'reloadBypassingCache'
      | 'restore'
      | 'restoreWithPost'
      | 'historySameDocument'
      | 'historyDifferentDocument'
      | 'sameDocument'
      | 'differentDocument'
  }
  export interface FrameRequestedNavigationEvent {
    frameId: FrameId
    reason: ClientNavigationReason
    url: string
    disposition: ClientNavigationDisposition
  }
  export interface FrameScheduledNavigationEvent {
    frameId: FrameId
    delay: number
    reason: ClientNavigationReason
    url: string
  }
  export interface FrameStartedLoadingEvent {
    frameId: FrameId
  }
  export interface FrameStoppedLoadingEvent {
    frameId: FrameId
  }
  export interface DownloadWillBeginEvent {
    frameId: FrameId
    guid: string
    url: string
    suggestedFilename: string
  }
  export interface DownloadProgressEvent {
    guid: string
    totalBytes: number
    receivedBytes: number
    state: 'inProgress' | 'completed' | 'canceled'
  }
  export interface InterstitialHiddenEvent {}
  export interface InterstitialShownEvent {}
  export interface JavascriptDialogClosedEvent {
    frameId: FrameId
    result: boolean
    userInput: string
  }
  export interface JavascriptDialogOpeningEvent {
    url: string
    frameId: FrameId
    message: string
    type: DialogType
    hasBrowserHandler: boolean
    defaultPrompt: string
  }
  export interface LifecycleEventEvent {
    frameId: FrameId
    loaderId: Network.LoaderId
    name: string
    timestamp: Network.MonotonicTime
  }
  export interface BackForwardCacheNotUsedEvent {
    loaderId: Network.LoaderId
    frameId: FrameId
    notRestoredExplanations: BackForwardCacheNotRestoredExplanation[]
    notRestoredExplanationsTree: BackForwardCacheNotRestoredExplanationTree
  }
  export interface LoadEventFiredEvent {
    timestamp: Network.MonotonicTime
  }
  export interface NavigatedWithinDocumentEvent {
    frameId: FrameId
    url: string
    navigationType: 'fragment' | 'historyApi' | 'other'
  }
  export interface ScreencastFrameEvent {
    data: string
    metadata: ScreencastFrameMetadata
    sessionId: number
  }
  export interface ScreencastVisibilityChangedEvent {
    visible: boolean
  }
  export interface WindowOpenEvent {
    url: string
    windowName: string
    windowFeatures: string[]
    userGesture: boolean
  }
  export interface CompilationCacheProducedEvent {
    url: string
    data: string
  }
  export interface EventMap {
    domContentEventFired: DomContentEventFiredEvent
    fileChooserOpened: FileChooserOpenedEvent
    frameAttached: FrameAttachedEvent
    frameClearedScheduledNavigation: FrameClearedScheduledNavigationEvent
    frameDetached: FrameDetachedEvent
    frameSubtreeWillBeDetached: FrameSubtreeWillBeDetachedEvent
    frameNavigated: FrameNavigatedEvent
    documentOpened: DocumentOpenedEvent
    frameResized: FrameResizedEvent
    frameStartedNavigating: FrameStartedNavigatingEvent
    frameRequestedNavigation: FrameRequestedNavigationEvent
    frameScheduledNavigation: FrameScheduledNavigationEvent
    frameStartedLoading: FrameStartedLoadingEvent
    frameStoppedLoading: FrameStoppedLoadingEvent
    downloadWillBegin: DownloadWillBeginEvent
    downloadProgress: DownloadProgressEvent
    interstitialHidden: InterstitialHiddenEvent
    interstitialShown: InterstitialShownEvent
    javascriptDialogClosed: JavascriptDialogClosedEvent
    javascriptDialogOpening: JavascriptDialogOpeningEvent
    lifecycleEvent: LifecycleEventEvent
    backForwardCacheNotUsed: BackForwardCacheNotUsedEvent
    loadEventFired: LoadEventFiredEvent
    navigatedWithinDocument: NavigatedWithinDocumentEvent
    screencastFrame: ScreencastFrameEvent
    screencastVisibilityChanged: ScreencastVisibilityChangedEvent
    windowOpen: WindowOpenEvent
    compilationCacheProduced: CompilationCacheProducedEvent
  }
}
export namespace Performance {
  export type Metric = { name: string; value: number }
  export interface GetMetricsResult {
    metrics: Metric[]
  }
  export interface MetricsEvent {
    metrics: Metric[]
    title: string
  }
  export interface EventMap {
    metrics: MetricsEvent
  }
}
export namespace PerformanceTimeline {
  export type LargestContentfulPaint = {
    renderTime: Network.TimeSinceEpoch
    loadTime: Network.TimeSinceEpoch
    size: number
    elementId?: string
    url?: string
    nodeId?: DOM.BackendNodeId
  }
  export type LayoutShiftAttribution = {
    previousRect: DOM.Rect
    currentRect: DOM.Rect
    nodeId?: DOM.BackendNodeId
  }
  export type LayoutShift = {
    value: number
    hadRecentInput: boolean
    lastInputTime: Network.TimeSinceEpoch
    sources: LayoutShiftAttribution[]
  }
  export type TimelineEvent = {
    frameId: Page.FrameId
    type: string
    name: string
    time: Network.TimeSinceEpoch
    duration?: number
    lcpDetails?: LargestContentfulPaint
    layoutShiftDetails?: LayoutShift
  }
  export interface TimelineEventAddedEvent {
    event: TimelineEvent
  }
  export interface EventMap {
    timelineEventAdded: TimelineEventAddedEvent
  }
}
export namespace Security {
  export type CertificateId = number
  export type MixedContentType = 'blockable' | 'optionally-blockable' | 'none'
  export type SecurityState =
    | 'unknown'
    | 'neutral'
    | 'insecure'
    | 'secure'
    | 'info'
    | 'insecure-broken'
  export type CertificateSecurityState = {
    protocol: string
    keyExchange: string
    keyExchangeGroup?: string
    cipher: string
    mac?: string
    certificate: string[]
    subjectName: string
    issuer: string
    validFrom: Network.TimeSinceEpoch
    validTo: Network.TimeSinceEpoch
    certificateNetworkError?: string
    certificateHasWeakSignature: boolean
    certificateHasSha1Signature: boolean
    modernSSL: boolean
    obsoleteSslProtocol: boolean
    obsoleteSslKeyExchange: boolean
    obsoleteSslCipher: boolean
    obsoleteSslSignature: boolean
  }
  export type SafetyTipStatus = 'badReputation' | 'lookalike'
  export type SafetyTipInfo = {
    safetyTipStatus: SafetyTipStatus
    safeUrl?: string
  }
  export type VisibleSecurityState = {
    securityState: SecurityState
    certificateSecurityState?: CertificateSecurityState
    safetyTipInfo?: SafetyTipInfo
    securityStateIssueIds: string[]
  }
  export type SecurityStateExplanation = {
    securityState: SecurityState
    title: string
    summary: string
    description: string
    mixedContentType: MixedContentType
    certificate: string[]
    recommendations?: string[]
  }
  export type InsecureContentStatus = {
    ranMixedContent: boolean
    displayedMixedContent: boolean
    containedMixedForm: boolean
    ranContentWithCertErrors: boolean
    displayedContentWithCertErrors: boolean
    ranInsecureContentStyle: SecurityState
    displayedInsecureContentStyle: SecurityState
  }
  export type CertificateErrorAction = 'continue' | 'cancel'
  export interface HandleCertificateErrorArgs {
    eventId: number
    action: CertificateErrorAction
  }
  export interface CertificateErrorEvent {
    eventId: number
    errorType: string
    requestURL: string
  }
  export interface VisibleSecurityStateChangedEvent {
    visibleSecurityState: VisibleSecurityState
  }
  export interface SecurityStateChangedEvent {
    securityState: SecurityState
    schemeIsCryptographic: boolean
    explanations: SecurityStateExplanation[]
    insecureContentStatus: InsecureContentStatus
    summary: string
  }
  export interface EventMap {
    certificateError: CertificateErrorEvent
    visibleSecurityStateChanged: VisibleSecurityStateChangedEvent
    securityStateChanged: SecurityStateChangedEvent
  }
}
export namespace ServiceWorker {
  export type RegistrationID = string
  export type ServiceWorkerRegistration = {
    registrationId: RegistrationID
    scopeURL: string
    isDeleted: boolean
  }
  export type ServiceWorkerVersionRunningStatus =
    | 'stopped'
    | 'starting'
    | 'running'
    | 'stopping'
  export type ServiceWorkerVersionStatus =
    | 'new'
    | 'installing'
    | 'installed'
    | 'activating'
    | 'activated'
    | 'redundant'
  export type ServiceWorkerVersion = {
    versionId: string
    registrationId: RegistrationID
    scriptURL: string
    runningStatus: ServiceWorkerVersionRunningStatus
    status: ServiceWorkerVersionStatus
    scriptLastModified?: number
    scriptResponseTime?: number
    controlledClients?: Target.TargetID[]
    targetId?: Target.TargetID
    routerRules?: string
  }
  export type ServiceWorkerErrorMessage = {
    errorMessage: string
    registrationId: RegistrationID
    versionId: string
    sourceURL: string
    lineNumber: number
    columnNumber: number
  }
  export interface DeliverPushMessageArgs {
    origin: string
    registrationId: RegistrationID
    data: string
  }
  export interface DispatchSyncEventArgs {
    origin: string
    registrationId: RegistrationID
    tag: string
    lastChance: boolean
  }
  export interface DispatchPeriodicSyncEventArgs {
    origin: string
    registrationId: RegistrationID
    tag: string
  }
  export interface WorkerErrorReportedEvent {
    errorMessage: ServiceWorkerErrorMessage
  }
  export interface WorkerRegistrationUpdatedEvent {
    registrations: ServiceWorkerRegistration[]
  }
  export interface WorkerVersionUpdatedEvent {
    versions: ServiceWorkerVersion[]
  }
  export interface EventMap {
    workerErrorReported: WorkerErrorReportedEvent
    workerRegistrationUpdated: WorkerRegistrationUpdatedEvent
    workerVersionUpdated: WorkerVersionUpdatedEvent
  }
}
export namespace Storage {
  export type SerializedStorageKey = string
  export type StorageType =
    | 'cookies'
    | 'file_systems'
    | 'indexeddb'
    | 'local_storage'
    | 'shader_cache'
    | 'websql'
    | 'service_workers'
    | 'cache_storage'
    | 'interest_groups'
    | 'shared_storage'
    | 'storage_buckets'
    | 'all'
    | 'other'
  export type UsageForType = { storageType: StorageType; usage: number }
  export type TrustTokens = { issuerOrigin: string; count: number }
  export type InterestGroupAuctionId = string
  export type InterestGroupAccessType =
    | 'join'
    | 'leave'
    | 'update'
    | 'loaded'
    | 'bid'
    | 'win'
    | 'additionalBid'
    | 'additionalBidWin'
    | 'topLevelBid'
    | 'topLevelAdditionalBid'
    | 'clear'
  export type InterestGroupAuctionEventType = 'started' | 'configResolved'
  export type InterestGroupAuctionFetchType =
    | 'bidderJs'
    | 'bidderWasm'
    | 'sellerJs'
    | 'bidderTrustedSignals'
    | 'sellerTrustedSignals'
  export type SharedStorageAccessScope =
    | 'window'
    | 'sharedStorageWorklet'
    | 'protectedAudienceWorklet'
    | 'header'
  export type SharedStorageAccessMethod =
    | 'addModule'
    | 'createWorklet'
    | 'selectURL'
    | 'run'
    | 'batchUpdate'
    | 'set'
    | 'append'
    | 'delete'
    | 'clear'
    | 'get'
    | 'keys'
    | 'values'
    | 'entries'
    | 'length'
    | 'remainingBudget'
  export type SharedStorageEntry = { key: string; value: string }
  export type SharedStorageMetadata = {
    creationTime: Network.TimeSinceEpoch
    length: number
    remainingBudget: number
    bytesUsed: number
  }
  export type SharedStoragePrivateAggregationConfig = {
    aggregationCoordinatorOrigin?: string
    contextId?: string
    filteringIdMaxBytes: number
    maxContributions?: number
  }
  export type SharedStorageReportingMetadata = {
    eventType: string
    reportingUrl: string
  }
  export type SharedStorageUrlWithMetadata = {
    url: string
    reportingMetadata: SharedStorageReportingMetadata[]
  }
  export type SharedStorageAccessParams = {
    scriptSourceUrl?: string
    dataOrigin?: string
    operationName?: string
    operationId?: string
    keepAlive?: boolean
    privateAggregationConfig?: SharedStoragePrivateAggregationConfig
    serializedData?: string
    urlsWithMetadata?: SharedStorageUrlWithMetadata[]
    urnUuid?: string
    key?: string
    value?: string
    ignoreIfPresent?: boolean
    workletOrdinal?: number
    workletTargetId?: Target.TargetID
    withLock?: string
    batchUpdateId?: string
    batchSize?: number
  }
  export type StorageBucketsDurability = 'relaxed' | 'strict'
  export type StorageBucket = {
    storageKey: SerializedStorageKey
    name?: string
  }
  export type StorageBucketInfo = {
    bucket: StorageBucket
    id: string
    expiration: Network.TimeSinceEpoch
    quota: number
    persistent: boolean
    durability: StorageBucketsDurability
  }
  export type AttributionReportingSourceType = 'navigation' | 'event'
  export type UnsignedInt64AsBase10 = string
  export type UnsignedInt128AsBase16 = string
  export type SignedInt64AsBase10 = string
  export type AttributionReportingFilterDataEntry = {
    key: string
    values: string[]
  }
  export type AttributionReportingFilterConfig = {
    filterValues: AttributionReportingFilterDataEntry[]
    lookbackWindow?: number
  }
  export type AttributionReportingFilterPair = {
    filters: AttributionReportingFilterConfig[]
    notFilters: AttributionReportingFilterConfig[]
  }
  export type AttributionReportingAggregationKeysEntry = {
    key: string
    value: UnsignedInt128AsBase16
  }
  export type AttributionReportingEventReportWindows = {
    start: number
    ends: number[]
  }
  export type AttributionReportingTriggerDataMatching = 'exact' | 'modulus'
  export type AttributionReportingAggregatableDebugReportingData = {
    keyPiece: UnsignedInt128AsBase16
    value: number
    types: string[]
  }
  export type AttributionReportingAggregatableDebugReportingConfig = {
    budget?: number
    keyPiece: UnsignedInt128AsBase16
    debugData: AttributionReportingAggregatableDebugReportingData[]
    aggregationCoordinatorOrigin?: string
  }
  export type AttributionScopesData = {
    values: string[]
    limit: number
    maxEventStates: number
  }
  export type AttributionReportingNamedBudgetDef = {
    name: string
    budget: number
  }
  export type AttributionReportingSourceRegistration = {
    time: Network.TimeSinceEpoch
    expiry: number
    triggerData: number[]
    eventReportWindows: AttributionReportingEventReportWindows
    aggregatableReportWindow: number
    type: AttributionReportingSourceType
    sourceOrigin: string
    reportingOrigin: string
    destinationSites: string[]
    eventId: UnsignedInt64AsBase10
    priority: SignedInt64AsBase10
    filterData: AttributionReportingFilterDataEntry[]
    aggregationKeys: AttributionReportingAggregationKeysEntry[]
    debugKey?: UnsignedInt64AsBase10
    triggerDataMatching: AttributionReportingTriggerDataMatching
    destinationLimitPriority: SignedInt64AsBase10
    aggregatableDebugReportingConfig: AttributionReportingAggregatableDebugReportingConfig
    scopesData?: AttributionScopesData
    maxEventLevelReports: number
    namedBudgets: AttributionReportingNamedBudgetDef[]
    debugReporting: boolean
    eventLevelEpsilon: number
  }
  export type AttributionReportingSourceRegistrationResult =
    | 'success'
    | 'internalError'
    | 'insufficientSourceCapacity'
    | 'insufficientUniqueDestinationCapacity'
    | 'excessiveReportingOrigins'
    | 'prohibitedByBrowserPolicy'
    | 'successNoised'
    | 'destinationReportingLimitReached'
    | 'destinationGlobalLimitReached'
    | 'destinationBothLimitsReached'
    | 'reportingOriginsPerSiteLimitReached'
    | 'exceedsMaxChannelCapacity'
    | 'exceedsMaxScopesChannelCapacity'
    | 'exceedsMaxTriggerStateCardinality'
    | 'exceedsMaxEventStatesLimit'
    | 'destinationPerDayReportingLimitReached'
  export type AttributionReportingSourceRegistrationTimeConfig =
    | 'include'
    | 'exclude'
  export type AttributionReportingAggregatableValueDictEntry = {
    key: string
    value: number
    filteringId: UnsignedInt64AsBase10
  }
  export type AttributionReportingAggregatableValueEntry = {
    values: AttributionReportingAggregatableValueDictEntry[]
    filters: AttributionReportingFilterPair
  }
  export type AttributionReportingEventTriggerData = {
    data: UnsignedInt64AsBase10
    priority: SignedInt64AsBase10
    dedupKey?: UnsignedInt64AsBase10
    filters: AttributionReportingFilterPair
  }
  export type AttributionReportingAggregatableTriggerData = {
    keyPiece: UnsignedInt128AsBase16
    sourceKeys: string[]
    filters: AttributionReportingFilterPair
  }
  export type AttributionReportingAggregatableDedupKey = {
    dedupKey?: UnsignedInt64AsBase10
    filters: AttributionReportingFilterPair
  }
  export type AttributionReportingNamedBudgetCandidate = {
    name?: string
    filters: AttributionReportingFilterPair
  }
  export type AttributionReportingTriggerRegistration = {
    filters: AttributionReportingFilterPair
    debugKey?: UnsignedInt64AsBase10
    aggregatableDedupKeys: AttributionReportingAggregatableDedupKey[]
    eventTriggerData: AttributionReportingEventTriggerData[]
    aggregatableTriggerData: AttributionReportingAggregatableTriggerData[]
    aggregatableValues: AttributionReportingAggregatableValueEntry[]
    aggregatableFilteringIdMaxBytes: number
    debugReporting: boolean
    aggregationCoordinatorOrigin?: string
    sourceRegistrationTimeConfig: AttributionReportingSourceRegistrationTimeConfig
    triggerContextId?: string
    aggregatableDebugReportingConfig: AttributionReportingAggregatableDebugReportingConfig
    scopes: string[]
    namedBudgets: AttributionReportingNamedBudgetCandidate[]
  }
  export type AttributionReportingEventLevelResult =
    | 'success'
    | 'successDroppedLowerPriority'
    | 'internalError'
    | 'noCapacityForAttributionDestination'
    | 'noMatchingSources'
    | 'deduplicated'
    | 'excessiveAttributions'
    | 'priorityTooLow'
    | 'neverAttributedSource'
    | 'excessiveReportingOrigins'
    | 'noMatchingSourceFilterData'
    | 'prohibitedByBrowserPolicy'
    | 'noMatchingConfigurations'
    | 'excessiveReports'
    | 'falselyAttributedSource'
    | 'reportWindowPassed'
    | 'notRegistered'
    | 'reportWindowNotStarted'
    | 'noMatchingTriggerData'
  export type AttributionReportingAggregatableResult =
    | 'success'
    | 'internalError'
    | 'noCapacityForAttributionDestination'
    | 'noMatchingSources'
    | 'excessiveAttributions'
    | 'excessiveReportingOrigins'
    | 'noHistograms'
    | 'insufficientBudget'
    | 'insufficientNamedBudget'
    | 'noMatchingSourceFilterData'
    | 'notRegistered'
    | 'prohibitedByBrowserPolicy'
    | 'deduplicated'
    | 'reportWindowPassed'
    | 'excessiveReports'
  export type AttributionReportingReportResult =
    | 'sent'
    | 'prohibited'
    | 'failedToAssemble'
    | 'expired'
  export type RelatedWebsiteSet = {
    primarySites: string[]
    associatedSites: string[]
    serviceSites: string[]
  }
  export interface ClearDataForOriginArgs {
    origin: string
    storageTypes: string
  }
  export interface ClearDataForStorageKeyArgs {
    storageKey: string
    storageTypes: string
  }
  export interface SetCookiesArgs {
    cookies: Network.CookieParam[]
    browserContextId?: Browser.BrowserContextID
  }
  export interface OverrideQuotaForOriginArgs {
    origin: string
    quotaSize?: number
  }
  export interface GetInterestGroupDetailsArgs {
    ownerOrigin: string
    name: string
  }
  export interface SetSharedStorageEntryArgs {
    ownerOrigin: string
    key: string
    value: string
    ignoreIfPresent?: boolean
  }
  export interface DeleteSharedStorageEntryArgs {
    ownerOrigin: string
    key: string
  }
  export interface SetStorageBucketTrackingArgs {
    storageKey: string
    enable: boolean
  }
  export interface GetAffectedUrlsForThirdPartyCookieMetadataArgs {
    firstPartyUrl: string
    thirdPartyUrls: string[]
  }
  export interface SetProtectedAudienceKAnonymityArgs {
    owner: string
    name: string
    hashes: string[]
  }
  export interface GetStorageKeyForFrameResult {
    storageKey: SerializedStorageKey
  }
  export interface GetCookiesResult {
    cookies: Network.Cookie[]
  }
  export interface GetUsageAndQuotaResult {
    usage: number
    quota: number
    overrideActive: boolean
    usageBreakdown: UsageForType[]
  }
  export interface GetTrustTokensResult {
    tokens: TrustTokens[]
  }
  export interface ClearTrustTokensResult {
    didDeleteTokens: boolean
  }
  export interface GetInterestGroupDetailsResult {
    details: Record<string, unknown>
  }
  export interface GetSharedStorageMetadataResult {
    metadata: SharedStorageMetadata
  }
  export interface GetSharedStorageEntriesResult {
    entries: SharedStorageEntry[]
  }
  export interface RunBounceTrackingMitigationsResult {
    deletedSites: string[]
  }
  export interface SendPendingAttributionReportsResult {
    numSent: number
  }
  export interface GetRelatedWebsiteSetsResult {
    sets: RelatedWebsiteSet[]
  }
  export interface GetAffectedUrlsForThirdPartyCookieMetadataResult {
    matchedUrls: string[]
  }
  export interface CacheStorageContentUpdatedEvent {
    origin: string
    storageKey: string
    bucketId: string
    cacheName: string
  }
  export interface CacheStorageListUpdatedEvent {
    origin: string
    storageKey: string
    bucketId: string
  }
  export interface IndexedDBContentUpdatedEvent {
    origin: string
    storageKey: string
    bucketId: string
    databaseName: string
    objectStoreName: string
  }
  export interface IndexedDBListUpdatedEvent {
    origin: string
    storageKey: string
    bucketId: string
  }
  export interface InterestGroupAccessedEvent {
    accessTime: Network.TimeSinceEpoch
    type: InterestGroupAccessType
    ownerOrigin: string
    name: string
    componentSellerOrigin: string
    bid: number
    bidCurrency: string
    uniqueAuctionId: InterestGroupAuctionId
  }
  export interface InterestGroupAuctionEventOccurredEvent {
    eventTime: Network.TimeSinceEpoch
    type: InterestGroupAuctionEventType
    uniqueAuctionId: InterestGroupAuctionId
    parentAuctionId: InterestGroupAuctionId
    auctionConfig: Record<string, unknown>
  }
  export interface InterestGroupAuctionNetworkRequestCreatedEvent {
    type: InterestGroupAuctionFetchType
    requestId: Network.RequestId
    auctions: InterestGroupAuctionId[]
  }
  export interface SharedStorageAccessedEvent {
    accessTime: Network.TimeSinceEpoch
    scope: SharedStorageAccessScope
    method: SharedStorageAccessMethod
    mainFrameId: Page.FrameId
    ownerOrigin: string
    ownerSite: string
    params: SharedStorageAccessParams
  }
  export interface SharedStorageWorkletOperationExecutionFinishedEvent {
    finishedTime: Network.TimeSinceEpoch
    executionTime: number
    method: SharedStorageAccessMethod
    operationId: string
    workletTargetId: Target.TargetID
    mainFrameId: Page.FrameId
    ownerOrigin: string
  }
  export interface StorageBucketCreatedOrUpdatedEvent {
    bucketInfo: StorageBucketInfo
  }
  export interface StorageBucketDeletedEvent {
    bucketId: string
  }
  export interface AttributionReportingSourceRegisteredEvent {
    registration: AttributionReportingSourceRegistration
    result: AttributionReportingSourceRegistrationResult
  }
  export interface AttributionReportingTriggerRegisteredEvent {
    registration: AttributionReportingTriggerRegistration
    eventLevel: AttributionReportingEventLevelResult
    aggregatable: AttributionReportingAggregatableResult
  }
  export interface AttributionReportingReportSentEvent {
    url: string
    body: Record<string, unknown>
    result: AttributionReportingReportResult
    netError: number
    netErrorName: string
    httpStatusCode: number
  }
  export interface EventMap {
    cacheStorageContentUpdated: CacheStorageContentUpdatedEvent
    cacheStorageListUpdated: CacheStorageListUpdatedEvent
    indexedDBContentUpdated: IndexedDBContentUpdatedEvent
    indexedDBListUpdated: IndexedDBListUpdatedEvent
    interestGroupAccessed: InterestGroupAccessedEvent
    interestGroupAuctionEventOccurred: InterestGroupAuctionEventOccurredEvent
    interestGroupAuctionNetworkRequestCreated: InterestGroupAuctionNetworkRequestCreatedEvent
    sharedStorageAccessed: SharedStorageAccessedEvent
    sharedStorageWorkletOperationExecutionFinished: SharedStorageWorkletOperationExecutionFinishedEvent
    storageBucketCreatedOrUpdated: StorageBucketCreatedOrUpdatedEvent
    storageBucketDeleted: StorageBucketDeletedEvent
    attributionReportingSourceRegistered: AttributionReportingSourceRegisteredEvent
    attributionReportingTriggerRegistered: AttributionReportingTriggerRegisteredEvent
    attributionReportingReportSent: AttributionReportingReportSentEvent
  }
}
export namespace SystemInfo {
  export type GPUDevice = {
    vendorId: number
    deviceId: number
    subSysId?: number
    revision?: number
    vendorString: string
    deviceString: string
    driverVendor: string
    driverVersion: string
  }
  export type Size = { width: number; height: number }
  export type VideoDecodeAcceleratorCapability = {
    profile: string
    maxResolution: Size
    minResolution: Size
  }
  export type VideoEncodeAcceleratorCapability = {
    profile: string
    maxResolution: Size
    maxFramerateNumerator: number
    maxFramerateDenominator: number
  }
  export type SubsamplingFormat = 'yuv420' | 'yuv422' | 'yuv444'
  export type ImageType = 'jpeg' | 'webp' | 'unknown'
  export type ImageDecodeAcceleratorCapability = {
    imageType: ImageType
    maxDimensions: Size
    minDimensions: Size
    subsamplings: SubsamplingFormat[]
  }
  export type GPUInfo = {
    devices: GPUDevice[]
    auxAttributes?: Record<string, unknown>
    featureStatus?: Record<string, unknown>
    driverBugWorkarounds: string[]
    videoDecoding: VideoDecodeAcceleratorCapability[]
    videoEncoding: VideoEncodeAcceleratorCapability[]
    imageDecoding: ImageDecodeAcceleratorCapability[]
  }
  export type ProcessInfo = { type: string; id: number; cpuTime: number }
  export interface GetInfoResult {
    gpu: GPUInfo
    modelName: string
    modelVersion: string
    commandLine: string
  }
  export interface GetFeatureStateResult {
    featureEnabled: boolean
  }
  export interface GetProcessInfoResult {
    processInfo: ProcessInfo[]
  }
}
export namespace Target {
  export type TargetID = string
  export type SessionID = string
  export type TargetInfo = {
    targetId: TargetID
    type: string
    title: string
    url: string
    attached: boolean
    openerId?: TargetID
    canAccessOpener: boolean
    openerFrameId?: Page.FrameId
    browserContextId?: Browser.BrowserContextID
    subtype?: string
  }
  export type FilterEntry = { exclude?: boolean; type?: string }
  export type TargetFilter = FilterEntry[]
  export type RemoteLocation = { host: string; port: number }
  export type WindowState = 'normal' | 'minimized' | 'maximized' | 'fullscreen'
  export interface AttachToTargetArgs {
    targetId: TargetID
    flatten?: boolean
  }
  export interface ExposeDevToolsProtocolArgs {
    targetId: TargetID
    bindingName?: string
    inheritPermissions?: boolean
  }
  export interface CreateBrowserContextArgs {
    disposeOnDetach?: boolean
    proxyServer?: string
    proxyBypassList?: string
    originsWithUniversalNetworkAccess?: string[]
  }
  export interface CreateTargetArgs {
    url: string
    left?: number
    top?: number
    width?: number
    height?: number
    windowState?: WindowState
    browserContextId?: Browser.BrowserContextID
    enableBeginFrameControl?: boolean
    newWindow?: boolean
    background?: boolean
    forTab?: boolean
    hidden?: boolean
  }
  export interface DetachFromTargetArgs {
    sessionId?: SessionID
    targetId?: TargetID
  }
  export interface SendMessageToTargetArgs {
    message: string
    sessionId?: SessionID
    targetId?: TargetID
  }
  export interface SetAutoAttachArgs {
    autoAttach: boolean
    waitForDebuggerOnStart: boolean
    flatten?: boolean
    filter?: TargetFilter
  }
  export interface AutoAttachRelatedArgs {
    targetId: TargetID
    waitForDebuggerOnStart: boolean
    filter?: TargetFilter
  }
  export interface SetDiscoverTargetsArgs {
    discover: boolean
    filter?: TargetFilter
  }
  export interface AttachToTargetResult {
    sessionId: SessionID
  }
  export interface AttachToBrowserTargetResult {
    sessionId: SessionID
  }
  export interface CloseTargetResult {
    success: boolean
  }
  export interface CreateBrowserContextResult {
    browserContextId: Browser.BrowserContextID
  }
  export interface GetBrowserContextsResult {
    browserContextIds: Browser.BrowserContextID[]
  }
  export interface CreateTargetResult {
    targetId: TargetID
  }
  export interface GetTargetInfoResult {
    targetInfo: TargetInfo
  }
  export interface GetTargetsResult {
    targetInfos: TargetInfo[]
  }
  export interface AttachedToTargetEvent {
    sessionId: SessionID
    targetInfo: TargetInfo
    waitingForDebugger: boolean
  }
  export interface DetachedFromTargetEvent {
    sessionId: SessionID
    targetId: TargetID
  }
  export interface ReceivedMessageFromTargetEvent {
    sessionId: SessionID
    message: string
    targetId: TargetID
  }
  export interface TargetCreatedEvent {
    targetInfo: TargetInfo
  }
  export interface TargetDestroyedEvent {
    targetId: TargetID
  }
  export interface TargetCrashedEvent {
    targetId: TargetID
    status: string
    errorCode: number
  }
  export interface TargetInfoChangedEvent {
    targetInfo: TargetInfo
  }
  export interface EventMap {
    attachedToTarget: AttachedToTargetEvent
    detachedFromTarget: DetachedFromTargetEvent
    receivedMessageFromTarget: ReceivedMessageFromTargetEvent
    targetCreated: TargetCreatedEvent
    targetDestroyed: TargetDestroyedEvent
    targetCrashed: TargetCrashedEvent
    targetInfoChanged: TargetInfoChangedEvent
  }
}
export namespace Tethering {
  export interface AcceptedEvent {
    port: number
    connectionId: string
  }
  export interface EventMap {
    accepted: AcceptedEvent
  }
}
export namespace Tracing {
  export type MemoryDumpConfig = Record<string, unknown>
  export type TraceConfig = {
    recordMode?:
      | 'recordUntilFull'
      | 'recordContinuously'
      | 'recordAsMuchAsPossible'
      | 'echoToConsole'
    traceBufferSizeInKb?: number
    enableSampling?: boolean
    enableSystrace?: boolean
    enableArgumentFilter?: boolean
    includedCategories?: string[]
    excludedCategories?: string[]
    syntheticDelays?: string[]
    memoryDumpConfig?: MemoryDumpConfig
  }
  export type StreamFormat = 'json' | 'proto'
  export type StreamCompression = 'none' | 'gzip'
  export type MemoryDumpLevelOfDetail = 'background' | 'light' | 'detailed'
  export type TracingBackend = 'auto' | 'chrome' | 'system'
  export interface RequestMemoryDumpArgs {
    deterministic?: boolean
    levelOfDetail?: MemoryDumpLevelOfDetail
  }
  export interface StartArgs {
    categories?: string
    options?: string
    bufferUsageReportingInterval?: number
    transferMode?: 'ReportEvents' | 'ReturnAsStream'
    streamFormat?: StreamFormat
    streamCompression?: StreamCompression
    traceConfig?: TraceConfig
    perfettoConfig?: string
    tracingBackend?: TracingBackend
  }
  export interface GetCategoriesResult {
    categories: string[]
  }
  export interface RequestMemoryDumpResult {
    dumpGuid: string
    success: boolean
  }
  export interface BufferUsageEvent {
    percentFull: number
    eventCount: number
    value: number
  }
  export interface DataCollectedEvent {
    value: Record<string, unknown>[]
  }
  export interface TracingCompleteEvent {
    dataLossOccurred: boolean
    stream: IO.StreamHandle
    traceFormat: StreamFormat
    streamCompression: StreamCompression
  }
  export interface EventMap {
    bufferUsage: BufferUsageEvent
    dataCollected: DataCollectedEvent
    tracingComplete: TracingCompleteEvent
  }
}
export namespace Fetch {
  export type RequestId = string
  export type RequestStage = 'Request' | 'Response'
  export type RequestPattern = {
    urlPattern?: string
    resourceType?: Network.ResourceType
    requestStage?: RequestStage
  }
  export type HeaderEntry = { name: string; value: string }
  export type AuthChallenge = {
    source?: 'Server' | 'Proxy'
    origin: string
    scheme: string
    realm: string
  }
  export type AuthChallengeResponse = {
    response: 'Default' | 'CancelAuth' | 'ProvideCredentials'
    username?: string
    password?: string
  }
  export interface EnableArgs {
    patterns?: RequestPattern[]
    handleAuthRequests?: boolean
  }
  export interface FailRequestArgs {
    requestId: RequestId
    errorReason: Network.ErrorReason
  }
  export interface FulfillRequestArgs {
    requestId: RequestId
    responseCode: number
    responseHeaders?: HeaderEntry[]
    binaryResponseHeaders?: string
    body?: string
    responsePhrase?: string
  }
  export interface ContinueRequestArgs {
    requestId: RequestId
    url?: string
    method?: string
    postData?: string
    headers?: HeaderEntry[]
    interceptResponse?: boolean
  }
  export interface ContinueWithAuthArgs {
    requestId: RequestId
    authChallengeResponse: AuthChallengeResponse
  }
  export interface ContinueResponseArgs {
    requestId: RequestId
    responseCode?: number
    responsePhrase?: string
    responseHeaders?: HeaderEntry[]
    binaryResponseHeaders?: string
  }
  export interface GetResponseBodyResult {
    body: string
    base64Encoded: boolean
  }
  export interface TakeResponseBodyAsStreamResult {
    stream: IO.StreamHandle
  }
  export interface RequestPausedEvent {
    requestId: RequestId
    request: Network.Request
    frameId: Page.FrameId
    resourceType: Network.ResourceType
    responseErrorReason: Network.ErrorReason
    responseStatusCode: number
    responseStatusText: string
    responseHeaders: HeaderEntry[]
    networkId: Network.RequestId
    redirectedRequestId: RequestId
  }
  export interface AuthRequiredEvent {
    requestId: RequestId
    request: Network.Request
    frameId: Page.FrameId
    resourceType: Network.ResourceType
    authChallenge: AuthChallenge
  }
  export interface EventMap {
    requestPaused: RequestPausedEvent
    authRequired: AuthRequiredEvent
  }
}
export namespace WebAudio {
  export type GraphObjectId = string
  export type ContextType = 'realtime' | 'offline'
  export type ContextState = 'suspended' | 'running' | 'closed' | 'interrupted'
  export type NodeType = string
  export type ChannelCountMode = 'clamped-max' | 'explicit' | 'max'
  export type ChannelInterpretation = 'discrete' | 'speakers'
  export type ParamType = string
  export type AutomationRate = 'a-rate' | 'k-rate'
  export type ContextRealtimeData = {
    currentTime: number
    renderCapacity: number
    callbackIntervalMean: number
    callbackIntervalVariance: number
  }
  export type BaseAudioContext = {
    contextId: GraphObjectId
    contextType: ContextType
    contextState: ContextState
    realtimeData?: ContextRealtimeData
    callbackBufferSize: number
    maxOutputChannelCount: number
    sampleRate: number
  }
  export type AudioListener = {
    listenerId: GraphObjectId
    contextId: GraphObjectId
  }
  export type AudioNode = {
    nodeId: GraphObjectId
    contextId: GraphObjectId
    nodeType: NodeType
    numberOfInputs: number
    numberOfOutputs: number
    channelCount: number
    channelCountMode: ChannelCountMode
    channelInterpretation: ChannelInterpretation
  }
  export type AudioParam = {
    paramId: GraphObjectId
    nodeId: GraphObjectId
    contextId: GraphObjectId
    paramType: ParamType
    rate: AutomationRate
    defaultValue: number
    minValue: number
    maxValue: number
  }
  export interface GetRealtimeDataResult {
    realtimeData: ContextRealtimeData
  }
  export interface ContextCreatedEvent {
    context: BaseAudioContext
  }
  export interface ContextWillBeDestroyedEvent {
    contextId: GraphObjectId
  }
  export interface ContextChangedEvent {
    context: BaseAudioContext
  }
  export interface AudioListenerCreatedEvent {
    listener: AudioListener
  }
  export interface AudioListenerWillBeDestroyedEvent {
    contextId: GraphObjectId
    listenerId: GraphObjectId
  }
  export interface AudioNodeCreatedEvent {
    node: AudioNode
  }
  export interface AudioNodeWillBeDestroyedEvent {
    contextId: GraphObjectId
    nodeId: GraphObjectId
  }
  export interface AudioParamCreatedEvent {
    param: AudioParam
  }
  export interface AudioParamWillBeDestroyedEvent {
    contextId: GraphObjectId
    nodeId: GraphObjectId
    paramId: GraphObjectId
  }
  export interface NodesConnectedEvent {
    contextId: GraphObjectId
    sourceId: GraphObjectId
    destinationId: GraphObjectId
    sourceOutputIndex: number
    destinationInputIndex: number
  }
  export interface NodesDisconnectedEvent {
    contextId: GraphObjectId
    sourceId: GraphObjectId
    destinationId: GraphObjectId
    sourceOutputIndex: number
    destinationInputIndex: number
  }
  export interface NodeParamConnectedEvent {
    contextId: GraphObjectId
    sourceId: GraphObjectId
    destinationId: GraphObjectId
    sourceOutputIndex: number
  }
  export interface NodeParamDisconnectedEvent {
    contextId: GraphObjectId
    sourceId: GraphObjectId
    destinationId: GraphObjectId
    sourceOutputIndex: number
  }
  export interface EventMap {
    contextCreated: ContextCreatedEvent
    contextWillBeDestroyed: ContextWillBeDestroyedEvent
    contextChanged: ContextChangedEvent
    audioListenerCreated: AudioListenerCreatedEvent
    audioListenerWillBeDestroyed: AudioListenerWillBeDestroyedEvent
    audioNodeCreated: AudioNodeCreatedEvent
    audioNodeWillBeDestroyed: AudioNodeWillBeDestroyedEvent
    audioParamCreated: AudioParamCreatedEvent
    audioParamWillBeDestroyed: AudioParamWillBeDestroyedEvent
    nodesConnected: NodesConnectedEvent
    nodesDisconnected: NodesDisconnectedEvent
    nodeParamConnected: NodeParamConnectedEvent
    nodeParamDisconnected: NodeParamDisconnectedEvent
  }
}
export namespace WebAuthn {
  export type AuthenticatorId = string
  export type AuthenticatorProtocol = 'u2f' | 'ctap2'
  export type Ctap2Version = 'ctap2_0' | 'ctap2_1'
  export type AuthenticatorTransport =
    | 'usb'
    | 'nfc'
    | 'ble'
    | 'cable'
    | 'internal'
  export type VirtualAuthenticatorOptions = {
    protocol: AuthenticatorProtocol
    ctap2Version?: Ctap2Version
    transport: AuthenticatorTransport
    hasResidentKey?: boolean
    hasUserVerification?: boolean
    hasLargeBlob?: boolean
    hasCredBlob?: boolean
    hasMinPinLength?: boolean
    hasPrf?: boolean
    automaticPresenceSimulation?: boolean
    isUserVerified?: boolean
    defaultBackupEligibility?: boolean
    defaultBackupState?: boolean
  }
  export type Credential = {
    credentialId: string
    isResidentCredential: boolean
    rpId?: string
    privateKey: string
    userHandle?: string
    signCount: number
    largeBlob?: string
    backupEligibility?: boolean
    backupState?: boolean
    userName?: string
    userDisplayName?: string
  }
  export interface SetResponseOverrideBitsArgs {
    authenticatorId: AuthenticatorId
    isBogusSignature?: boolean
    isBadUV?: boolean
    isBadUP?: boolean
  }
  export interface AddCredentialArgs {
    authenticatorId: AuthenticatorId
    credential: Credential
  }
  export interface GetCredentialArgs {
    authenticatorId: AuthenticatorId
    credentialId: string
  }
  export interface RemoveCredentialArgs {
    authenticatorId: AuthenticatorId
    credentialId: string
  }
  export interface SetUserVerifiedArgs {
    authenticatorId: AuthenticatorId
    isUserVerified: boolean
  }
  export interface SetAutomaticPresenceSimulationArgs {
    authenticatorId: AuthenticatorId
    enabled: boolean
  }
  export interface SetCredentialPropertiesArgs {
    authenticatorId: AuthenticatorId
    credentialId: string
    backupEligibility?: boolean
    backupState?: boolean
  }
  export interface AddVirtualAuthenticatorResult {
    authenticatorId: AuthenticatorId
  }
  export interface GetCredentialResult {
    credential: Credential
  }
  export interface GetCredentialsResult {
    credentials: Credential[]
  }
  export interface CredentialAddedEvent {
    authenticatorId: AuthenticatorId
    credential: Credential
  }
  export interface CredentialDeletedEvent {
    authenticatorId: AuthenticatorId
    credentialId: string
  }
  export interface CredentialUpdatedEvent {
    authenticatorId: AuthenticatorId
    credential: Credential
  }
  export interface CredentialAssertedEvent {
    authenticatorId: AuthenticatorId
    credential: Credential
  }
  export interface EventMap {
    credentialAdded: CredentialAddedEvent
    credentialDeleted: CredentialDeletedEvent
    credentialUpdated: CredentialUpdatedEvent
    credentialAsserted: CredentialAssertedEvent
  }
}
export namespace Media {
  export type PlayerId = string
  export type Timestamp = number
  export type PlayerMessage = {
    level: 'error' | 'warning' | 'info' | 'debug'
    message: string
  }
  export type PlayerProperty = { name: string; value: string }
  export type PlayerEvent = { timestamp: Timestamp; value: string }
  export type PlayerErrorSourceLocation = { file: string; line: number }
  export type PlayerError = {
    errorType: string
    code: number
    stack: PlayerErrorSourceLocation[]
    cause: PlayerError[]
    data: Record<string, unknown>
  }
  export interface PlayerPropertiesChangedEvent {
    playerId: PlayerId
    properties: PlayerProperty[]
  }
  export interface PlayerEventsAddedEvent {
    playerId: PlayerId
    events: PlayerEvent[]
  }
  export interface PlayerMessagesLoggedEvent {
    playerId: PlayerId
    messages: PlayerMessage[]
  }
  export interface PlayerErrorsRaisedEvent {
    playerId: PlayerId
    errors: PlayerError[]
  }
  export interface PlayersCreatedEvent {
    players: PlayerId[]
  }
  export interface EventMap {
    playerPropertiesChanged: PlayerPropertiesChangedEvent
    playerEventsAdded: PlayerEventsAddedEvent
    playerMessagesLogged: PlayerMessagesLoggedEvent
    playerErrorsRaised: PlayerErrorsRaisedEvent
    playersCreated: PlayersCreatedEvent
  }
}
export namespace DeviceAccess {
  export type RequestId = string
  export type DeviceId = string
  export type PromptDevice = { id: DeviceId; name: string }
  export interface SelectPromptArgs {
    id: RequestId
    deviceId: DeviceId
  }
  export interface DeviceRequestPromptedEvent {
    id: RequestId
    devices: PromptDevice[]
  }
  export interface EventMap {
    deviceRequestPrompted: DeviceRequestPromptedEvent
  }
}
export namespace Preload {
  export type RuleSetId = string
  export type RuleSet = {
    id: RuleSetId
    loaderId: Network.LoaderId
    sourceText: string
    backendNodeId?: DOM.BackendNodeId
    url?: string
    requestId?: Network.RequestId
    errorType?: RuleSetErrorType
    errorMessage?: string
  }
  export type RuleSetErrorType = 'SourceIsNotJsonObject' | 'InvalidRulesSkipped'
  export type SpeculationAction = 'Prefetch' | 'Prerender'
  export type SpeculationTargetHint = 'Blank' | 'Self'
  export type PreloadingAttemptKey = {
    loaderId: Network.LoaderId
    action: SpeculationAction
    url: string
    targetHint?: SpeculationTargetHint
  }
  export type PreloadingAttemptSource = {
    key: PreloadingAttemptKey
    ruleSetIds: RuleSetId[]
    nodeIds: DOM.BackendNodeId[]
  }
  export type PreloadPipelineId = string
  export type PrerenderFinalStatus =
    | 'Activated'
    | 'Destroyed'
    | 'LowEndDevice'
    | 'InvalidSchemeRedirect'
    | 'InvalidSchemeNavigation'
    | 'NavigationRequestBlockedByCsp'
    | 'MojoBinderPolicy'
    | 'RendererProcessCrashed'
    | 'RendererProcessKilled'
    | 'Download'
    | 'TriggerDestroyed'
    | 'NavigationNotCommitted'
    | 'NavigationBadHttpStatus'
    | 'ClientCertRequested'
    | 'NavigationRequestNetworkError'
    | 'CancelAllHostsForTesting'
    | 'DidFailLoad'
    | 'Stop'
    | 'SslCertificateError'
    | 'LoginAuthRequested'
    | 'UaChangeRequiresReload'
    | 'BlockedByClient'
    | 'AudioOutputDeviceRequested'
    | 'MixedContent'
    | 'TriggerBackgrounded'
    | 'MemoryLimitExceeded'
    | 'DataSaverEnabled'
    | 'TriggerUrlHasEffectiveUrl'
    | 'ActivatedBeforeStarted'
    | 'InactivePageRestriction'
    | 'StartFailed'
    | 'TimeoutBackgrounded'
    | 'CrossSiteRedirectInInitialNavigation'
    | 'CrossSiteNavigationInInitialNavigation'
    | 'SameSiteCrossOriginRedirectNotOptInInInitialNavigation'
    | 'SameSiteCrossOriginNavigationNotOptInInInitialNavigation'
    | 'ActivationNavigationParameterMismatch'
    | 'ActivatedInBackground'
    | 'EmbedderHostDisallowed'
    | 'ActivationNavigationDestroyedBeforeSuccess'
    | 'TabClosedByUserGesture'
    | 'TabClosedWithoutUserGesture'
    | 'PrimaryMainFrameRendererProcessCrashed'
    | 'PrimaryMainFrameRendererProcessKilled'
    | 'ActivationFramePolicyNotCompatible'
    | 'PreloadingDisabled'
    | 'BatterySaverEnabled'
    | 'ActivatedDuringMainFrameNavigation'
    | 'PreloadingUnsupportedByWebContents'
    | 'CrossSiteRedirectInMainFrameNavigation'
    | 'CrossSiteNavigationInMainFrameNavigation'
    | 'SameSiteCrossOriginRedirectNotOptInInMainFrameNavigation'
    | 'SameSiteCrossOriginNavigationNotOptInInMainFrameNavigation'
    | 'MemoryPressureOnTrigger'
    | 'MemoryPressureAfterTriggered'
    | 'PrerenderingDisabledByDevTools'
    | 'SpeculationRuleRemoved'
    | 'ActivatedWithAuxiliaryBrowsingContexts'
    | 'MaxNumOfRunningEagerPrerendersExceeded'
    | 'MaxNumOfRunningNonEagerPrerendersExceeded'
    | 'MaxNumOfRunningEmbedderPrerendersExceeded'
    | 'PrerenderingUrlHasEffectiveUrl'
    | 'RedirectedPrerenderingUrlHasEffectiveUrl'
    | 'ActivationUrlHasEffectiveUrl'
    | 'JavaScriptInterfaceAdded'
    | 'JavaScriptInterfaceRemoved'
    | 'AllPrerenderingCanceled'
    | 'WindowClosed'
    | 'SlowNetwork'
    | 'OtherPrerenderedPageActivated'
    | 'V8OptimizerDisabled'
    | 'PrerenderFailedDuringPrefetch'
    | 'BrowsingDataRemoved'
  export type PreloadingStatus =
    | 'Pending'
    | 'Running'
    | 'Ready'
    | 'Success'
    | 'Failure'
    | 'NotSupported'
  export type PrefetchStatus =
    | 'PrefetchAllowed'
    | 'PrefetchFailedIneligibleRedirect'
    | 'PrefetchFailedInvalidRedirect'
    | 'PrefetchFailedMIMENotSupported'
    | 'PrefetchFailedNetError'
    | 'PrefetchFailedNon2XX'
    | 'PrefetchEvictedAfterBrowsingDataRemoved'
    | 'PrefetchEvictedAfterCandidateRemoved'
    | 'PrefetchEvictedForNewerPrefetch'
    | 'PrefetchHeldback'
    | 'PrefetchIneligibleRetryAfter'
    | 'PrefetchIsPrivacyDecoy'
    | 'PrefetchIsStale'
    | 'PrefetchNotEligibleBrowserContextOffTheRecord'
    | 'PrefetchNotEligibleDataSaverEnabled'
    | 'PrefetchNotEligibleExistingProxy'
    | 'PrefetchNotEligibleHostIsNonUnique'
    | 'PrefetchNotEligibleNonDefaultStoragePartition'
    | 'PrefetchNotEligibleSameSiteCrossOriginPrefetchRequiredProxy'
    | 'PrefetchNotEligibleSchemeIsNotHttps'
    | 'PrefetchNotEligibleUserHasCookies'
    | 'PrefetchNotEligibleUserHasServiceWorker'
    | 'PrefetchNotEligibleUserHasServiceWorkerNoFetchHandler'
    | 'PrefetchNotEligibleRedirectFromServiceWorker'
    | 'PrefetchNotEligibleRedirectToServiceWorker'
    | 'PrefetchNotEligibleBatterySaverEnabled'
    | 'PrefetchNotEligiblePreloadingDisabled'
    | 'PrefetchNotFinishedInTime'
    | 'PrefetchNotStarted'
    | 'PrefetchNotUsedCookiesChanged'
    | 'PrefetchProxyNotAvailable'
    | 'PrefetchResponseUsed'
    | 'PrefetchSuccessfulButNotUsed'
    | 'PrefetchNotUsedProbeFailed'
  export type PrerenderMismatchedHeaders = {
    headerName: string
    initialValue?: string
    activationValue?: string
  }
  export interface RuleSetUpdatedEvent {
    ruleSet: RuleSet
  }
  export interface RuleSetRemovedEvent {
    id: RuleSetId
  }
  export interface PreloadEnabledStateUpdatedEvent {
    disabledByPreference: boolean
    disabledByDataSaver: boolean
    disabledByBatterySaver: boolean
    disabledByHoldbackPrefetchSpeculationRules: boolean
    disabledByHoldbackPrerenderSpeculationRules: boolean
  }
  export interface PrefetchStatusUpdatedEvent {
    key: PreloadingAttemptKey
    pipelineId: PreloadPipelineId
    initiatingFrameId: Page.FrameId
    prefetchUrl: string
    status: PreloadingStatus
    prefetchStatus: PrefetchStatus
    requestId: Network.RequestId
  }
  export interface PrerenderStatusUpdatedEvent {
    key: PreloadingAttemptKey
    pipelineId: PreloadPipelineId
    status: PreloadingStatus
    prerenderStatus: PrerenderFinalStatus
    disallowedMojoInterface: string
    mismatchedHeaders: PrerenderMismatchedHeaders[]
  }
  export interface PreloadingAttemptSourcesUpdatedEvent {
    loaderId: Network.LoaderId
    preloadingAttemptSources: PreloadingAttemptSource[]
  }
  export interface EventMap {
    ruleSetUpdated: RuleSetUpdatedEvent
    ruleSetRemoved: RuleSetRemovedEvent
    preloadEnabledStateUpdated: PreloadEnabledStateUpdatedEvent
    prefetchStatusUpdated: PrefetchStatusUpdatedEvent
    prerenderStatusUpdated: PrerenderStatusUpdatedEvent
    preloadingAttemptSourcesUpdated: PreloadingAttemptSourcesUpdatedEvent
  }
}
export namespace FedCm {
  export type LoginState = 'SignIn' | 'SignUp'
  export type DialogType =
    | 'AccountChooser'
    | 'AutoReauthn'
    | 'ConfirmIdpLogin'
    | 'Error'
  export type DialogButton =
    | 'ConfirmIdpLoginContinue'
    | 'ErrorGotIt'
    | 'ErrorMoreDetails'
  export type AccountUrlType = 'TermsOfService' | 'PrivacyPolicy'
  export type Account = {
    accountId: string
    email: string
    name: string
    givenName: string
    pictureUrl: string
    idpConfigUrl: string
    idpLoginUrl: string
    loginState: LoginState
    termsOfServiceUrl?: string
    privacyPolicyUrl?: string
  }
  export interface SelectAccountArgs {
    dialogId: string
    accountIndex: number
  }
  export interface ClickDialogButtonArgs {
    dialogId: string
    dialogButton: DialogButton
  }
  export interface OpenUrlArgs {
    dialogId: string
    accountIndex: number
    accountUrlType: AccountUrlType
  }
  export interface DismissDialogArgs {
    dialogId: string
    triggerCooldown?: boolean
  }
  export interface DialogShownEvent {
    dialogId: string
    dialogType: DialogType
    accounts: Account[]
    title: string
    subtitle: string
  }
  export interface DialogClosedEvent {
    dialogId: string
  }
  export interface EventMap {
    dialogShown: DialogShownEvent
    dialogClosed: DialogClosedEvent
  }
}
export namespace PWA {
  export type FileHandlerAccept = {
    mediaType: string
    fileExtensions: string[]
  }
  export type FileHandler = {
    action: string
    accepts: FileHandlerAccept[]
    displayName: string
  }
  export type DisplayMode = 'standalone' | 'browser'
  export interface InstallArgs {
    manifestId: string
    installUrlOrBundleUrl?: string
  }
  export interface LaunchArgs {
    manifestId: string
    url?: string
  }
  export interface LaunchFilesInAppArgs {
    manifestId: string
    files: string[]
  }
  export interface ChangeAppUserSettingsArgs {
    manifestId: string
    linkCapturing?: boolean
    displayMode?: DisplayMode
  }
  export interface GetOsAppStateResult {
    badgeCount: number
    fileHandlers: FileHandler[]
  }
  export interface LaunchResult {
    targetId: Target.TargetID
  }
  export interface LaunchFilesInAppResult {
    targetIds: Target.TargetID[]
  }
}
export namespace BluetoothEmulation {
  export type CentralState = 'absent' | 'powered-off' | 'powered-on'
  export type GATTOperationType = 'connection' | 'discovery'
  export type CharacteristicWriteType =
    | 'write-default-deprecated'
    | 'write-with-response'
    | 'write-without-response'
  export type CharacteristicOperationType =
    | 'read'
    | 'write'
    | 'subscribe-to-notifications'
    | 'unsubscribe-from-notifications'
  export type DescriptorOperationType = 'read' | 'write'
  export type ManufacturerData = { key: number; data: string }
  export type ScanRecord = {
    name?: string
    uuids?: string[]
    appearance?: number
    txPower?: number
    manufacturerData?: ManufacturerData[]
  }
  export type ScanEntry = {
    deviceAddress: string
    rssi: number
    scanRecord: ScanRecord
  }
  export type CharacteristicProperties = {
    broadcast?: boolean
    read?: boolean
    writeWithoutResponse?: boolean
    write?: boolean
    notify?: boolean
    indicate?: boolean
    authenticatedSignedWrites?: boolean
    extendedProperties?: boolean
  }
  export interface EnableArgs {
    state: CentralState
    leSupported: boolean
  }
  export interface SimulatePreconnectedPeripheralArgs {
    address: string
    name: string
    manufacturerData: ManufacturerData[]
    knownServiceUuids: string[]
  }
  export interface SimulateGATTOperationResponseArgs {
    address: string
    type: GATTOperationType
    code: number
  }
  export interface SimulateCharacteristicOperationResponseArgs {
    characteristicId: string
    type: CharacteristicOperationType
    code: number
    data?: string
  }
  export interface SimulateDescriptorOperationResponseArgs {
    descriptorId: string
    type: DescriptorOperationType
    code: number
    data?: string
  }
  export interface AddServiceArgs {
    address: string
    serviceUuid: string
  }
  export interface AddCharacteristicArgs {
    serviceId: string
    characteristicUuid: string
    properties: CharacteristicProperties
  }
  export interface AddDescriptorArgs {
    characteristicId: string
    descriptorUuid: string
  }
  export interface AddServiceResult {
    serviceId: string
  }
  export interface AddCharacteristicResult {
    characteristicId: string
  }
  export interface AddDescriptorResult {
    descriptorId: string
  }
  export interface GattOperationReceivedEvent {
    address: string
    type: GATTOperationType
  }
  export interface CharacteristicOperationReceivedEvent {
    characteristicId: string
    type: CharacteristicOperationType
    data: string
    writeType: CharacteristicWriteType
  }
  export interface DescriptorOperationReceivedEvent {
    descriptorId: string
    type: DescriptorOperationType
    data: string
  }
  export interface EventMap {
    gattOperationReceived: GattOperationReceivedEvent
    characteristicOperationReceived: CharacteristicOperationReceivedEvent
    descriptorOperationReceived: DescriptorOperationReceivedEvent
  }
}
export namespace Console {
  export type ConsoleMessage = {
    source:
      | 'xml'
      | 'javascript'
      | 'network'
      | 'console-api'
      | 'storage'
      | 'appcache'
      | 'rendering'
      | 'security'
      | 'other'
      | 'deprecation'
      | 'worker'
    level: 'log' | 'warning' | 'error' | 'debug' | 'info'
    text: string
    url?: string
    line?: number
    column?: number
  }
  export interface MessageAddedEvent {
    message: ConsoleMessage
  }
  export interface EventMap {
    messageAdded: MessageAddedEvent
  }
}
export namespace Debugger {
  export type BreakpointId = string
  export type CallFrameId = string
  export type Location = {
    scriptId: Runtime.ScriptId
    lineNumber: number
    columnNumber?: number
  }
  export type ScriptPosition = { lineNumber: number; columnNumber: number }
  export type LocationRange = {
    scriptId: Runtime.ScriptId
    start: ScriptPosition
    end: ScriptPosition
  }
  export type CallFrame = {
    callFrameId: CallFrameId
    functionName: string
    functionLocation?: Location
    location: Location
    url: string
    scopeChain: Scope[]
    this: Runtime.RemoteObject
    returnValue?: Runtime.RemoteObject
    canBeRestarted?: boolean
  }
  export type Scope = {
    type:
      | 'global'
      | 'local'
      | 'with'
      | 'closure'
      | 'catch'
      | 'block'
      | 'script'
      | 'eval'
      | 'module'
      | 'wasm-expression-stack'
    object: Runtime.RemoteObject
    name?: string
    startLocation?: Location
    endLocation?: Location
  }
  export type SearchMatch = { lineNumber: number; lineContent: string }
  export type BreakLocation = {
    scriptId: Runtime.ScriptId
    lineNumber: number
    columnNumber?: number
    type?: 'debuggerStatement' | 'call' | 'return'
  }
  export type WasmDisassemblyChunk = {
    lines: string[]
    bytecodeOffsets: number[]
  }
  export type ScriptLanguage = 'JavaScript' | 'WebAssembly'
  export type DebugSymbols = {
    type: 'SourceMap' | 'EmbeddedDWARF' | 'ExternalDWARF'
    externalURL?: string
  }
  export type ResolvedBreakpoint = {
    breakpointId: BreakpointId
    location: Location
  }
  export interface ContinueToLocationArgs {
    location: Location
    targetCallFrames?: 'any' | 'current'
  }
  export interface EvaluateOnCallFrameArgs {
    callFrameId: CallFrameId
    expression: string
    objectGroup?: string
    includeCommandLineAPI?: boolean
    silent?: boolean
    returnByValue?: boolean
    generatePreview?: boolean
    throwOnSideEffect?: boolean
    timeout?: Runtime.TimeDelta
  }
  export interface GetPossibleBreakpointsArgs {
    start: Location
    end?: Location
    restrictToFunction?: boolean
  }
  export interface RestartFrameArgs {
    callFrameId: CallFrameId
    mode?: 'StepInto'
  }
  export interface SearchInContentArgs {
    scriptId: Runtime.ScriptId
    query: string
    caseSensitive?: boolean
    isRegex?: boolean
  }
  export interface SetBlackboxPatternsArgs {
    patterns: string[]
    skipAnonymous?: boolean
  }
  export interface SetBlackboxedRangesArgs {
    scriptId: Runtime.ScriptId
    positions: ScriptPosition[]
  }
  export interface SetBreakpointArgs {
    location: Location
    condition?: string
  }
  export interface SetBreakpointByUrlArgs {
    lineNumber: number
    url?: string
    urlRegex?: string
    scriptHash?: string
    columnNumber?: number
    condition?: string
  }
  export interface SetBreakpointOnFunctionCallArgs {
    objectId: Runtime.RemoteObjectId
    condition?: string
  }
  export interface SetScriptSourceArgs {
    scriptId: Runtime.ScriptId
    scriptSource: string
    dryRun?: boolean
    allowTopFrameEditing?: boolean
  }
  export interface SetVariableValueArgs {
    scopeNumber: number
    variableName: string
    newValue: Runtime.CallArgument
    callFrameId: CallFrameId
  }
  export interface StepIntoArgs {
    breakOnAsyncCall?: boolean
    skipList?: LocationRange[]
  }
  export interface EnableResult {
    debuggerId: Runtime.UniqueDebuggerId
  }
  export interface EvaluateOnCallFrameResult {
    result: Runtime.RemoteObject
    exceptionDetails: Runtime.ExceptionDetails
  }
  export interface GetPossibleBreakpointsResult {
    locations: BreakLocation[]
  }
  export interface GetScriptSourceResult {
    scriptSource: string
    bytecode: string
  }
  export interface DisassembleWasmModuleResult {
    streamId: string
    totalNumberOfLines: number
    functionBodyOffsets: number[]
    chunk: WasmDisassemblyChunk
  }
  export interface NextWasmDisassemblyChunkResult {
    chunk: WasmDisassemblyChunk
  }
  export interface GetWasmBytecodeResult {
    bytecode: string
  }
  export interface GetStackTraceResult {
    stackTrace: Runtime.StackTrace
  }
  export interface RestartFrameResult {
    callFrames: CallFrame[]
    asyncStackTrace: Runtime.StackTrace
    asyncStackTraceId: Runtime.StackTraceId
  }
  export interface SearchInContentResult {
    result: SearchMatch[]
  }
  export interface SetBreakpointResult {
    breakpointId: BreakpointId
    actualLocation: Location
  }
  export interface SetInstrumentationBreakpointResult {
    breakpointId: BreakpointId
  }
  export interface SetBreakpointByUrlResult {
    breakpointId: BreakpointId
    locations: Location[]
  }
  export interface SetBreakpointOnFunctionCallResult {
    breakpointId: BreakpointId
  }
  export interface SetScriptSourceResult {
    callFrames: CallFrame[]
    stackChanged: boolean
    asyncStackTrace: Runtime.StackTrace
    asyncStackTraceId: Runtime.StackTraceId
    status:
      | 'Ok'
      | 'CompileError'
      | 'BlockedByActiveGenerator'
      | 'BlockedByActiveFunction'
      | 'BlockedByTopLevelEsModuleChange'
    exceptionDetails: Runtime.ExceptionDetails
  }
  export interface BreakpointResolvedEvent {
    breakpointId: BreakpointId
    location: Location
  }
  export interface PausedEvent {
    callFrames: CallFrame[]
    reason:
      | 'ambiguous'
      | 'assert'
      | 'CSPViolation'
      | 'debugCommand'
      | 'DOM'
      | 'EventListener'
      | 'exception'
      | 'instrumentation'
      | 'OOM'
      | 'other'
      | 'promiseRejection'
      | 'XHR'
      | 'step'
    data: Record<string, unknown>
    hitBreakpoints: string[]
    asyncStackTrace: Runtime.StackTrace
    asyncStackTraceId: Runtime.StackTraceId
    asyncCallStackTraceId: Runtime.StackTraceId
  }
  export interface ResumedEvent {}
  export interface ScriptFailedToParseEvent {
    scriptId: Runtime.ScriptId
    url: string
    startLine: number
    startColumn: number
    endLine: number
    endColumn: number
    executionContextId: Runtime.ExecutionContextId
    hash: string
    buildId: string
    executionContextAuxData: Record<string, unknown>
    sourceMapURL: string
    hasSourceURL: boolean
    isModule: boolean
    length: number
    stackTrace: Runtime.StackTrace
    codeOffset: number
    scriptLanguage: Debugger.ScriptLanguage
    embedderName: string
  }
  export interface ScriptParsedEvent {
    scriptId: Runtime.ScriptId
    url: string
    startLine: number
    startColumn: number
    endLine: number
    endColumn: number
    executionContextId: Runtime.ExecutionContextId
    hash: string
    buildId: string
    executionContextAuxData: Record<string, unknown>
    isLiveEdit: boolean
    sourceMapURL: string
    hasSourceURL: boolean
    isModule: boolean
    length: number
    stackTrace: Runtime.StackTrace
    codeOffset: number
    scriptLanguage: Debugger.ScriptLanguage
    debugSymbols: Debugger.DebugSymbols[]
    embedderName: string
    resolvedBreakpoints: ResolvedBreakpoint[]
  }
  export interface EventMap {
    breakpointResolved: BreakpointResolvedEvent
    paused: PausedEvent
    resumed: ResumedEvent
    scriptFailedToParse: ScriptFailedToParseEvent
    scriptParsed: ScriptParsedEvent
  }
}
export namespace HeapProfiler {
  export type HeapSnapshotObjectId = string
  export type SamplingHeapProfileNode = {
    callFrame: Runtime.CallFrame
    selfSize: number
    id: number
    children: SamplingHeapProfileNode[]
  }
  export type SamplingHeapProfileSample = {
    size: number
    nodeId: number
    ordinal: number
  }
  export type SamplingHeapProfile = {
    head: SamplingHeapProfileNode
    samples: SamplingHeapProfileSample[]
  }
  export interface GetObjectByHeapObjectIdArgs {
    objectId: HeapSnapshotObjectId
    objectGroup?: string
  }
  export interface StartSamplingArgs {
    samplingInterval?: number
    includeObjectsCollectedByMajorGC?: boolean
    includeObjectsCollectedByMinorGC?: boolean
  }
  export interface StopTrackingHeapObjectsArgs {
    reportProgress?: boolean
    treatGlobalObjectsAsRoots?: boolean
    captureNumericValue?: boolean
    exposeInternals?: boolean
  }
  export interface TakeHeapSnapshotArgs {
    reportProgress?: boolean
    treatGlobalObjectsAsRoots?: boolean
    captureNumericValue?: boolean
    exposeInternals?: boolean
  }
  export interface GetHeapObjectIdResult {
    heapSnapshotObjectId: HeapSnapshotObjectId
  }
  export interface GetObjectByHeapObjectIdResult {
    result: Runtime.RemoteObject
  }
  export interface GetSamplingProfileResult {
    profile: SamplingHeapProfile
  }
  export interface StopSamplingResult {
    profile: SamplingHeapProfile
  }
  export interface AddHeapSnapshotChunkEvent {
    chunk: string
  }
  export interface HeapStatsUpdateEvent {
    statsUpdate: number[]
  }
  export interface LastSeenObjectIdEvent {
    lastSeenObjectId: number
    timestamp: number
  }
  export interface ReportHeapSnapshotProgressEvent {
    done: number
    total: number
    finished: boolean
  }
  export interface ResetProfilesEvent {}
  export interface EventMap {
    addHeapSnapshotChunk: AddHeapSnapshotChunkEvent
    heapStatsUpdate: HeapStatsUpdateEvent
    lastSeenObjectId: LastSeenObjectIdEvent
    reportHeapSnapshotProgress: ReportHeapSnapshotProgressEvent
    resetProfiles: ResetProfilesEvent
  }
}
export namespace Profiler {
  export type ProfileNode = {
    id: number
    callFrame: Runtime.CallFrame
    hitCount?: number
    children?: number[]
    deoptReason?: string
    positionTicks?: PositionTickInfo[]
  }
  export type Profile = {
    nodes: ProfileNode[]
    startTime: number
    endTime: number
    samples?: number[]
    timeDeltas?: number[]
  }
  export type PositionTickInfo = { line: number; ticks: number }
  export type CoverageRange = {
    startOffset: number
    endOffset: number
    count: number
  }
  export type FunctionCoverage = {
    functionName: string
    ranges: CoverageRange[]
    isBlockCoverage: boolean
  }
  export type ScriptCoverage = {
    scriptId: Runtime.ScriptId
    url: string
    functions: FunctionCoverage[]
  }
  export interface StartPreciseCoverageArgs {
    callCount?: boolean
    detailed?: boolean
    allowTriggeredUpdates?: boolean
  }
  export interface GetBestEffortCoverageResult {
    result: ScriptCoverage[]
  }
  export interface StartPreciseCoverageResult {
    timestamp: number
  }
  export interface StopResult {
    profile: Profile
  }
  export interface TakePreciseCoverageResult {
    result: ScriptCoverage[]
    timestamp: number
  }
  export interface ConsoleProfileFinishedEvent {
    id: string
    location: Debugger.Location
    profile: Profile
    title: string
  }
  export interface ConsoleProfileStartedEvent {
    id: string
    location: Debugger.Location
    title: string
  }
  export interface PreciseCoverageDeltaUpdateEvent {
    timestamp: number
    occasion: string
    result: ScriptCoverage[]
  }
  export interface EventMap {
    consoleProfileFinished: ConsoleProfileFinishedEvent
    consoleProfileStarted: ConsoleProfileStartedEvent
    preciseCoverageDeltaUpdate: PreciseCoverageDeltaUpdateEvent
  }
}
export namespace Runtime {
  export type ScriptId = string
  export type SerializationOptions = {
    serialization: 'deep' | 'json' | 'idOnly'
    maxDepth?: number
    additionalParameters?: Record<string, unknown>
  }
  export type DeepSerializedValue = {
    type:
      | 'undefined'
      | 'null'
      | 'string'
      | 'number'
      | 'boolean'
      | 'bigint'
      | 'regexp'
      | 'date'
      | 'symbol'
      | 'array'
      | 'object'
      | 'function'
      | 'map'
      | 'set'
      | 'weakmap'
      | 'weakset'
      | 'error'
      | 'proxy'
      | 'promise'
      | 'typedarray'
      | 'arraybuffer'
      | 'node'
      | 'window'
      | 'generator'
    value?: unknown
    objectId?: string
    weakLocalObjectReference?: number
  }
  export type RemoteObjectId = string
  export type UnserializableValue = string
  export type RemoteObject = {
    type:
      | 'object'
      | 'function'
      | 'undefined'
      | 'string'
      | 'number'
      | 'boolean'
      | 'symbol'
      | 'bigint'
    subtype?:
      | 'array'
      | 'null'
      | 'node'
      | 'regexp'
      | 'date'
      | 'map'
      | 'set'
      | 'weakmap'
      | 'weakset'
      | 'iterator'
      | 'generator'
      | 'error'
      | 'proxy'
      | 'promise'
      | 'typedarray'
      | 'arraybuffer'
      | 'dataview'
      | 'webassemblymemory'
      | 'wasmvalue'
    className?: string
    value?: unknown
    unserializableValue?: UnserializableValue
    description?: string
    deepSerializedValue?: DeepSerializedValue
    objectId?: RemoteObjectId
    preview?: ObjectPreview
    customPreview?: CustomPreview
  }
  export type CustomPreview = { header: string; bodyGetterId?: RemoteObjectId }
  export type ObjectPreview = {
    type:
      | 'object'
      | 'function'
      | 'undefined'
      | 'string'
      | 'number'
      | 'boolean'
      | 'symbol'
      | 'bigint'
    subtype?:
      | 'array'
      | 'null'
      | 'node'
      | 'regexp'
      | 'date'
      | 'map'
      | 'set'
      | 'weakmap'
      | 'weakset'
      | 'iterator'
      | 'generator'
      | 'error'
      | 'proxy'
      | 'promise'
      | 'typedarray'
      | 'arraybuffer'
      | 'dataview'
      | 'webassemblymemory'
      | 'wasmvalue'
    description?: string
    overflow: boolean
    properties: PropertyPreview[]
    entries?: EntryPreview[]
  }
  export type PropertyPreview = {
    name: string
    type:
      | 'object'
      | 'function'
      | 'undefined'
      | 'string'
      | 'number'
      | 'boolean'
      | 'symbol'
      | 'accessor'
      | 'bigint'
    value?: string
    valuePreview?: ObjectPreview
    subtype?:
      | 'array'
      | 'null'
      | 'node'
      | 'regexp'
      | 'date'
      | 'map'
      | 'set'
      | 'weakmap'
      | 'weakset'
      | 'iterator'
      | 'generator'
      | 'error'
      | 'proxy'
      | 'promise'
      | 'typedarray'
      | 'arraybuffer'
      | 'dataview'
      | 'webassemblymemory'
      | 'wasmvalue'
  }
  export type EntryPreview = { key?: ObjectPreview; value: ObjectPreview }
  export type PropertyDescriptor = {
    name: string
    value?: RemoteObject
    writable?: boolean
    get?: RemoteObject
    set?: RemoteObject
    configurable: boolean
    enumerable: boolean
    wasThrown?: boolean
    isOwn?: boolean
    symbol?: RemoteObject
  }
  export type InternalPropertyDescriptor = {
    name: string
    value?: RemoteObject
  }
  export type PrivatePropertyDescriptor = {
    name: string
    value?: RemoteObject
    get?: RemoteObject
    set?: RemoteObject
  }
  export type CallArgument = {
    value?: unknown
    unserializableValue?: UnserializableValue
    objectId?: RemoteObjectId
  }
  export type ExecutionContextId = number
  export type ExecutionContextDescription = {
    id: ExecutionContextId
    origin: string
    name: string
    uniqueId: string
    auxData?: Record<string, unknown>
  }
  export type ExceptionDetails = {
    exceptionId: number
    text: string
    lineNumber: number
    columnNumber: number
    scriptId?: ScriptId
    url?: string
    stackTrace?: StackTrace
    exception?: RemoteObject
    executionContextId?: ExecutionContextId
    exceptionMetaData?: Record<string, unknown>
  }
  export type Timestamp = number
  export type TimeDelta = number
  export type CallFrame = {
    functionName: string
    scriptId: ScriptId
    url: string
    lineNumber: number
    columnNumber: number
  }
  export type StackTrace = {
    description?: string
    callFrames: CallFrame[]
    parent?: StackTrace
    parentId?: StackTraceId
  }
  export type UniqueDebuggerId = string
  export type StackTraceId = { id: string; debuggerId?: UniqueDebuggerId }
  export interface AwaitPromiseArgs {
    promiseObjectId: RemoteObjectId
    returnByValue?: boolean
    generatePreview?: boolean
  }
  export interface CallFunctionOnArgs {
    functionDeclaration: string
    objectId?: RemoteObjectId
    arguments?: CallArgument[]
    silent?: boolean
    returnByValue?: boolean
    generatePreview?: boolean
    userGesture?: boolean
    awaitPromise?: boolean
    executionContextId?: ExecutionContextId
    objectGroup?: string
    throwOnSideEffect?: boolean
    uniqueContextId?: string
    serializationOptions?: SerializationOptions
  }
  export interface CompileScriptArgs {
    expression: string
    sourceURL: string
    persistScript: boolean
    executionContextId?: ExecutionContextId
  }
  export interface EvaluateArgs {
    expression: string
    objectGroup?: string
    includeCommandLineAPI?: boolean
    silent?: boolean
    contextId?: ExecutionContextId
    returnByValue?: boolean
    generatePreview?: boolean
    userGesture?: boolean
    awaitPromise?: boolean
    throwOnSideEffect?: boolean
    timeout?: TimeDelta
    disableBreaks?: boolean
    replMode?: boolean
    allowUnsafeEvalBlockedByCSP?: boolean
    uniqueContextId?: string
    serializationOptions?: SerializationOptions
  }
  export interface GetPropertiesArgs {
    objectId: RemoteObjectId
    ownProperties?: boolean
    accessorPropertiesOnly?: boolean
    generatePreview?: boolean
    nonIndexedPropertiesOnly?: boolean
  }
  export interface QueryObjectsArgs {
    prototypeObjectId: RemoteObjectId
    objectGroup?: string
  }
  export interface RunScriptArgs {
    scriptId: ScriptId
    executionContextId?: ExecutionContextId
    objectGroup?: string
    silent?: boolean
    includeCommandLineAPI?: boolean
    returnByValue?: boolean
    generatePreview?: boolean
    awaitPromise?: boolean
  }
  export interface AddBindingArgs {
    name: string
    executionContextId?: ExecutionContextId
    executionContextName?: string
  }
  export interface AwaitPromiseResult {
    result: RemoteObject
    exceptionDetails: ExceptionDetails
  }
  export interface CallFunctionOnResult {
    result: RemoteObject
    exceptionDetails: ExceptionDetails
  }
  export interface CompileScriptResult {
    scriptId: ScriptId
    exceptionDetails: ExceptionDetails
  }
  export interface EvaluateResult {
    result: RemoteObject
    exceptionDetails: ExceptionDetails
  }
  export interface GetIsolateIdResult {
    id: string
  }
  export interface GetHeapUsageResult {
    usedSize: number
    totalSize: number
    embedderHeapUsedSize: number
    backingStorageSize: number
  }
  export interface GetPropertiesResult {
    result: PropertyDescriptor[]
    internalProperties: InternalPropertyDescriptor[]
    privateProperties: PrivatePropertyDescriptor[]
    exceptionDetails: ExceptionDetails
  }
  export interface GlobalLexicalScopeNamesResult {
    names: string[]
  }
  export interface QueryObjectsResult {
    objects: RemoteObject
  }
  export interface RunScriptResult {
    result: RemoteObject
    exceptionDetails: ExceptionDetails
  }
  export interface GetExceptionDetailsResult {
    exceptionDetails: ExceptionDetails
  }
  export interface BindingCalledEvent {
    name: string
    payload: string
    executionContextId: ExecutionContextId
  }
  export interface ConsoleAPICalledEvent {
    type:
      | 'log'
      | 'debug'
      | 'info'
      | 'error'
      | 'warning'
      | 'dir'
      | 'dirxml'
      | 'table'
      | 'trace'
      | 'clear'
      | 'startGroup'
      | 'startGroupCollapsed'
      | 'endGroup'
      | 'assert'
      | 'profile'
      | 'profileEnd'
      | 'count'
      | 'timeEnd'
    args: RemoteObject[]
    executionContextId: ExecutionContextId
    timestamp: Timestamp
    stackTrace: StackTrace
    context: string
  }
  export interface ExceptionRevokedEvent {
    reason: string
    exceptionId: number
  }
  export interface ExceptionThrownEvent {
    timestamp: Timestamp
    exceptionDetails: ExceptionDetails
  }
  export interface ExecutionContextCreatedEvent {
    context: ExecutionContextDescription
  }
  export interface ExecutionContextDestroyedEvent {
    executionContextId: ExecutionContextId
    executionContextUniqueId: string
  }
  export interface ExecutionContextsClearedEvent {}
  export interface InspectRequestedEvent {
    object: RemoteObject
    hints: Record<string, unknown>
    executionContextId: ExecutionContextId
  }
  export interface EventMap {
    bindingCalled: BindingCalledEvent
    consoleAPICalled: ConsoleAPICalledEvent
    exceptionRevoked: ExceptionRevokedEvent
    exceptionThrown: ExceptionThrownEvent
    executionContextCreated: ExecutionContextCreatedEvent
    executionContextDestroyed: ExecutionContextDestroyedEvent
    executionContextsCleared: ExecutionContextsClearedEvent
    inspectRequested: InspectRequestedEvent
  }
}
export namespace Schema {
  export type Domain = { name: string; version: string }
  export interface GetDomainsResult {
    domains: Domain[]
  }
}
class AccessibilityClient {
  transport: Transport
  sessionId: Target.SessionID | undefined
  listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  disable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Accessibility.disable',
      params: {},
    })
  }
  enable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Accessibility.enable',
      params: {},
    })
  }
  getPartialAXTree(
    args?: Accessibility.GetPartialAXTreeArgs
  ): Promise<Accessibility.GetPartialAXTreeResult> {
    return this.transport.call<Accessibility.GetPartialAXTreeResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Accessibility.getPartialAXTree',
      params: args ?? {},
    })
  }
  getFullAXTree(
    args?: Accessibility.GetFullAXTreeArgs
  ): Promise<Accessibility.GetFullAXTreeResult> {
    return this.transport.call<Accessibility.GetFullAXTreeResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Accessibility.getFullAXTree',
      params: args ?? {},
    })
  }
  getRootAXNode(
    frameId?: Page.FrameId
  ): Promise<Accessibility.GetRootAXNodeResult> {
    return this.transport.call<Accessibility.GetRootAXNodeResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Accessibility.getRootAXNode',
      params: { frameId: frameId },
    })
  }
  getAXNodeAndAncestors(
    args?: Accessibility.GetAXNodeAndAncestorsArgs
  ): Promise<Accessibility.GetAXNodeAndAncestorsResult> {
    return this.transport.call<Accessibility.GetAXNodeAndAncestorsResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Accessibility.getAXNodeAndAncestors',
      params: args ?? {},
    })
  }
  getChildAXNodes(
    args: Accessibility.GetChildAXNodesArgs
  ): Promise<Accessibility.GetChildAXNodesResult> {
    return this.transport.call<Accessibility.GetChildAXNodesResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Accessibility.getChildAXNodes',
      params: args,
    })
  }
  queryAXTree(
    args?: Accessibility.QueryAXTreeArgs
  ): Promise<Accessibility.QueryAXTreeResult> {
    return this.transport.call<Accessibility.QueryAXTreeResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Accessibility.queryAXTree',
      params: args ?? {},
    })
  }
  on<K extends keyof Accessibility.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Accessibility.EventMap[K]>) => void
  ): () => void {
    const filteredListener: typeof listener = (event) => {
      if (event.sessionId !== this.sessionId) {
        return
      }
      listener(event)
    }
    this.listeners.set(
      listener as ChromeEventListener,
      filteredListener as ChromeEventListener
    )
    return this.transport.on(
      'Accessibility.' + name,
      listener as ChromeEventListener
    )
  }
  off<K extends keyof Accessibility.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Accessibility.EventMap[K]>) => void
  ): void {
    const filteredListener = this.listeners.get(listener as ChromeEventListener)
    if (filteredListener === undefined) {
      return
    }
    this.listeners.delete(listener as ChromeEventListener)
    return this.transport.off(
      'Accessibility.' + name,
      listener as ChromeEventListener
    )
  }
}
class AnimationClient {
  transport: Transport
  sessionId: Target.SessionID | undefined
  listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  disable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Animation.disable',
      params: {},
    })
  }
  enable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Animation.enable',
      params: {},
    })
  }
  getCurrentTime(id: string): Promise<Animation.GetCurrentTimeResult> {
    return this.transport.call<Animation.GetCurrentTimeResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Animation.getCurrentTime',
      params: { id: id },
    })
  }
  getPlaybackRate(): Promise<Animation.GetPlaybackRateResult> {
    return this.transport.call<Animation.GetPlaybackRateResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Animation.getPlaybackRate',
      params: {},
    })
  }
  releaseAnimations(animations: string[]): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Animation.releaseAnimations',
      params: { animations: animations },
    })
  }
  resolveAnimation(
    animationId: string
  ): Promise<Animation.ResolveAnimationResult> {
    return this.transport.call<Animation.ResolveAnimationResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Animation.resolveAnimation',
      params: { animationId: animationId },
    })
  }
  seekAnimations(args: Animation.SeekAnimationsArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Animation.seekAnimations',
      params: args,
    })
  }
  setPaused(args: Animation.SetPausedArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Animation.setPaused',
      params: args,
    })
  }
  setPlaybackRate(playbackRate: number): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Animation.setPlaybackRate',
      params: { playbackRate: playbackRate },
    })
  }
  setTiming(args: Animation.SetTimingArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Animation.setTiming',
      params: args,
    })
  }
  on<K extends keyof Animation.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Animation.EventMap[K]>) => void
  ): () => void {
    const filteredListener: typeof listener = (event) => {
      if (event.sessionId !== this.sessionId) {
        return
      }
      listener(event)
    }
    this.listeners.set(
      listener as ChromeEventListener,
      filteredListener as ChromeEventListener
    )
    return this.transport.on(
      'Animation.' + name,
      listener as ChromeEventListener
    )
  }
  off<K extends keyof Animation.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Animation.EventMap[K]>) => void
  ): void {
    const filteredListener = this.listeners.get(listener as ChromeEventListener)
    if (filteredListener === undefined) {
      return
    }
    this.listeners.delete(listener as ChromeEventListener)
    return this.transport.off(
      'Animation.' + name,
      listener as ChromeEventListener
    )
  }
}
class AuditsClient {
  transport: Transport
  sessionId: Target.SessionID | undefined
  listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  getEncodedResponse(
    args: Audits.GetEncodedResponseArgs
  ): Promise<Audits.GetEncodedResponseResult> {
    return this.transport.call<Audits.GetEncodedResponseResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Audits.getEncodedResponse',
      params: args,
    })
  }
  disable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Audits.disable',
      params: {},
    })
  }
  enable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Audits.enable',
      params: {},
    })
  }
  checkContrast(reportAAA?: boolean): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Audits.checkContrast',
      params: { reportAAA: reportAAA },
    })
  }
  checkFormsIssues(): Promise<Audits.CheckFormsIssuesResult> {
    return this.transport.call<Audits.CheckFormsIssuesResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Audits.checkFormsIssues',
      params: {},
    })
  }
  on<K extends keyof Audits.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Audits.EventMap[K]>) => void
  ): () => void {
    const filteredListener: typeof listener = (event) => {
      if (event.sessionId !== this.sessionId) {
        return
      }
      listener(event)
    }
    this.listeners.set(
      listener as ChromeEventListener,
      filteredListener as ChromeEventListener
    )
    return this.transport.on('Audits.' + name, listener as ChromeEventListener)
  }
  off<K extends keyof Audits.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Audits.EventMap[K]>) => void
  ): void {
    const filteredListener = this.listeners.get(listener as ChromeEventListener)
    if (filteredListener === undefined) {
      return
    }
    this.listeners.delete(listener as ChromeEventListener)
    return this.transport.off('Audits.' + name, listener as ChromeEventListener)
  }
}
class ExtensionsClient {
  transport: Transport
  sessionId: Target.SessionID | undefined
  listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  loadUnpacked(path: string): Promise<Extensions.LoadUnpackedResult> {
    return this.transport.call<Extensions.LoadUnpackedResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Extensions.loadUnpacked',
      params: { path: path },
    })
  }
  uninstall(id: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Extensions.uninstall',
      params: { id: id },
    })
  }
  getStorageItems(
    args: Extensions.GetStorageItemsArgs
  ): Promise<Extensions.GetStorageItemsResult> {
    return this.transport.call<Extensions.GetStorageItemsResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Extensions.getStorageItems',
      params: args,
    })
  }
  removeStorageItems(args: Extensions.RemoveStorageItemsArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Extensions.removeStorageItems',
      params: args,
    })
  }
  clearStorageItems(args: Extensions.ClearStorageItemsArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Extensions.clearStorageItems',
      params: args,
    })
  }
  setStorageItems(args: Extensions.SetStorageItemsArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Extensions.setStorageItems',
      params: args,
    })
  }
}
class AutofillClient {
  transport: Transport
  sessionId: Target.SessionID | undefined
  listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  trigger(args: Autofill.TriggerArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Autofill.trigger',
      params: args,
    })
  }
  setAddresses(addresses: Autofill.Address[]): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Autofill.setAddresses',
      params: { addresses: addresses },
    })
  }
  disable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Autofill.disable',
      params: {},
    })
  }
  enable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Autofill.enable',
      params: {},
    })
  }
  on<K extends keyof Autofill.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Autofill.EventMap[K]>) => void
  ): () => void {
    const filteredListener: typeof listener = (event) => {
      if (event.sessionId !== this.sessionId) {
        return
      }
      listener(event)
    }
    this.listeners.set(
      listener as ChromeEventListener,
      filteredListener as ChromeEventListener
    )
    return this.transport.on(
      'Autofill.' + name,
      listener as ChromeEventListener
    )
  }
  off<K extends keyof Autofill.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Autofill.EventMap[K]>) => void
  ): void {
    const filteredListener = this.listeners.get(listener as ChromeEventListener)
    if (filteredListener === undefined) {
      return
    }
    this.listeners.delete(listener as ChromeEventListener)
    return this.transport.off(
      'Autofill.' + name,
      listener as ChromeEventListener
    )
  }
}
class BackgroundServiceClient {
  transport: Transport
  sessionId: Target.SessionID | undefined
  listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  startObserving(service: BackgroundService.ServiceName): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'BackgroundService.startObserving',
      params: { service: service },
    })
  }
  stopObserving(service: BackgroundService.ServiceName): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'BackgroundService.stopObserving',
      params: { service: service },
    })
  }
  setRecording(args: BackgroundService.SetRecordingArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'BackgroundService.setRecording',
      params: args,
    })
  }
  clearEvents(service: BackgroundService.ServiceName): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'BackgroundService.clearEvents',
      params: { service: service },
    })
  }
  on<K extends keyof BackgroundService.EventMap>(
    name: K,
    listener: (event: ChromeEvent<BackgroundService.EventMap[K]>) => void
  ): () => void {
    const filteredListener: typeof listener = (event) => {
      if (event.sessionId !== this.sessionId) {
        return
      }
      listener(event)
    }
    this.listeners.set(
      listener as ChromeEventListener,
      filteredListener as ChromeEventListener
    )
    return this.transport.on(
      'BackgroundService.' + name,
      listener as ChromeEventListener
    )
  }
  off<K extends keyof BackgroundService.EventMap>(
    name: K,
    listener: (event: ChromeEvent<BackgroundService.EventMap[K]>) => void
  ): void {
    const filteredListener = this.listeners.get(listener as ChromeEventListener)
    if (filteredListener === undefined) {
      return
    }
    this.listeners.delete(listener as ChromeEventListener)
    return this.transport.off(
      'BackgroundService.' + name,
      listener as ChromeEventListener
    )
  }
}
class BrowserClient {
  transport: Transport
  sessionId: Target.SessionID | undefined
  listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  setPermission(args: Browser.SetPermissionArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Browser.setPermission',
      params: args,
    })
  }
  grantPermissions(args: Browser.GrantPermissionsArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Browser.grantPermissions',
      params: args,
    })
  }
  resetPermissions(browserContextId?: Browser.BrowserContextID): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Browser.resetPermissions',
      params: { browserContextId: browserContextId },
    })
  }
  setDownloadBehavior(args: Browser.SetDownloadBehaviorArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Browser.setDownloadBehavior',
      params: args,
    })
  }
  cancelDownload(args: Browser.CancelDownloadArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Browser.cancelDownload',
      params: args,
    })
  }
  close(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Browser.close',
      params: {},
    })
  }
  crash(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Browser.crash',
      params: {},
    })
  }
  crashGpuProcess(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Browser.crashGpuProcess',
      params: {},
    })
  }
  getVersion(): Promise<Browser.GetVersionResult> {
    return this.transport.call<Browser.GetVersionResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Browser.getVersion',
      params: {},
    })
  }
  getBrowserCommandLine(): Promise<Browser.GetBrowserCommandLineResult> {
    return this.transport.call<Browser.GetBrowserCommandLineResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Browser.getBrowserCommandLine',
      params: {},
    })
  }
  getHistograms(
    args?: Browser.GetHistogramsArgs
  ): Promise<Browser.GetHistogramsResult> {
    return this.transport.call<Browser.GetHistogramsResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Browser.getHistograms',
      params: args ?? {},
    })
  }
  getHistogram(
    args: Browser.GetHistogramArgs
  ): Promise<Browser.GetHistogramResult> {
    return this.transport.call<Browser.GetHistogramResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Browser.getHistogram',
      params: args,
    })
  }
  getWindowBounds(
    windowId: Browser.WindowID
  ): Promise<Browser.GetWindowBoundsResult> {
    return this.transport.call<Browser.GetWindowBoundsResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Browser.getWindowBounds',
      params: { windowId: windowId },
    })
  }
  getWindowForTarget(
    targetId?: Target.TargetID
  ): Promise<Browser.GetWindowForTargetResult> {
    return this.transport.call<Browser.GetWindowForTargetResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Browser.getWindowForTarget',
      params: { targetId: targetId },
    })
  }
  setWindowBounds(args: Browser.SetWindowBoundsArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Browser.setWindowBounds',
      params: args,
    })
  }
  setDockTile(args?: Browser.SetDockTileArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Browser.setDockTile',
      params: args ?? {},
    })
  }
  executeBrowserCommand(commandId: Browser.BrowserCommandId): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Browser.executeBrowserCommand',
      params: { commandId: commandId },
    })
  }
  addPrivacySandboxEnrollmentOverride(url: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Browser.addPrivacySandboxEnrollmentOverride',
      params: { url: url },
    })
  }
  addPrivacySandboxCoordinatorKeyConfig(
    args: Browser.AddPrivacySandboxCoordinatorKeyConfigArgs
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Browser.addPrivacySandboxCoordinatorKeyConfig',
      params: args,
    })
  }
  on<K extends keyof Browser.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Browser.EventMap[K]>) => void
  ): () => void {
    const filteredListener: typeof listener = (event) => {
      if (event.sessionId !== this.sessionId) {
        return
      }
      listener(event)
    }
    this.listeners.set(
      listener as ChromeEventListener,
      filteredListener as ChromeEventListener
    )
    return this.transport.on('Browser.' + name, listener as ChromeEventListener)
  }
  off<K extends keyof Browser.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Browser.EventMap[K]>) => void
  ): void {
    const filteredListener = this.listeners.get(listener as ChromeEventListener)
    if (filteredListener === undefined) {
      return
    }
    this.listeners.delete(listener as ChromeEventListener)
    return this.transport.off(
      'Browser.' + name,
      listener as ChromeEventListener
    )
  }
}
class CSSClient {
  transport: Transport
  sessionId: Target.SessionID | undefined
  listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  addRule(args: CSS.AddRuleArgs): Promise<CSS.AddRuleResult> {
    return this.transport.call<CSS.AddRuleResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'CSS.addRule',
      params: args,
    })
  }
  collectClassNames(
    styleSheetId: CSS.StyleSheetId
  ): Promise<CSS.CollectClassNamesResult> {
    return this.transport.call<CSS.CollectClassNamesResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'CSS.collectClassNames',
      params: { styleSheetId: styleSheetId },
    })
  }
  createStyleSheet(
    args: CSS.CreateStyleSheetArgs
  ): Promise<CSS.CreateStyleSheetResult> {
    return this.transport.call<CSS.CreateStyleSheetResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'CSS.createStyleSheet',
      params: args,
    })
  }
  disable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'CSS.disable',
      params: {},
    })
  }
  enable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'CSS.enable',
      params: {},
    })
  }
  forcePseudoState(args: CSS.ForcePseudoStateArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'CSS.forcePseudoState',
      params: args,
    })
  }
  forceStartingStyle(args: CSS.ForceStartingStyleArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'CSS.forceStartingStyle',
      params: args,
    })
  }
  getBackgroundColors(
    nodeId: DOM.NodeId
  ): Promise<CSS.GetBackgroundColorsResult> {
    return this.transport.call<CSS.GetBackgroundColorsResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'CSS.getBackgroundColors',
      params: { nodeId: nodeId },
    })
  }
  getComputedStyleForNode(
    nodeId: DOM.NodeId
  ): Promise<CSS.GetComputedStyleForNodeResult> {
    return this.transport.call<CSS.GetComputedStyleForNodeResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'CSS.getComputedStyleForNode',
      params: { nodeId: nodeId },
    })
  }
  resolveValues(args: CSS.ResolveValuesArgs): Promise<CSS.ResolveValuesResult> {
    return this.transport.call<CSS.ResolveValuesResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'CSS.resolveValues',
      params: args,
    })
  }
  getLonghandProperties(
    args: CSS.GetLonghandPropertiesArgs
  ): Promise<CSS.GetLonghandPropertiesResult> {
    return this.transport.call<CSS.GetLonghandPropertiesResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'CSS.getLonghandProperties',
      params: args,
    })
  }
  getInlineStylesForNode(
    nodeId: DOM.NodeId
  ): Promise<CSS.GetInlineStylesForNodeResult> {
    return this.transport.call<CSS.GetInlineStylesForNodeResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'CSS.getInlineStylesForNode',
      params: { nodeId: nodeId },
    })
  }
  getAnimatedStylesForNode(
    nodeId: DOM.NodeId
  ): Promise<CSS.GetAnimatedStylesForNodeResult> {
    return this.transport.call<CSS.GetAnimatedStylesForNodeResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'CSS.getAnimatedStylesForNode',
      params: { nodeId: nodeId },
    })
  }
  getMatchedStylesForNode(
    nodeId: DOM.NodeId
  ): Promise<CSS.GetMatchedStylesForNodeResult> {
    return this.transport.call<CSS.GetMatchedStylesForNodeResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'CSS.getMatchedStylesForNode',
      params: { nodeId: nodeId },
    })
  }
  getMediaQueries(): Promise<CSS.GetMediaQueriesResult> {
    return this.transport.call<CSS.GetMediaQueriesResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'CSS.getMediaQueries',
      params: {},
    })
  }
  getPlatformFontsForNode(
    nodeId: DOM.NodeId
  ): Promise<CSS.GetPlatformFontsForNodeResult> {
    return this.transport.call<CSS.GetPlatformFontsForNodeResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'CSS.getPlatformFontsForNode',
      params: { nodeId: nodeId },
    })
  }
  getStyleSheetText(
    styleSheetId: CSS.StyleSheetId
  ): Promise<CSS.GetStyleSheetTextResult> {
    return this.transport.call<CSS.GetStyleSheetTextResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'CSS.getStyleSheetText',
      params: { styleSheetId: styleSheetId },
    })
  }
  getLayersForNode(nodeId: DOM.NodeId): Promise<CSS.GetLayersForNodeResult> {
    return this.transport.call<CSS.GetLayersForNodeResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'CSS.getLayersForNode',
      params: { nodeId: nodeId },
    })
  }
  getLocationForSelector(
    args: CSS.GetLocationForSelectorArgs
  ): Promise<CSS.GetLocationForSelectorResult> {
    return this.transport.call<CSS.GetLocationForSelectorResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'CSS.getLocationForSelector',
      params: args,
    })
  }
  trackComputedStyleUpdatesForNode(nodeId?: DOM.NodeId): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'CSS.trackComputedStyleUpdatesForNode',
      params: { nodeId: nodeId },
    })
  }
  trackComputedStyleUpdates(
    propertiesToTrack: CSS.CSSComputedStyleProperty[]
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'CSS.trackComputedStyleUpdates',
      params: { propertiesToTrack: propertiesToTrack },
    })
  }
  takeComputedStyleUpdates(): Promise<CSS.TakeComputedStyleUpdatesResult> {
    return this.transport.call<CSS.TakeComputedStyleUpdatesResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'CSS.takeComputedStyleUpdates',
      params: {},
    })
  }
  setEffectivePropertyValueForNode(
    args: CSS.SetEffectivePropertyValueForNodeArgs
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'CSS.setEffectivePropertyValueForNode',
      params: args,
    })
  }
  setPropertyRulePropertyName(
    args: CSS.SetPropertyRulePropertyNameArgs
  ): Promise<CSS.SetPropertyRulePropertyNameResult> {
    return this.transport.call<CSS.SetPropertyRulePropertyNameResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'CSS.setPropertyRulePropertyName',
      params: args,
    })
  }
  setKeyframeKey(
    args: CSS.SetKeyframeKeyArgs
  ): Promise<CSS.SetKeyframeKeyResult> {
    return this.transport.call<CSS.SetKeyframeKeyResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'CSS.setKeyframeKey',
      params: args,
    })
  }
  setMediaText(args: CSS.SetMediaTextArgs): Promise<CSS.SetMediaTextResult> {
    return this.transport.call<CSS.SetMediaTextResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'CSS.setMediaText',
      params: args,
    })
  }
  setContainerQueryText(
    args: CSS.SetContainerQueryTextArgs
  ): Promise<CSS.SetContainerQueryTextResult> {
    return this.transport.call<CSS.SetContainerQueryTextResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'CSS.setContainerQueryText',
      params: args,
    })
  }
  setSupportsText(
    args: CSS.SetSupportsTextArgs
  ): Promise<CSS.SetSupportsTextResult> {
    return this.transport.call<CSS.SetSupportsTextResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'CSS.setSupportsText',
      params: args,
    })
  }
  setScopeText(args: CSS.SetScopeTextArgs): Promise<CSS.SetScopeTextResult> {
    return this.transport.call<CSS.SetScopeTextResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'CSS.setScopeText',
      params: args,
    })
  }
  setRuleSelector(
    args: CSS.SetRuleSelectorArgs
  ): Promise<CSS.SetRuleSelectorResult> {
    return this.transport.call<CSS.SetRuleSelectorResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'CSS.setRuleSelector',
      params: args,
    })
  }
  setStyleSheetText(
    args: CSS.SetStyleSheetTextArgs
  ): Promise<CSS.SetStyleSheetTextResult> {
    return this.transport.call<CSS.SetStyleSheetTextResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'CSS.setStyleSheetText',
      params: args,
    })
  }
  setStyleTexts(args: CSS.SetStyleTextsArgs): Promise<CSS.SetStyleTextsResult> {
    return this.transport.call<CSS.SetStyleTextsResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'CSS.setStyleTexts',
      params: args,
    })
  }
  startRuleUsageTracking(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'CSS.startRuleUsageTracking',
      params: {},
    })
  }
  stopRuleUsageTracking(): Promise<CSS.StopRuleUsageTrackingResult> {
    return this.transport.call<CSS.StopRuleUsageTrackingResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'CSS.stopRuleUsageTracking',
      params: {},
    })
  }
  takeCoverageDelta(): Promise<CSS.TakeCoverageDeltaResult> {
    return this.transport.call<CSS.TakeCoverageDeltaResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'CSS.takeCoverageDelta',
      params: {},
    })
  }
  setLocalFontsEnabled(enabled: boolean): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'CSS.setLocalFontsEnabled',
      params: { enabled: enabled },
    })
  }
  on<K extends keyof CSS.EventMap>(
    name: K,
    listener: (event: ChromeEvent<CSS.EventMap[K]>) => void
  ): () => void {
    const filteredListener: typeof listener = (event) => {
      if (event.sessionId !== this.sessionId) {
        return
      }
      listener(event)
    }
    this.listeners.set(
      listener as ChromeEventListener,
      filteredListener as ChromeEventListener
    )
    return this.transport.on('CSS.' + name, listener as ChromeEventListener)
  }
  off<K extends keyof CSS.EventMap>(
    name: K,
    listener: (event: ChromeEvent<CSS.EventMap[K]>) => void
  ): void {
    const filteredListener = this.listeners.get(listener as ChromeEventListener)
    if (filteredListener === undefined) {
      return
    }
    this.listeners.delete(listener as ChromeEventListener)
    return this.transport.off('CSS.' + name, listener as ChromeEventListener)
  }
}
class CacheStorageClient {
  transport: Transport
  sessionId: Target.SessionID | undefined
  listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  deleteCache(cacheId: CacheStorage.CacheId): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'CacheStorage.deleteCache',
      params: { cacheId: cacheId },
    })
  }
  deleteEntry(args: CacheStorage.DeleteEntryArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'CacheStorage.deleteEntry',
      params: args,
    })
  }
  requestCacheNames(
    args?: CacheStorage.RequestCacheNamesArgs
  ): Promise<CacheStorage.RequestCacheNamesResult> {
    return this.transport.call<CacheStorage.RequestCacheNamesResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'CacheStorage.requestCacheNames',
      params: args ?? {},
    })
  }
  requestCachedResponse(
    args: CacheStorage.RequestCachedResponseArgs
  ): Promise<CacheStorage.RequestCachedResponseResult> {
    return this.transport.call<CacheStorage.RequestCachedResponseResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'CacheStorage.requestCachedResponse',
      params: args,
    })
  }
  requestEntries(
    args: CacheStorage.RequestEntriesArgs
  ): Promise<CacheStorage.RequestEntriesResult> {
    return this.transport.call<CacheStorage.RequestEntriesResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'CacheStorage.requestEntries',
      params: args,
    })
  }
}
class CastClient {
  transport: Transport
  sessionId: Target.SessionID | undefined
  listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  enable(presentationUrl?: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Cast.enable',
      params: { presentationUrl: presentationUrl },
    })
  }
  disable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Cast.disable',
      params: {},
    })
  }
  setSinkToUse(sinkName: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Cast.setSinkToUse',
      params: { sinkName: sinkName },
    })
  }
  startDesktopMirroring(sinkName: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Cast.startDesktopMirroring',
      params: { sinkName: sinkName },
    })
  }
  startTabMirroring(sinkName: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Cast.startTabMirroring',
      params: { sinkName: sinkName },
    })
  }
  stopCasting(sinkName: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Cast.stopCasting',
      params: { sinkName: sinkName },
    })
  }
  on<K extends keyof Cast.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Cast.EventMap[K]>) => void
  ): () => void {
    const filteredListener: typeof listener = (event) => {
      if (event.sessionId !== this.sessionId) {
        return
      }
      listener(event)
    }
    this.listeners.set(
      listener as ChromeEventListener,
      filteredListener as ChromeEventListener
    )
    return this.transport.on('Cast.' + name, listener as ChromeEventListener)
  }
  off<K extends keyof Cast.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Cast.EventMap[K]>) => void
  ): void {
    const filteredListener = this.listeners.get(listener as ChromeEventListener)
    if (filteredListener === undefined) {
      return
    }
    this.listeners.delete(listener as ChromeEventListener)
    return this.transport.off('Cast.' + name, listener as ChromeEventListener)
  }
}
class DOMClient {
  transport: Transport
  sessionId: Target.SessionID | undefined
  listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  collectClassNamesFromSubtree(
    nodeId: DOM.NodeId
  ): Promise<DOM.CollectClassNamesFromSubtreeResult> {
    return this.transport.call<DOM.CollectClassNamesFromSubtreeResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.collectClassNamesFromSubtree',
      params: { nodeId: nodeId },
    })
  }
  copyTo(args: DOM.CopyToArgs): Promise<DOM.CopyToResult> {
    return this.transport.call<DOM.CopyToResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.copyTo',
      params: args,
    })
  }
  describeNode(args?: DOM.DescribeNodeArgs): Promise<DOM.DescribeNodeResult> {
    return this.transport.call<DOM.DescribeNodeResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.describeNode',
      params: args ?? {},
    })
  }
  scrollIntoViewIfNeeded(args?: DOM.ScrollIntoViewIfNeededArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.scrollIntoViewIfNeeded',
      params: args ?? {},
    })
  }
  disable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.disable',
      params: {},
    })
  }
  discardSearchResults(searchId: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.discardSearchResults',
      params: { searchId: searchId },
    })
  }
  enable(includeWhitespace?: 'none' | 'all'): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.enable',
      params: { includeWhitespace: includeWhitespace },
    })
  }
  focus(args?: DOM.FocusArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.focus',
      params: args ?? {},
    })
  }
  getAttributes(nodeId: DOM.NodeId): Promise<DOM.GetAttributesResult> {
    return this.transport.call<DOM.GetAttributesResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.getAttributes',
      params: { nodeId: nodeId },
    })
  }
  getBoxModel(args?: DOM.GetBoxModelArgs): Promise<DOM.GetBoxModelResult> {
    return this.transport.call<DOM.GetBoxModelResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.getBoxModel',
      params: args ?? {},
    })
  }
  getContentQuads(
    args?: DOM.GetContentQuadsArgs
  ): Promise<DOM.GetContentQuadsResult> {
    return this.transport.call<DOM.GetContentQuadsResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.getContentQuads',
      params: args ?? {},
    })
  }
  getDocument(args?: DOM.GetDocumentArgs): Promise<DOM.GetDocumentResult> {
    return this.transport.call<DOM.GetDocumentResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.getDocument',
      params: args ?? {},
    })
  }
  getFlattenedDocument(
    args?: DOM.GetFlattenedDocumentArgs
  ): Promise<DOM.GetFlattenedDocumentResult> {
    return this.transport.call<DOM.GetFlattenedDocumentResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.getFlattenedDocument',
      params: args ?? {},
    })
  }
  getNodesForSubtreeByStyle(
    args: DOM.GetNodesForSubtreeByStyleArgs
  ): Promise<DOM.GetNodesForSubtreeByStyleResult> {
    return this.transport.call<DOM.GetNodesForSubtreeByStyleResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.getNodesForSubtreeByStyle',
      params: args,
    })
  }
  getNodeForLocation(
    args: DOM.GetNodeForLocationArgs
  ): Promise<DOM.GetNodeForLocationResult> {
    return this.transport.call<DOM.GetNodeForLocationResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.getNodeForLocation',
      params: args,
    })
  }
  getOuterHTML(args?: DOM.GetOuterHTMLArgs): Promise<DOM.GetOuterHTMLResult> {
    return this.transport.call<DOM.GetOuterHTMLResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.getOuterHTML',
      params: args ?? {},
    })
  }
  getRelayoutBoundary(
    nodeId: DOM.NodeId
  ): Promise<DOM.GetRelayoutBoundaryResult> {
    return this.transport.call<DOM.GetRelayoutBoundaryResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.getRelayoutBoundary',
      params: { nodeId: nodeId },
    })
  }
  getSearchResults(
    args: DOM.GetSearchResultsArgs
  ): Promise<DOM.GetSearchResultsResult> {
    return this.transport.call<DOM.GetSearchResultsResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.getSearchResults',
      params: args,
    })
  }
  hideHighlight(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.hideHighlight',
      params: {},
    })
  }
  highlightNode(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.highlightNode',
      params: {},
    })
  }
  highlightRect(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.highlightRect',
      params: {},
    })
  }
  markUndoableState(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.markUndoableState',
      params: {},
    })
  }
  moveTo(args: DOM.MoveToArgs): Promise<DOM.MoveToResult> {
    return this.transport.call<DOM.MoveToResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.moveTo',
      params: args,
    })
  }
  performSearch(args: DOM.PerformSearchArgs): Promise<DOM.PerformSearchResult> {
    return this.transport.call<DOM.PerformSearchResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.performSearch',
      params: args,
    })
  }
  pushNodeByPathToFrontend(
    path: string
  ): Promise<DOM.PushNodeByPathToFrontendResult> {
    return this.transport.call<DOM.PushNodeByPathToFrontendResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.pushNodeByPathToFrontend',
      params: { path: path },
    })
  }
  pushNodesByBackendIdsToFrontend(
    backendNodeIds: DOM.BackendNodeId[]
  ): Promise<DOM.PushNodesByBackendIdsToFrontendResult> {
    return this.transport.call<DOM.PushNodesByBackendIdsToFrontendResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.pushNodesByBackendIdsToFrontend',
      params: { backendNodeIds: backendNodeIds },
    })
  }
  querySelector(args: DOM.QuerySelectorArgs): Promise<DOM.QuerySelectorResult> {
    return this.transport.call<DOM.QuerySelectorResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.querySelector',
      params: args,
    })
  }
  querySelectorAll(
    args: DOM.QuerySelectorAllArgs
  ): Promise<DOM.QuerySelectorAllResult> {
    return this.transport.call<DOM.QuerySelectorAllResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.querySelectorAll',
      params: args,
    })
  }
  getTopLayerElements(): Promise<DOM.GetTopLayerElementsResult> {
    return this.transport.call<DOM.GetTopLayerElementsResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.getTopLayerElements',
      params: {},
    })
  }
  getElementByRelation(
    args: DOM.GetElementByRelationArgs
  ): Promise<DOM.GetElementByRelationResult> {
    return this.transport.call<DOM.GetElementByRelationResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.getElementByRelation',
      params: args,
    })
  }
  redo(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.redo',
      params: {},
    })
  }
  removeAttribute(args: DOM.RemoveAttributeArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.removeAttribute',
      params: args,
    })
  }
  removeNode(nodeId: DOM.NodeId): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.removeNode',
      params: { nodeId: nodeId },
    })
  }
  requestChildNodes(args: DOM.RequestChildNodesArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.requestChildNodes',
      params: args,
    })
  }
  requestNode(
    objectId: Runtime.RemoteObjectId
  ): Promise<DOM.RequestNodeResult> {
    return this.transport.call<DOM.RequestNodeResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.requestNode',
      params: { objectId: objectId },
    })
  }
  resolveNode(args?: DOM.ResolveNodeArgs): Promise<DOM.ResolveNodeResult> {
    return this.transport.call<DOM.ResolveNodeResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.resolveNode',
      params: args ?? {},
    })
  }
  setAttributeValue(args: DOM.SetAttributeValueArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.setAttributeValue',
      params: args,
    })
  }
  setAttributesAsText(args: DOM.SetAttributesAsTextArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.setAttributesAsText',
      params: args,
    })
  }
  setFileInputFiles(args: DOM.SetFileInputFilesArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.setFileInputFiles',
      params: args,
    })
  }
  setNodeStackTracesEnabled(enable: boolean): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.setNodeStackTracesEnabled',
      params: { enable: enable },
    })
  }
  getNodeStackTraces(
    nodeId: DOM.NodeId
  ): Promise<DOM.GetNodeStackTracesResult> {
    return this.transport.call<DOM.GetNodeStackTracesResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.getNodeStackTraces',
      params: { nodeId: nodeId },
    })
  }
  getFileInfo(
    objectId: Runtime.RemoteObjectId
  ): Promise<DOM.GetFileInfoResult> {
    return this.transport.call<DOM.GetFileInfoResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.getFileInfo',
      params: { objectId: objectId },
    })
  }
  getDetachedDomNodes(): Promise<DOM.GetDetachedDomNodesResult> {
    return this.transport.call<DOM.GetDetachedDomNodesResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.getDetachedDomNodes',
      params: {},
    })
  }
  setInspectedNode(nodeId: DOM.NodeId): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.setInspectedNode',
      params: { nodeId: nodeId },
    })
  }
  setNodeName(args: DOM.SetNodeNameArgs): Promise<DOM.SetNodeNameResult> {
    return this.transport.call<DOM.SetNodeNameResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.setNodeName',
      params: args,
    })
  }
  setNodeValue(args: DOM.SetNodeValueArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.setNodeValue',
      params: args,
    })
  }
  setOuterHTML(args: DOM.SetOuterHTMLArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.setOuterHTML',
      params: args,
    })
  }
  undo(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.undo',
      params: {},
    })
  }
  getFrameOwner(frameId: Page.FrameId): Promise<DOM.GetFrameOwnerResult> {
    return this.transport.call<DOM.GetFrameOwnerResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.getFrameOwner',
      params: { frameId: frameId },
    })
  }
  getContainerForNode(
    args: DOM.GetContainerForNodeArgs
  ): Promise<DOM.GetContainerForNodeResult> {
    return this.transport.call<DOM.GetContainerForNodeResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.getContainerForNode',
      params: args,
    })
  }
  getQueryingDescendantsForContainer(
    nodeId: DOM.NodeId
  ): Promise<DOM.GetQueryingDescendantsForContainerResult> {
    return this.transport.call<DOM.GetQueryingDescendantsForContainerResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.getQueryingDescendantsForContainer',
      params: { nodeId: nodeId },
    })
  }
  getAnchorElement(
    args: DOM.GetAnchorElementArgs
  ): Promise<DOM.GetAnchorElementResult> {
    return this.transport.call<DOM.GetAnchorElementResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.getAnchorElement',
      params: args,
    })
  }
  on<K extends keyof DOM.EventMap>(
    name: K,
    listener: (event: ChromeEvent<DOM.EventMap[K]>) => void
  ): () => void {
    const filteredListener: typeof listener = (event) => {
      if (event.sessionId !== this.sessionId) {
        return
      }
      listener(event)
    }
    this.listeners.set(
      listener as ChromeEventListener,
      filteredListener as ChromeEventListener
    )
    return this.transport.on('DOM.' + name, listener as ChromeEventListener)
  }
  off<K extends keyof DOM.EventMap>(
    name: K,
    listener: (event: ChromeEvent<DOM.EventMap[K]>) => void
  ): void {
    const filteredListener = this.listeners.get(listener as ChromeEventListener)
    if (filteredListener === undefined) {
      return
    }
    this.listeners.delete(listener as ChromeEventListener)
    return this.transport.off('DOM.' + name, listener as ChromeEventListener)
  }
}
class DOMDebuggerClient {
  transport: Transport
  sessionId: Target.SessionID | undefined
  listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  getEventListeners(
    args: DOMDebugger.GetEventListenersArgs
  ): Promise<DOMDebugger.GetEventListenersResult> {
    return this.transport.call<DOMDebugger.GetEventListenersResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOMDebugger.getEventListeners',
      params: args,
    })
  }
  removeDOMBreakpoint(
    args: DOMDebugger.RemoveDOMBreakpointArgs
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOMDebugger.removeDOMBreakpoint',
      params: args,
    })
  }
  removeEventListenerBreakpoint(
    args: DOMDebugger.RemoveEventListenerBreakpointArgs
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOMDebugger.removeEventListenerBreakpoint',
      params: args,
    })
  }
  removeInstrumentationBreakpoint(eventName: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOMDebugger.removeInstrumentationBreakpoint',
      params: { eventName: eventName },
    })
  }
  removeXHRBreakpoint(url: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOMDebugger.removeXHRBreakpoint',
      params: { url: url },
    })
  }
  setBreakOnCSPViolation(
    violationTypes: DOMDebugger.CSPViolationType[]
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOMDebugger.setBreakOnCSPViolation',
      params: { violationTypes: violationTypes },
    })
  }
  setDOMBreakpoint(args: DOMDebugger.SetDOMBreakpointArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOMDebugger.setDOMBreakpoint',
      params: args,
    })
  }
  setEventListenerBreakpoint(
    args: DOMDebugger.SetEventListenerBreakpointArgs
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOMDebugger.setEventListenerBreakpoint',
      params: args,
    })
  }
  setInstrumentationBreakpoint(eventName: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOMDebugger.setInstrumentationBreakpoint',
      params: { eventName: eventName },
    })
  }
  setXHRBreakpoint(url: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOMDebugger.setXHRBreakpoint',
      params: { url: url },
    })
  }
}
class EventBreakpointsClient {
  transport: Transport
  sessionId: Target.SessionID | undefined
  listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  setInstrumentationBreakpoint(eventName: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'EventBreakpoints.setInstrumentationBreakpoint',
      params: { eventName: eventName },
    })
  }
  removeInstrumentationBreakpoint(eventName: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'EventBreakpoints.removeInstrumentationBreakpoint',
      params: { eventName: eventName },
    })
  }
  disable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'EventBreakpoints.disable',
      params: {},
    })
  }
}
class DOMSnapshotClient {
  transport: Transport
  sessionId: Target.SessionID | undefined
  listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  disable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOMSnapshot.disable',
      params: {},
    })
  }
  enable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOMSnapshot.enable',
      params: {},
    })
  }
  getSnapshot(
    args: DOMSnapshot.GetSnapshotArgs
  ): Promise<DOMSnapshot.GetSnapshotResult> {
    return this.transport.call<DOMSnapshot.GetSnapshotResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOMSnapshot.getSnapshot',
      params: args,
    })
  }
  captureSnapshot(
    args: DOMSnapshot.CaptureSnapshotArgs
  ): Promise<DOMSnapshot.CaptureSnapshotResult> {
    return this.transport.call<DOMSnapshot.CaptureSnapshotResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOMSnapshot.captureSnapshot',
      params: args,
    })
  }
}
class DOMStorageClient {
  transport: Transport
  sessionId: Target.SessionID | undefined
  listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  clear(storageId: DOMStorage.StorageId): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOMStorage.clear',
      params: { storageId: storageId },
    })
  }
  disable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOMStorage.disable',
      params: {},
    })
  }
  enable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOMStorage.enable',
      params: {},
    })
  }
  getDOMStorageItems(
    storageId: DOMStorage.StorageId
  ): Promise<DOMStorage.GetDOMStorageItemsResult> {
    return this.transport.call<DOMStorage.GetDOMStorageItemsResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOMStorage.getDOMStorageItems',
      params: { storageId: storageId },
    })
  }
  removeDOMStorageItem(
    args: DOMStorage.RemoveDOMStorageItemArgs
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOMStorage.removeDOMStorageItem',
      params: args,
    })
  }
  setDOMStorageItem(args: DOMStorage.SetDOMStorageItemArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOMStorage.setDOMStorageItem',
      params: args,
    })
  }
  on<K extends keyof DOMStorage.EventMap>(
    name: K,
    listener: (event: ChromeEvent<DOMStorage.EventMap[K]>) => void
  ): () => void {
    const filteredListener: typeof listener = (event) => {
      if (event.sessionId !== this.sessionId) {
        return
      }
      listener(event)
    }
    this.listeners.set(
      listener as ChromeEventListener,
      filteredListener as ChromeEventListener
    )
    return this.transport.on(
      'DOMStorage.' + name,
      listener as ChromeEventListener
    )
  }
  off<K extends keyof DOMStorage.EventMap>(
    name: K,
    listener: (event: ChromeEvent<DOMStorage.EventMap[K]>) => void
  ): void {
    const filteredListener = this.listeners.get(listener as ChromeEventListener)
    if (filteredListener === undefined) {
      return
    }
    this.listeners.delete(listener as ChromeEventListener)
    return this.transport.off(
      'DOMStorage.' + name,
      listener as ChromeEventListener
    )
  }
}
class DeviceOrientationClient {
  transport: Transport
  sessionId: Target.SessionID | undefined
  listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  clearDeviceOrientationOverride(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DeviceOrientation.clearDeviceOrientationOverride',
      params: {},
    })
  }
  setDeviceOrientationOverride(
    args: DeviceOrientation.SetDeviceOrientationOverrideArgs
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DeviceOrientation.setDeviceOrientationOverride',
      params: args,
    })
  }
}
class EmulationClient {
  transport: Transport
  sessionId: Target.SessionID | undefined
  listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  canEmulate(): Promise<Emulation.CanEmulateResult> {
    return this.transport.call<Emulation.CanEmulateResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Emulation.canEmulate',
      params: {},
    })
  }
  clearDeviceMetricsOverride(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Emulation.clearDeviceMetricsOverride',
      params: {},
    })
  }
  clearGeolocationOverride(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Emulation.clearGeolocationOverride',
      params: {},
    })
  }
  resetPageScaleFactor(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Emulation.resetPageScaleFactor',
      params: {},
    })
  }
  setFocusEmulationEnabled(enabled: boolean): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Emulation.setFocusEmulationEnabled',
      params: { enabled: enabled },
    })
  }
  setAutoDarkModeOverride(enabled?: boolean): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Emulation.setAutoDarkModeOverride',
      params: { enabled: enabled },
    })
  }
  setCPUThrottlingRate(rate: number): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Emulation.setCPUThrottlingRate',
      params: { rate: rate },
    })
  }
  setDefaultBackgroundColorOverride(color?: DOM.RGBA): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Emulation.setDefaultBackgroundColorOverride',
      params: { color: color },
    })
  }
  setSafeAreaInsetsOverride(insets: Emulation.SafeAreaInsets): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Emulation.setSafeAreaInsetsOverride',
      params: { insets: insets },
    })
  }
  setDeviceMetricsOverride(
    args: Emulation.SetDeviceMetricsOverrideArgs
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Emulation.setDeviceMetricsOverride',
      params: args,
    })
  }
  setDevicePostureOverride(posture: Emulation.DevicePosture): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Emulation.setDevicePostureOverride',
      params: { posture: posture },
    })
  }
  clearDevicePostureOverride(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Emulation.clearDevicePostureOverride',
      params: {},
    })
  }
  setDisplayFeaturesOverride(
    features: Emulation.DisplayFeature[]
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Emulation.setDisplayFeaturesOverride',
      params: { features: features },
    })
  }
  clearDisplayFeaturesOverride(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Emulation.clearDisplayFeaturesOverride',
      params: {},
    })
  }
  setScrollbarsHidden(hidden: boolean): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Emulation.setScrollbarsHidden',
      params: { hidden: hidden },
    })
  }
  setDocumentCookieDisabled(disabled: boolean): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Emulation.setDocumentCookieDisabled',
      params: { disabled: disabled },
    })
  }
  setEmitTouchEventsForMouse(
    args: Emulation.SetEmitTouchEventsForMouseArgs
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Emulation.setEmitTouchEventsForMouse',
      params: args,
    })
  }
  setEmulatedMedia(args?: Emulation.SetEmulatedMediaArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Emulation.setEmulatedMedia',
      params: args ?? {},
    })
  }
  setEmulatedVisionDeficiency(
    type:
      | 'none'
      | 'blurredVision'
      | 'reducedContrast'
      | 'achromatopsia'
      | 'deuteranopia'
      | 'protanopia'
      | 'tritanopia'
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Emulation.setEmulatedVisionDeficiency',
      params: { type: type },
    })
  }
  setGeolocationOverride(
    args?: Emulation.SetGeolocationOverrideArgs
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Emulation.setGeolocationOverride',
      params: args ?? {},
    })
  }
  getOverriddenSensorInformation(
    type: Emulation.SensorType
  ): Promise<Emulation.GetOverriddenSensorInformationResult> {
    return this.transport.call<Emulation.GetOverriddenSensorInformationResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Emulation.getOverriddenSensorInformation',
      params: { type: type },
    })
  }
  setSensorOverrideEnabled(
    args: Emulation.SetSensorOverrideEnabledArgs
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Emulation.setSensorOverrideEnabled',
      params: args,
    })
  }
  setSensorOverrideReadings(
    args: Emulation.SetSensorOverrideReadingsArgs
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Emulation.setSensorOverrideReadings',
      params: args,
    })
  }
  setPressureSourceOverrideEnabled(
    args: Emulation.SetPressureSourceOverrideEnabledArgs
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Emulation.setPressureSourceOverrideEnabled',
      params: args,
    })
  }
  setPressureStateOverride(
    args: Emulation.SetPressureStateOverrideArgs
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Emulation.setPressureStateOverride',
      params: args,
    })
  }
  setPressureDataOverride(
    args: Emulation.SetPressureDataOverrideArgs
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Emulation.setPressureDataOverride',
      params: args,
    })
  }
  setIdleOverride(args: Emulation.SetIdleOverrideArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Emulation.setIdleOverride',
      params: args,
    })
  }
  clearIdleOverride(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Emulation.clearIdleOverride',
      params: {},
    })
  }
  setNavigatorOverrides(platform: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Emulation.setNavigatorOverrides',
      params: { platform: platform },
    })
  }
  setPageScaleFactor(pageScaleFactor: number): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Emulation.setPageScaleFactor',
      params: { pageScaleFactor: pageScaleFactor },
    })
  }
  setScriptExecutionDisabled(value: boolean): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Emulation.setScriptExecutionDisabled',
      params: { value: value },
    })
  }
  setTouchEmulationEnabled(
    args: Emulation.SetTouchEmulationEnabledArgs
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Emulation.setTouchEmulationEnabled',
      params: args,
    })
  }
  setVirtualTimePolicy(
    args: Emulation.SetVirtualTimePolicyArgs
  ): Promise<Emulation.SetVirtualTimePolicyResult> {
    return this.transport.call<Emulation.SetVirtualTimePolicyResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Emulation.setVirtualTimePolicy',
      params: args,
    })
  }
  setLocaleOverride(locale?: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Emulation.setLocaleOverride',
      params: { locale: locale },
    })
  }
  setTimezoneOverride(timezoneId: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Emulation.setTimezoneOverride',
      params: { timezoneId: timezoneId },
    })
  }
  setVisibleSize(args: Emulation.SetVisibleSizeArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Emulation.setVisibleSize',
      params: args,
    })
  }
  setDisabledImageTypes(
    imageTypes: Emulation.DisabledImageType[]
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Emulation.setDisabledImageTypes',
      params: { imageTypes: imageTypes },
    })
  }
  setHardwareConcurrencyOverride(hardwareConcurrency: number): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Emulation.setHardwareConcurrencyOverride',
      params: { hardwareConcurrency: hardwareConcurrency },
    })
  }
  setUserAgentOverride(
    args: Emulation.SetUserAgentOverrideArgs
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Emulation.setUserAgentOverride',
      params: args,
    })
  }
  setAutomationOverride(enabled: boolean): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Emulation.setAutomationOverride',
      params: { enabled: enabled },
    })
  }
  setSmallViewportHeightDifferenceOverride(difference: number): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Emulation.setSmallViewportHeightDifferenceOverride',
      params: { difference: difference },
    })
  }
  on<K extends keyof Emulation.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Emulation.EventMap[K]>) => void
  ): () => void {
    const filteredListener: typeof listener = (event) => {
      if (event.sessionId !== this.sessionId) {
        return
      }
      listener(event)
    }
    this.listeners.set(
      listener as ChromeEventListener,
      filteredListener as ChromeEventListener
    )
    return this.transport.on(
      'Emulation.' + name,
      listener as ChromeEventListener
    )
  }
  off<K extends keyof Emulation.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Emulation.EventMap[K]>) => void
  ): void {
    const filteredListener = this.listeners.get(listener as ChromeEventListener)
    if (filteredListener === undefined) {
      return
    }
    this.listeners.delete(listener as ChromeEventListener)
    return this.transport.off(
      'Emulation.' + name,
      listener as ChromeEventListener
    )
  }
}
class HeadlessExperimentalClient {
  transport: Transport
  sessionId: Target.SessionID | undefined
  listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  beginFrame(
    args?: HeadlessExperimental.BeginFrameArgs
  ): Promise<HeadlessExperimental.BeginFrameResult> {
    return this.transport.call<HeadlessExperimental.BeginFrameResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'HeadlessExperimental.beginFrame',
      params: args ?? {},
    })
  }
  disable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'HeadlessExperimental.disable',
      params: {},
    })
  }
  enable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'HeadlessExperimental.enable',
      params: {},
    })
  }
}
class IOClient {
  transport: Transport
  sessionId: Target.SessionID | undefined
  listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  close(handle: IO.StreamHandle): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'IO.close',
      params: { handle: handle },
    })
  }
  read(args: IO.ReadArgs): Promise<IO.ReadResult> {
    return this.transport.call<IO.ReadResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'IO.read',
      params: args,
    })
  }
  resolveBlob(objectId: Runtime.RemoteObjectId): Promise<IO.ResolveBlobResult> {
    return this.transport.call<IO.ResolveBlobResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'IO.resolveBlob',
      params: { objectId: objectId },
    })
  }
}
class FileSystemClient {
  transport: Transport
  sessionId: Target.SessionID | undefined
  listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  getDirectory(
    bucketFileSystemLocator: FileSystem.BucketFileSystemLocator
  ): Promise<FileSystem.GetDirectoryResult> {
    return this.transport.call<FileSystem.GetDirectoryResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'FileSystem.getDirectory',
      params: { bucketFileSystemLocator: bucketFileSystemLocator },
    })
  }
}
class IndexedDBClient {
  transport: Transport
  sessionId: Target.SessionID | undefined
  listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  clearObjectStore(args: IndexedDB.ClearObjectStoreArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'IndexedDB.clearObjectStore',
      params: args,
    })
  }
  deleteDatabase(args: IndexedDB.DeleteDatabaseArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'IndexedDB.deleteDatabase',
      params: args,
    })
  }
  deleteObjectStoreEntries(
    args: IndexedDB.DeleteObjectStoreEntriesArgs
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'IndexedDB.deleteObjectStoreEntries',
      params: args,
    })
  }
  disable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'IndexedDB.disable',
      params: {},
    })
  }
  enable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'IndexedDB.enable',
      params: {},
    })
  }
  requestData(
    args: IndexedDB.RequestDataArgs
  ): Promise<IndexedDB.RequestDataResult> {
    return this.transport.call<IndexedDB.RequestDataResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'IndexedDB.requestData',
      params: args,
    })
  }
  getMetadata(
    args: IndexedDB.GetMetadataArgs
  ): Promise<IndexedDB.GetMetadataResult> {
    return this.transport.call<IndexedDB.GetMetadataResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'IndexedDB.getMetadata',
      params: args,
    })
  }
  requestDatabase(
    args: IndexedDB.RequestDatabaseArgs
  ): Promise<IndexedDB.RequestDatabaseResult> {
    return this.transport.call<IndexedDB.RequestDatabaseResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'IndexedDB.requestDatabase',
      params: args,
    })
  }
  requestDatabaseNames(
    args?: IndexedDB.RequestDatabaseNamesArgs
  ): Promise<IndexedDB.RequestDatabaseNamesResult> {
    return this.transport.call<IndexedDB.RequestDatabaseNamesResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'IndexedDB.requestDatabaseNames',
      params: args ?? {},
    })
  }
}
class InputClient {
  transport: Transport
  sessionId: Target.SessionID | undefined
  listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  dispatchDragEvent(args: Input.DispatchDragEventArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Input.dispatchDragEvent',
      params: args,
    })
  }
  dispatchKeyEvent(args: Input.DispatchKeyEventArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Input.dispatchKeyEvent',
      params: args,
    })
  }
  insertText(text: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Input.insertText',
      params: { text: text },
    })
  }
  imeSetComposition(args: Input.ImeSetCompositionArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Input.imeSetComposition',
      params: args,
    })
  }
  dispatchMouseEvent(args: Input.DispatchMouseEventArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Input.dispatchMouseEvent',
      params: args,
    })
  }
  dispatchTouchEvent(args: Input.DispatchTouchEventArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Input.dispatchTouchEvent',
      params: args,
    })
  }
  cancelDragging(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Input.cancelDragging',
      params: {},
    })
  }
  emulateTouchFromMouseEvent(
    args: Input.EmulateTouchFromMouseEventArgs
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Input.emulateTouchFromMouseEvent',
      params: args,
    })
  }
  setIgnoreInputEvents(ignore: boolean): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Input.setIgnoreInputEvents',
      params: { ignore: ignore },
    })
  }
  setInterceptDrags(enabled: boolean): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Input.setInterceptDrags',
      params: { enabled: enabled },
    })
  }
  synthesizePinchGesture(
    args: Input.SynthesizePinchGestureArgs
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Input.synthesizePinchGesture',
      params: args,
    })
  }
  synthesizeScrollGesture(
    args: Input.SynthesizeScrollGestureArgs
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Input.synthesizeScrollGesture',
      params: args,
    })
  }
  synthesizeTapGesture(args: Input.SynthesizeTapGestureArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Input.synthesizeTapGesture',
      params: args,
    })
  }
  on<K extends keyof Input.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Input.EventMap[K]>) => void
  ): () => void {
    const filteredListener: typeof listener = (event) => {
      if (event.sessionId !== this.sessionId) {
        return
      }
      listener(event)
    }
    this.listeners.set(
      listener as ChromeEventListener,
      filteredListener as ChromeEventListener
    )
    return this.transport.on('Input.' + name, listener as ChromeEventListener)
  }
  off<K extends keyof Input.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Input.EventMap[K]>) => void
  ): void {
    const filteredListener = this.listeners.get(listener as ChromeEventListener)
    if (filteredListener === undefined) {
      return
    }
    this.listeners.delete(listener as ChromeEventListener)
    return this.transport.off('Input.' + name, listener as ChromeEventListener)
  }
}
class InspectorClient {
  transport: Transport
  sessionId: Target.SessionID | undefined
  listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  disable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Inspector.disable',
      params: {},
    })
  }
  enable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Inspector.enable',
      params: {},
    })
  }
  on<K extends keyof Inspector.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Inspector.EventMap[K]>) => void
  ): () => void {
    const filteredListener: typeof listener = (event) => {
      if (event.sessionId !== this.sessionId) {
        return
      }
      listener(event)
    }
    this.listeners.set(
      listener as ChromeEventListener,
      filteredListener as ChromeEventListener
    )
    return this.transport.on(
      'Inspector.' + name,
      listener as ChromeEventListener
    )
  }
  off<K extends keyof Inspector.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Inspector.EventMap[K]>) => void
  ): void {
    const filteredListener = this.listeners.get(listener as ChromeEventListener)
    if (filteredListener === undefined) {
      return
    }
    this.listeners.delete(listener as ChromeEventListener)
    return this.transport.off(
      'Inspector.' + name,
      listener as ChromeEventListener
    )
  }
}
class LayerTreeClient {
  transport: Transport
  sessionId: Target.SessionID | undefined
  listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  compositingReasons(
    layerId: LayerTree.LayerId
  ): Promise<LayerTree.CompositingReasonsResult> {
    return this.transport.call<LayerTree.CompositingReasonsResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'LayerTree.compositingReasons',
      params: { layerId: layerId },
    })
  }
  disable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'LayerTree.disable',
      params: {},
    })
  }
  enable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'LayerTree.enable',
      params: {},
    })
  }
  loadSnapshot(
    tiles: LayerTree.PictureTile[]
  ): Promise<LayerTree.LoadSnapshotResult> {
    return this.transport.call<LayerTree.LoadSnapshotResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'LayerTree.loadSnapshot',
      params: { tiles: tiles },
    })
  }
  makeSnapshot(
    layerId: LayerTree.LayerId
  ): Promise<LayerTree.MakeSnapshotResult> {
    return this.transport.call<LayerTree.MakeSnapshotResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'LayerTree.makeSnapshot',
      params: { layerId: layerId },
    })
  }
  profileSnapshot(
    args: LayerTree.ProfileSnapshotArgs
  ): Promise<LayerTree.ProfileSnapshotResult> {
    return this.transport.call<LayerTree.ProfileSnapshotResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'LayerTree.profileSnapshot',
      params: args,
    })
  }
  releaseSnapshot(snapshotId: LayerTree.SnapshotId): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'LayerTree.releaseSnapshot',
      params: { snapshotId: snapshotId },
    })
  }
  replaySnapshot(
    args: LayerTree.ReplaySnapshotArgs
  ): Promise<LayerTree.ReplaySnapshotResult> {
    return this.transport.call<LayerTree.ReplaySnapshotResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'LayerTree.replaySnapshot',
      params: args,
    })
  }
  snapshotCommandLog(
    snapshotId: LayerTree.SnapshotId
  ): Promise<LayerTree.SnapshotCommandLogResult> {
    return this.transport.call<LayerTree.SnapshotCommandLogResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'LayerTree.snapshotCommandLog',
      params: { snapshotId: snapshotId },
    })
  }
  on<K extends keyof LayerTree.EventMap>(
    name: K,
    listener: (event: ChromeEvent<LayerTree.EventMap[K]>) => void
  ): () => void {
    const filteredListener: typeof listener = (event) => {
      if (event.sessionId !== this.sessionId) {
        return
      }
      listener(event)
    }
    this.listeners.set(
      listener as ChromeEventListener,
      filteredListener as ChromeEventListener
    )
    return this.transport.on(
      'LayerTree.' + name,
      listener as ChromeEventListener
    )
  }
  off<K extends keyof LayerTree.EventMap>(
    name: K,
    listener: (event: ChromeEvent<LayerTree.EventMap[K]>) => void
  ): void {
    const filteredListener = this.listeners.get(listener as ChromeEventListener)
    if (filteredListener === undefined) {
      return
    }
    this.listeners.delete(listener as ChromeEventListener)
    return this.transport.off(
      'LayerTree.' + name,
      listener as ChromeEventListener
    )
  }
}
class LogClient {
  transport: Transport
  sessionId: Target.SessionID | undefined
  listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  clear(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Log.clear',
      params: {},
    })
  }
  disable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Log.disable',
      params: {},
    })
  }
  enable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Log.enable',
      params: {},
    })
  }
  startViolationsReport(config: Log.ViolationSetting[]): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Log.startViolationsReport',
      params: { config: config },
    })
  }
  stopViolationsReport(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Log.stopViolationsReport',
      params: {},
    })
  }
  on<K extends keyof Log.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Log.EventMap[K]>) => void
  ): () => void {
    const filteredListener: typeof listener = (event) => {
      if (event.sessionId !== this.sessionId) {
        return
      }
      listener(event)
    }
    this.listeners.set(
      listener as ChromeEventListener,
      filteredListener as ChromeEventListener
    )
    return this.transport.on('Log.' + name, listener as ChromeEventListener)
  }
  off<K extends keyof Log.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Log.EventMap[K]>) => void
  ): void {
    const filteredListener = this.listeners.get(listener as ChromeEventListener)
    if (filteredListener === undefined) {
      return
    }
    this.listeners.delete(listener as ChromeEventListener)
    return this.transport.off('Log.' + name, listener as ChromeEventListener)
  }
}
class MemoryClient {
  transport: Transport
  sessionId: Target.SessionID | undefined
  listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  getDOMCounters(): Promise<Memory.GetDOMCountersResult> {
    return this.transport.call<Memory.GetDOMCountersResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Memory.getDOMCounters',
      params: {},
    })
  }
  getDOMCountersForLeakDetection(): Promise<Memory.GetDOMCountersForLeakDetectionResult> {
    return this.transport.call<Memory.GetDOMCountersForLeakDetectionResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Memory.getDOMCountersForLeakDetection',
      params: {},
    })
  }
  prepareForLeakDetection(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Memory.prepareForLeakDetection',
      params: {},
    })
  }
  forciblyPurgeJavaScriptMemory(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Memory.forciblyPurgeJavaScriptMemory',
      params: {},
    })
  }
  setPressureNotificationsSuppressed(suppressed: boolean): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Memory.setPressureNotificationsSuppressed',
      params: { suppressed: suppressed },
    })
  }
  simulatePressureNotification(level: Memory.PressureLevel): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Memory.simulatePressureNotification',
      params: { level: level },
    })
  }
  startSampling(args?: Memory.StartSamplingArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Memory.startSampling',
      params: args ?? {},
    })
  }
  stopSampling(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Memory.stopSampling',
      params: {},
    })
  }
  getAllTimeSamplingProfile(): Promise<Memory.GetAllTimeSamplingProfileResult> {
    return this.transport.call<Memory.GetAllTimeSamplingProfileResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Memory.getAllTimeSamplingProfile',
      params: {},
    })
  }
  getBrowserSamplingProfile(): Promise<Memory.GetBrowserSamplingProfileResult> {
    return this.transport.call<Memory.GetBrowserSamplingProfileResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Memory.getBrowserSamplingProfile',
      params: {},
    })
  }
  getSamplingProfile(): Promise<Memory.GetSamplingProfileResult> {
    return this.transport.call<Memory.GetSamplingProfileResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Memory.getSamplingProfile',
      params: {},
    })
  }
}
class NetworkClient {
  transport: Transport
  sessionId: Target.SessionID | undefined
  listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  setAcceptedEncodings(encodings: Network.ContentEncoding[]): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Network.setAcceptedEncodings',
      params: { encodings: encodings },
    })
  }
  clearAcceptedEncodingsOverride(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Network.clearAcceptedEncodingsOverride',
      params: {},
    })
  }
  canClearBrowserCache(): Promise<Network.CanClearBrowserCacheResult> {
    return this.transport.call<Network.CanClearBrowserCacheResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Network.canClearBrowserCache',
      params: {},
    })
  }
  canClearBrowserCookies(): Promise<Network.CanClearBrowserCookiesResult> {
    return this.transport.call<Network.CanClearBrowserCookiesResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Network.canClearBrowserCookies',
      params: {},
    })
  }
  canEmulateNetworkConditions(): Promise<Network.CanEmulateNetworkConditionsResult> {
    return this.transport.call<Network.CanEmulateNetworkConditionsResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Network.canEmulateNetworkConditions',
      params: {},
    })
  }
  clearBrowserCache(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Network.clearBrowserCache',
      params: {},
    })
  }
  clearBrowserCookies(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Network.clearBrowserCookies',
      params: {},
    })
  }
  continueInterceptedRequest(
    args: Network.ContinueInterceptedRequestArgs
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Network.continueInterceptedRequest',
      params: args,
    })
  }
  deleteCookies(args: Network.DeleteCookiesArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Network.deleteCookies',
      params: args,
    })
  }
  disable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Network.disable',
      params: {},
    })
  }
  emulateNetworkConditions(
    args: Network.EmulateNetworkConditionsArgs
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Network.emulateNetworkConditions',
      params: args,
    })
  }
  enable(args?: Network.EnableArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Network.enable',
      params: args ?? {},
    })
  }
  getAllCookies(): Promise<Network.GetAllCookiesResult> {
    return this.transport.call<Network.GetAllCookiesResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Network.getAllCookies',
      params: {},
    })
  }
  getCertificate(origin: string): Promise<Network.GetCertificateResult> {
    return this.transport.call<Network.GetCertificateResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Network.getCertificate',
      params: { origin: origin },
    })
  }
  getCookies(urls?: string[]): Promise<Network.GetCookiesResult> {
    return this.transport.call<Network.GetCookiesResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Network.getCookies',
      params: { urls: urls },
    })
  }
  getResponseBody(
    requestId: Network.RequestId
  ): Promise<Network.GetResponseBodyResult> {
    return this.transport.call<Network.GetResponseBodyResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Network.getResponseBody',
      params: { requestId: requestId },
    })
  }
  getRequestPostData(
    requestId: Network.RequestId
  ): Promise<Network.GetRequestPostDataResult> {
    return this.transport.call<Network.GetRequestPostDataResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Network.getRequestPostData',
      params: { requestId: requestId },
    })
  }
  getResponseBodyForInterception(
    interceptionId: Network.InterceptionId
  ): Promise<Network.GetResponseBodyForInterceptionResult> {
    return this.transport.call<Network.GetResponseBodyForInterceptionResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Network.getResponseBodyForInterception',
      params: { interceptionId: interceptionId },
    })
  }
  takeResponseBodyForInterceptionAsStream(
    interceptionId: Network.InterceptionId
  ): Promise<Network.TakeResponseBodyForInterceptionAsStreamResult> {
    return this.transport.call<Network.TakeResponseBodyForInterceptionAsStreamResult>(
      {
        id: generateId(),
        sessionId: this.sessionId,
        method: 'Network.takeResponseBodyForInterceptionAsStream',
        params: { interceptionId: interceptionId },
      }
    )
  }
  replayXHR(requestId: Network.RequestId): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Network.replayXHR',
      params: { requestId: requestId },
    })
  }
  searchInResponseBody(
    args: Network.SearchInResponseBodyArgs
  ): Promise<Network.SearchInResponseBodyResult> {
    return this.transport.call<Network.SearchInResponseBodyResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Network.searchInResponseBody',
      params: args,
    })
  }
  setBlockedURLs(urls: string[]): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Network.setBlockedURLs',
      params: { urls: urls },
    })
  }
  setBypassServiceWorker(bypass: boolean): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Network.setBypassServiceWorker',
      params: { bypass: bypass },
    })
  }
  setCacheDisabled(cacheDisabled: boolean): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Network.setCacheDisabled',
      params: { cacheDisabled: cacheDisabled },
    })
  }
  setCookie(args: Network.SetCookieArgs): Promise<Network.SetCookieResult> {
    return this.transport.call<Network.SetCookieResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Network.setCookie',
      params: args,
    })
  }
  setCookies(cookies: Network.CookieParam[]): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Network.setCookies',
      params: { cookies: cookies },
    })
  }
  setExtraHTTPHeaders(headers: Network.Headers): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Network.setExtraHTTPHeaders',
      params: { headers: headers },
    })
  }
  setAttachDebugStack(enabled: boolean): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Network.setAttachDebugStack',
      params: { enabled: enabled },
    })
  }
  setRequestInterception(patterns: Network.RequestPattern[]): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Network.setRequestInterception',
      params: { patterns: patterns },
    })
  }
  setUserAgentOverride(args: Network.SetUserAgentOverrideArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Network.setUserAgentOverride',
      params: args,
    })
  }
  streamResourceContent(
    requestId: Network.RequestId
  ): Promise<Network.StreamResourceContentResult> {
    return this.transport.call<Network.StreamResourceContentResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Network.streamResourceContent',
      params: { requestId: requestId },
    })
  }
  getSecurityIsolationStatus(
    frameId?: Page.FrameId
  ): Promise<Network.GetSecurityIsolationStatusResult> {
    return this.transport.call<Network.GetSecurityIsolationStatusResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Network.getSecurityIsolationStatus',
      params: { frameId: frameId },
    })
  }
  enableReportingApi(enable: boolean): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Network.enableReportingApi',
      params: { enable: enable },
    })
  }
  loadNetworkResource(
    args: Network.LoadNetworkResourceArgs
  ): Promise<Network.LoadNetworkResourceResult> {
    return this.transport.call<Network.LoadNetworkResourceResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Network.loadNetworkResource',
      params: args,
    })
  }
  setCookieControls(args: Network.SetCookieControlsArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Network.setCookieControls',
      params: args,
    })
  }
  on<K extends keyof Network.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Network.EventMap[K]>) => void
  ): () => void {
    const filteredListener: typeof listener = (event) => {
      if (event.sessionId !== this.sessionId) {
        return
      }
      listener(event)
    }
    this.listeners.set(
      listener as ChromeEventListener,
      filteredListener as ChromeEventListener
    )
    return this.transport.on('Network.' + name, listener as ChromeEventListener)
  }
  off<K extends keyof Network.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Network.EventMap[K]>) => void
  ): void {
    const filteredListener = this.listeners.get(listener as ChromeEventListener)
    if (filteredListener === undefined) {
      return
    }
    this.listeners.delete(listener as ChromeEventListener)
    return this.transport.off(
      'Network.' + name,
      listener as ChromeEventListener
    )
  }
}
class OverlayClient {
  transport: Transport
  sessionId: Target.SessionID | undefined
  listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  disable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Overlay.disable',
      params: {},
    })
  }
  enable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Overlay.enable',
      params: {},
    })
  }
  getHighlightObjectForTest(
    args: Overlay.GetHighlightObjectForTestArgs
  ): Promise<Overlay.GetHighlightObjectForTestResult> {
    return this.transport.call<Overlay.GetHighlightObjectForTestResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Overlay.getHighlightObjectForTest',
      params: args,
    })
  }
  getGridHighlightObjectsForTest(
    nodeIds: DOM.NodeId[]
  ): Promise<Overlay.GetGridHighlightObjectsForTestResult> {
    return this.transport.call<Overlay.GetGridHighlightObjectsForTestResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Overlay.getGridHighlightObjectsForTest',
      params: { nodeIds: nodeIds },
    })
  }
  getSourceOrderHighlightObjectForTest(
    nodeId: DOM.NodeId
  ): Promise<Overlay.GetSourceOrderHighlightObjectForTestResult> {
    return this.transport.call<Overlay.GetSourceOrderHighlightObjectForTestResult>(
      {
        id: generateId(),
        sessionId: this.sessionId,
        method: 'Overlay.getSourceOrderHighlightObjectForTest',
        params: { nodeId: nodeId },
      }
    )
  }
  hideHighlight(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Overlay.hideHighlight',
      params: {},
    })
  }
  highlightFrame(args: Overlay.HighlightFrameArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Overlay.highlightFrame',
      params: args,
    })
  }
  highlightNode(args: Overlay.HighlightNodeArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Overlay.highlightNode',
      params: args,
    })
  }
  highlightQuad(args: Overlay.HighlightQuadArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Overlay.highlightQuad',
      params: args,
    })
  }
  highlightRect(args: Overlay.HighlightRectArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Overlay.highlightRect',
      params: args,
    })
  }
  highlightSourceOrder(args: Overlay.HighlightSourceOrderArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Overlay.highlightSourceOrder',
      params: args,
    })
  }
  setInspectMode(args: Overlay.SetInspectModeArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Overlay.setInspectMode',
      params: args,
    })
  }
  setShowAdHighlights(show: boolean): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Overlay.setShowAdHighlights',
      params: { show: show },
    })
  }
  setPausedInDebuggerMessage(message?: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Overlay.setPausedInDebuggerMessage',
      params: { message: message },
    })
  }
  setShowDebugBorders(show: boolean): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Overlay.setShowDebugBorders',
      params: { show: show },
    })
  }
  setShowFPSCounter(show: boolean): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Overlay.setShowFPSCounter',
      params: { show: show },
    })
  }
  setShowGridOverlays(
    gridNodeHighlightConfigs: Overlay.GridNodeHighlightConfig[]
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Overlay.setShowGridOverlays',
      params: { gridNodeHighlightConfigs: gridNodeHighlightConfigs },
    })
  }
  setShowFlexOverlays(
    flexNodeHighlightConfigs: Overlay.FlexNodeHighlightConfig[]
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Overlay.setShowFlexOverlays',
      params: { flexNodeHighlightConfigs: flexNodeHighlightConfigs },
    })
  }
  setShowScrollSnapOverlays(
    scrollSnapHighlightConfigs: Overlay.ScrollSnapHighlightConfig[]
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Overlay.setShowScrollSnapOverlays',
      params: { scrollSnapHighlightConfigs: scrollSnapHighlightConfigs },
    })
  }
  setShowContainerQueryOverlays(
    containerQueryHighlightConfigs: Overlay.ContainerQueryHighlightConfig[]
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Overlay.setShowContainerQueryOverlays',
      params: {
        containerQueryHighlightConfigs: containerQueryHighlightConfigs,
      },
    })
  }
  setShowPaintRects(result: boolean): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Overlay.setShowPaintRects',
      params: { result: result },
    })
  }
  setShowLayoutShiftRegions(result: boolean): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Overlay.setShowLayoutShiftRegions',
      params: { result: result },
    })
  }
  setShowScrollBottleneckRects(show: boolean): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Overlay.setShowScrollBottleneckRects',
      params: { show: show },
    })
  }
  setShowHitTestBorders(show: boolean): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Overlay.setShowHitTestBorders',
      params: { show: show },
    })
  }
  setShowWebVitals(show: boolean): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Overlay.setShowWebVitals',
      params: { show: show },
    })
  }
  setShowViewportSizeOnResize(show: boolean): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Overlay.setShowViewportSizeOnResize',
      params: { show: show },
    })
  }
  setShowHinge(hingeConfig?: Overlay.HingeConfig): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Overlay.setShowHinge',
      params: { hingeConfig: hingeConfig },
    })
  }
  setShowIsolatedElements(
    isolatedElementHighlightConfigs: Overlay.IsolatedElementHighlightConfig[]
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Overlay.setShowIsolatedElements',
      params: {
        isolatedElementHighlightConfigs: isolatedElementHighlightConfigs,
      },
    })
  }
  setShowWindowControlsOverlay(
    windowControlsOverlayConfig?: Overlay.WindowControlsOverlayConfig
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Overlay.setShowWindowControlsOverlay',
      params: { windowControlsOverlayConfig: windowControlsOverlayConfig },
    })
  }
  on<K extends keyof Overlay.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Overlay.EventMap[K]>) => void
  ): () => void {
    const filteredListener: typeof listener = (event) => {
      if (event.sessionId !== this.sessionId) {
        return
      }
      listener(event)
    }
    this.listeners.set(
      listener as ChromeEventListener,
      filteredListener as ChromeEventListener
    )
    return this.transport.on('Overlay.' + name, listener as ChromeEventListener)
  }
  off<K extends keyof Overlay.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Overlay.EventMap[K]>) => void
  ): void {
    const filteredListener = this.listeners.get(listener as ChromeEventListener)
    if (filteredListener === undefined) {
      return
    }
    this.listeners.delete(listener as ChromeEventListener)
    return this.transport.off(
      'Overlay.' + name,
      listener as ChromeEventListener
    )
  }
}
class PageClient {
  transport: Transport
  sessionId: Target.SessionID | undefined
  listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  addScriptToEvaluateOnLoad(
    scriptSource: string
  ): Promise<Page.AddScriptToEvaluateOnLoadResult> {
    return this.transport.call<Page.AddScriptToEvaluateOnLoadResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.addScriptToEvaluateOnLoad',
      params: { scriptSource: scriptSource },
    })
  }
  addScriptToEvaluateOnNewDocument(
    args: Page.AddScriptToEvaluateOnNewDocumentArgs
  ): Promise<Page.AddScriptToEvaluateOnNewDocumentResult> {
    return this.transport.call<Page.AddScriptToEvaluateOnNewDocumentResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.addScriptToEvaluateOnNewDocument',
      params: args,
    })
  }
  bringToFront(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.bringToFront',
      params: {},
    })
  }
  captureScreenshot(
    args?: Page.CaptureScreenshotArgs
  ): Promise<Page.CaptureScreenshotResult> {
    return this.transport.call<Page.CaptureScreenshotResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.captureScreenshot',
      params: args ?? {},
    })
  }
  captureSnapshot(format?: 'mhtml'): Promise<Page.CaptureSnapshotResult> {
    return this.transport.call<Page.CaptureSnapshotResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.captureSnapshot',
      params: { format: format },
    })
  }
  clearDeviceMetricsOverride(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.clearDeviceMetricsOverride',
      params: {},
    })
  }
  clearDeviceOrientationOverride(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.clearDeviceOrientationOverride',
      params: {},
    })
  }
  clearGeolocationOverride(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.clearGeolocationOverride',
      params: {},
    })
  }
  createIsolatedWorld(
    args: Page.CreateIsolatedWorldArgs
  ): Promise<Page.CreateIsolatedWorldResult> {
    return this.transport.call<Page.CreateIsolatedWorldResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.createIsolatedWorld',
      params: args,
    })
  }
  deleteCookie(args: Page.DeleteCookieArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.deleteCookie',
      params: args,
    })
  }
  disable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.disable',
      params: {},
    })
  }
  enable(enableFileChooserOpenedEvent?: boolean): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.enable',
      params: { enableFileChooserOpenedEvent: enableFileChooserOpenedEvent },
    })
  }
  getAppManifest(manifestId?: string): Promise<Page.GetAppManifestResult> {
    return this.transport.call<Page.GetAppManifestResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.getAppManifest',
      params: { manifestId: manifestId },
    })
  }
  getInstallabilityErrors(): Promise<Page.GetInstallabilityErrorsResult> {
    return this.transport.call<Page.GetInstallabilityErrorsResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.getInstallabilityErrors',
      params: {},
    })
  }
  getManifestIcons(): Promise<Page.GetManifestIconsResult> {
    return this.transport.call<Page.GetManifestIconsResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.getManifestIcons',
      params: {},
    })
  }
  getAppId(): Promise<Page.GetAppIdResult> {
    return this.transport.call<Page.GetAppIdResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.getAppId',
      params: {},
    })
  }
  getAdScriptAncestry(
    frameId: Page.FrameId
  ): Promise<Page.GetAdScriptAncestryResult> {
    return this.transport.call<Page.GetAdScriptAncestryResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.getAdScriptAncestry',
      params: { frameId: frameId },
    })
  }
  getFrameTree(): Promise<Page.GetFrameTreeResult> {
    return this.transport.call<Page.GetFrameTreeResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.getFrameTree',
      params: {},
    })
  }
  getLayoutMetrics(): Promise<Page.GetLayoutMetricsResult> {
    return this.transport.call<Page.GetLayoutMetricsResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.getLayoutMetrics',
      params: {},
    })
  }
  getNavigationHistory(): Promise<Page.GetNavigationHistoryResult> {
    return this.transport.call<Page.GetNavigationHistoryResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.getNavigationHistory',
      params: {},
    })
  }
  resetNavigationHistory(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.resetNavigationHistory',
      params: {},
    })
  }
  getResourceContent(
    args: Page.GetResourceContentArgs
  ): Promise<Page.GetResourceContentResult> {
    return this.transport.call<Page.GetResourceContentResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.getResourceContent',
      params: args,
    })
  }
  getResourceTree(): Promise<Page.GetResourceTreeResult> {
    return this.transport.call<Page.GetResourceTreeResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.getResourceTree',
      params: {},
    })
  }
  handleJavaScriptDialog(args: Page.HandleJavaScriptDialogArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.handleJavaScriptDialog',
      params: args,
    })
  }
  navigate(args: Page.NavigateArgs): Promise<Page.NavigateResult> {
    return this.transport.call<Page.NavigateResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.navigate',
      params: args,
    })
  }
  navigateToHistoryEntry(entryId: number): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.navigateToHistoryEntry',
      params: { entryId: entryId },
    })
  }
  printToPDF(args?: Page.PrintToPDFArgs): Promise<Page.PrintToPDFResult> {
    return this.transport.call<Page.PrintToPDFResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.printToPDF',
      params: args ?? {},
    })
  }
  reload(args?: Page.ReloadArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.reload',
      params: args ?? {},
    })
  }
  removeScriptToEvaluateOnLoad(
    identifier: Page.ScriptIdentifier
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.removeScriptToEvaluateOnLoad',
      params: { identifier: identifier },
    })
  }
  removeScriptToEvaluateOnNewDocument(
    identifier: Page.ScriptIdentifier
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.removeScriptToEvaluateOnNewDocument',
      params: { identifier: identifier },
    })
  }
  screencastFrameAck(sessionId: number): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.screencastFrameAck',
      params: { sessionId: sessionId },
    })
  }
  searchInResource(
    args: Page.SearchInResourceArgs
  ): Promise<Page.SearchInResourceResult> {
    return this.transport.call<Page.SearchInResourceResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.searchInResource',
      params: args,
    })
  }
  setAdBlockingEnabled(enabled: boolean): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.setAdBlockingEnabled',
      params: { enabled: enabled },
    })
  }
  setBypassCSP(enabled: boolean): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.setBypassCSP',
      params: { enabled: enabled },
    })
  }
  getPermissionsPolicyState(
    frameId: Page.FrameId
  ): Promise<Page.GetPermissionsPolicyStateResult> {
    return this.transport.call<Page.GetPermissionsPolicyStateResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.getPermissionsPolicyState',
      params: { frameId: frameId },
    })
  }
  getOriginTrials(frameId: Page.FrameId): Promise<Page.GetOriginTrialsResult> {
    return this.transport.call<Page.GetOriginTrialsResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.getOriginTrials',
      params: { frameId: frameId },
    })
  }
  setDeviceMetricsOverride(
    args: Page.SetDeviceMetricsOverrideArgs
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.setDeviceMetricsOverride',
      params: args,
    })
  }
  setDeviceOrientationOverride(
    args: Page.SetDeviceOrientationOverrideArgs
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.setDeviceOrientationOverride',
      params: args,
    })
  }
  setFontFamilies(args: Page.SetFontFamiliesArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.setFontFamilies',
      params: args,
    })
  }
  setFontSizes(fontSizes: Page.FontSizes): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.setFontSizes',
      params: { fontSizes: fontSizes },
    })
  }
  setDocumentContent(args: Page.SetDocumentContentArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.setDocumentContent',
      params: args,
    })
  }
  setDownloadBehavior(args: Page.SetDownloadBehaviorArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.setDownloadBehavior',
      params: args,
    })
  }
  setGeolocationOverride(
    args?: Page.SetGeolocationOverrideArgs
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.setGeolocationOverride',
      params: args ?? {},
    })
  }
  setLifecycleEventsEnabled(enabled: boolean): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.setLifecycleEventsEnabled',
      params: { enabled: enabled },
    })
  }
  setTouchEmulationEnabled(
    args: Page.SetTouchEmulationEnabledArgs
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.setTouchEmulationEnabled',
      params: args,
    })
  }
  startScreencast(args?: Page.StartScreencastArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.startScreencast',
      params: args ?? {},
    })
  }
  stopLoading(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.stopLoading',
      params: {},
    })
  }
  crash(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.crash',
      params: {},
    })
  }
  close(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.close',
      params: {},
    })
  }
  setWebLifecycleState(state: 'frozen' | 'active'): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.setWebLifecycleState',
      params: { state: state },
    })
  }
  stopScreencast(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.stopScreencast',
      params: {},
    })
  }
  produceCompilationCache(
    scripts: Page.CompilationCacheParams[]
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.produceCompilationCache',
      params: { scripts: scripts },
    })
  }
  addCompilationCache(args: Page.AddCompilationCacheArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.addCompilationCache',
      params: args,
    })
  }
  clearCompilationCache(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.clearCompilationCache',
      params: {},
    })
  }
  setSPCTransactionMode(mode: Page.AutoResponseMode): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.setSPCTransactionMode',
      params: { mode: mode },
    })
  }
  setRPHRegistrationMode(mode: Page.AutoResponseMode): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.setRPHRegistrationMode',
      params: { mode: mode },
    })
  }
  generateTestReport(args: Page.GenerateTestReportArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.generateTestReport',
      params: args,
    })
  }
  waitForDebugger(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.waitForDebugger',
      params: {},
    })
  }
  setInterceptFileChooserDialog(
    args: Page.SetInterceptFileChooserDialogArgs
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.setInterceptFileChooserDialog',
      params: args,
    })
  }
  setPrerenderingAllowed(isAllowed: boolean): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.setPrerenderingAllowed',
      params: { isAllowed: isAllowed },
    })
  }
  on<K extends keyof Page.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Page.EventMap[K]>) => void
  ): () => void {
    const filteredListener: typeof listener = (event) => {
      if (event.sessionId !== this.sessionId) {
        return
      }
      listener(event)
    }
    this.listeners.set(
      listener as ChromeEventListener,
      filteredListener as ChromeEventListener
    )
    return this.transport.on('Page.' + name, listener as ChromeEventListener)
  }
  off<K extends keyof Page.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Page.EventMap[K]>) => void
  ): void {
    const filteredListener = this.listeners.get(listener as ChromeEventListener)
    if (filteredListener === undefined) {
      return
    }
    this.listeners.delete(listener as ChromeEventListener)
    return this.transport.off('Page.' + name, listener as ChromeEventListener)
  }
}
class PerformanceClient {
  transport: Transport
  sessionId: Target.SessionID | undefined
  listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  disable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Performance.disable',
      params: {},
    })
  }
  enable(timeDomain?: 'timeTicks' | 'threadTicks'): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Performance.enable',
      params: { timeDomain: timeDomain },
    })
  }
  setTimeDomain(timeDomain: 'timeTicks' | 'threadTicks'): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Performance.setTimeDomain',
      params: { timeDomain: timeDomain },
    })
  }
  getMetrics(): Promise<Performance.GetMetricsResult> {
    return this.transport.call<Performance.GetMetricsResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Performance.getMetrics',
      params: {},
    })
  }
  on<K extends keyof Performance.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Performance.EventMap[K]>) => void
  ): () => void {
    const filteredListener: typeof listener = (event) => {
      if (event.sessionId !== this.sessionId) {
        return
      }
      listener(event)
    }
    this.listeners.set(
      listener as ChromeEventListener,
      filteredListener as ChromeEventListener
    )
    return this.transport.on(
      'Performance.' + name,
      listener as ChromeEventListener
    )
  }
  off<K extends keyof Performance.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Performance.EventMap[K]>) => void
  ): void {
    const filteredListener = this.listeners.get(listener as ChromeEventListener)
    if (filteredListener === undefined) {
      return
    }
    this.listeners.delete(listener as ChromeEventListener)
    return this.transport.off(
      'Performance.' + name,
      listener as ChromeEventListener
    )
  }
}
class PerformanceTimelineClient {
  transport: Transport
  sessionId: Target.SessionID | undefined
  listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  enable(eventTypes: string[]): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'PerformanceTimeline.enable',
      params: { eventTypes: eventTypes },
    })
  }
  on<K extends keyof PerformanceTimeline.EventMap>(
    name: K,
    listener: (event: ChromeEvent<PerformanceTimeline.EventMap[K]>) => void
  ): () => void {
    const filteredListener: typeof listener = (event) => {
      if (event.sessionId !== this.sessionId) {
        return
      }
      listener(event)
    }
    this.listeners.set(
      listener as ChromeEventListener,
      filteredListener as ChromeEventListener
    )
    return this.transport.on(
      'PerformanceTimeline.' + name,
      listener as ChromeEventListener
    )
  }
  off<K extends keyof PerformanceTimeline.EventMap>(
    name: K,
    listener: (event: ChromeEvent<PerformanceTimeline.EventMap[K]>) => void
  ): void {
    const filteredListener = this.listeners.get(listener as ChromeEventListener)
    if (filteredListener === undefined) {
      return
    }
    this.listeners.delete(listener as ChromeEventListener)
    return this.transport.off(
      'PerformanceTimeline.' + name,
      listener as ChromeEventListener
    )
  }
}
class SecurityClient {
  transport: Transport
  sessionId: Target.SessionID | undefined
  listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  disable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Security.disable',
      params: {},
    })
  }
  enable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Security.enable',
      params: {},
    })
  }
  setIgnoreCertificateErrors(ignore: boolean): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Security.setIgnoreCertificateErrors',
      params: { ignore: ignore },
    })
  }
  handleCertificateError(
    args: Security.HandleCertificateErrorArgs
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Security.handleCertificateError',
      params: args,
    })
  }
  setOverrideCertificateErrors(override: boolean): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Security.setOverrideCertificateErrors',
      params: { override: override },
    })
  }
  on<K extends keyof Security.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Security.EventMap[K]>) => void
  ): () => void {
    const filteredListener: typeof listener = (event) => {
      if (event.sessionId !== this.sessionId) {
        return
      }
      listener(event)
    }
    this.listeners.set(
      listener as ChromeEventListener,
      filteredListener as ChromeEventListener
    )
    return this.transport.on(
      'Security.' + name,
      listener as ChromeEventListener
    )
  }
  off<K extends keyof Security.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Security.EventMap[K]>) => void
  ): void {
    const filteredListener = this.listeners.get(listener as ChromeEventListener)
    if (filteredListener === undefined) {
      return
    }
    this.listeners.delete(listener as ChromeEventListener)
    return this.transport.off(
      'Security.' + name,
      listener as ChromeEventListener
    )
  }
}
class ServiceWorkerClient {
  transport: Transport
  sessionId: Target.SessionID | undefined
  listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  deliverPushMessage(
    args: ServiceWorker.DeliverPushMessageArgs
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'ServiceWorker.deliverPushMessage',
      params: args,
    })
  }
  disable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'ServiceWorker.disable',
      params: {},
    })
  }
  dispatchSyncEvent(args: ServiceWorker.DispatchSyncEventArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'ServiceWorker.dispatchSyncEvent',
      params: args,
    })
  }
  dispatchPeriodicSyncEvent(
    args: ServiceWorker.DispatchPeriodicSyncEventArgs
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'ServiceWorker.dispatchPeriodicSyncEvent',
      params: args,
    })
  }
  enable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'ServiceWorker.enable',
      params: {},
    })
  }
  inspectWorker(versionId: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'ServiceWorker.inspectWorker',
      params: { versionId: versionId },
    })
  }
  setForceUpdateOnPageLoad(forceUpdateOnPageLoad: boolean): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'ServiceWorker.setForceUpdateOnPageLoad',
      params: { forceUpdateOnPageLoad: forceUpdateOnPageLoad },
    })
  }
  skipWaiting(scopeURL: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'ServiceWorker.skipWaiting',
      params: { scopeURL: scopeURL },
    })
  }
  startWorker(scopeURL: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'ServiceWorker.startWorker',
      params: { scopeURL: scopeURL },
    })
  }
  stopAllWorkers(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'ServiceWorker.stopAllWorkers',
      params: {},
    })
  }
  stopWorker(versionId: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'ServiceWorker.stopWorker',
      params: { versionId: versionId },
    })
  }
  unregister(scopeURL: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'ServiceWorker.unregister',
      params: { scopeURL: scopeURL },
    })
  }
  updateRegistration(scopeURL: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'ServiceWorker.updateRegistration',
      params: { scopeURL: scopeURL },
    })
  }
  on<K extends keyof ServiceWorker.EventMap>(
    name: K,
    listener: (event: ChromeEvent<ServiceWorker.EventMap[K]>) => void
  ): () => void {
    const filteredListener: typeof listener = (event) => {
      if (event.sessionId !== this.sessionId) {
        return
      }
      listener(event)
    }
    this.listeners.set(
      listener as ChromeEventListener,
      filteredListener as ChromeEventListener
    )
    return this.transport.on(
      'ServiceWorker.' + name,
      listener as ChromeEventListener
    )
  }
  off<K extends keyof ServiceWorker.EventMap>(
    name: K,
    listener: (event: ChromeEvent<ServiceWorker.EventMap[K]>) => void
  ): void {
    const filteredListener = this.listeners.get(listener as ChromeEventListener)
    if (filteredListener === undefined) {
      return
    }
    this.listeners.delete(listener as ChromeEventListener)
    return this.transport.off(
      'ServiceWorker.' + name,
      listener as ChromeEventListener
    )
  }
}
class StorageClient {
  transport: Transport
  sessionId: Target.SessionID | undefined
  listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  getStorageKeyForFrame(
    frameId: Page.FrameId
  ): Promise<Storage.GetStorageKeyForFrameResult> {
    return this.transport.call<Storage.GetStorageKeyForFrameResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Storage.getStorageKeyForFrame',
      params: { frameId: frameId },
    })
  }
  clearDataForOrigin(args: Storage.ClearDataForOriginArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Storage.clearDataForOrigin',
      params: args,
    })
  }
  clearDataForStorageKey(
    args: Storage.ClearDataForStorageKeyArgs
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Storage.clearDataForStorageKey',
      params: args,
    })
  }
  getCookies(
    browserContextId?: Browser.BrowserContextID
  ): Promise<Storage.GetCookiesResult> {
    return this.transport.call<Storage.GetCookiesResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Storage.getCookies',
      params: { browserContextId: browserContextId },
    })
  }
  setCookies(args: Storage.SetCookiesArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Storage.setCookies',
      params: args,
    })
  }
  clearCookies(browserContextId?: Browser.BrowserContextID): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Storage.clearCookies',
      params: { browserContextId: browserContextId },
    })
  }
  getUsageAndQuota(origin: string): Promise<Storage.GetUsageAndQuotaResult> {
    return this.transport.call<Storage.GetUsageAndQuotaResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Storage.getUsageAndQuota',
      params: { origin: origin },
    })
  }
  overrideQuotaForOrigin(
    args: Storage.OverrideQuotaForOriginArgs
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Storage.overrideQuotaForOrigin',
      params: args,
    })
  }
  trackCacheStorageForOrigin(origin: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Storage.trackCacheStorageForOrigin',
      params: { origin: origin },
    })
  }
  trackCacheStorageForStorageKey(storageKey: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Storage.trackCacheStorageForStorageKey',
      params: { storageKey: storageKey },
    })
  }
  trackIndexedDBForOrigin(origin: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Storage.trackIndexedDBForOrigin',
      params: { origin: origin },
    })
  }
  trackIndexedDBForStorageKey(storageKey: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Storage.trackIndexedDBForStorageKey',
      params: { storageKey: storageKey },
    })
  }
  untrackCacheStorageForOrigin(origin: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Storage.untrackCacheStorageForOrigin',
      params: { origin: origin },
    })
  }
  untrackCacheStorageForStorageKey(storageKey: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Storage.untrackCacheStorageForStorageKey',
      params: { storageKey: storageKey },
    })
  }
  untrackIndexedDBForOrigin(origin: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Storage.untrackIndexedDBForOrigin',
      params: { origin: origin },
    })
  }
  untrackIndexedDBForStorageKey(storageKey: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Storage.untrackIndexedDBForStorageKey',
      params: { storageKey: storageKey },
    })
  }
  getTrustTokens(): Promise<Storage.GetTrustTokensResult> {
    return this.transport.call<Storage.GetTrustTokensResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Storage.getTrustTokens',
      params: {},
    })
  }
  clearTrustTokens(
    issuerOrigin: string
  ): Promise<Storage.ClearTrustTokensResult> {
    return this.transport.call<Storage.ClearTrustTokensResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Storage.clearTrustTokens',
      params: { issuerOrigin: issuerOrigin },
    })
  }
  getInterestGroupDetails(
    args: Storage.GetInterestGroupDetailsArgs
  ): Promise<Storage.GetInterestGroupDetailsResult> {
    return this.transport.call<Storage.GetInterestGroupDetailsResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Storage.getInterestGroupDetails',
      params: args,
    })
  }
  setInterestGroupTracking(enable: boolean): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Storage.setInterestGroupTracking',
      params: { enable: enable },
    })
  }
  setInterestGroupAuctionTracking(enable: boolean): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Storage.setInterestGroupAuctionTracking',
      params: { enable: enable },
    })
  }
  getSharedStorageMetadata(
    ownerOrigin: string
  ): Promise<Storage.GetSharedStorageMetadataResult> {
    return this.transport.call<Storage.GetSharedStorageMetadataResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Storage.getSharedStorageMetadata',
      params: { ownerOrigin: ownerOrigin },
    })
  }
  getSharedStorageEntries(
    ownerOrigin: string
  ): Promise<Storage.GetSharedStorageEntriesResult> {
    return this.transport.call<Storage.GetSharedStorageEntriesResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Storage.getSharedStorageEntries',
      params: { ownerOrigin: ownerOrigin },
    })
  }
  setSharedStorageEntry(
    args: Storage.SetSharedStorageEntryArgs
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Storage.setSharedStorageEntry',
      params: args,
    })
  }
  deleteSharedStorageEntry(
    args: Storage.DeleteSharedStorageEntryArgs
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Storage.deleteSharedStorageEntry',
      params: args,
    })
  }
  clearSharedStorageEntries(ownerOrigin: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Storage.clearSharedStorageEntries',
      params: { ownerOrigin: ownerOrigin },
    })
  }
  resetSharedStorageBudget(ownerOrigin: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Storage.resetSharedStorageBudget',
      params: { ownerOrigin: ownerOrigin },
    })
  }
  setSharedStorageTracking(enable: boolean): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Storage.setSharedStorageTracking',
      params: { enable: enable },
    })
  }
  setStorageBucketTracking(
    args: Storage.SetStorageBucketTrackingArgs
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Storage.setStorageBucketTracking',
      params: args,
    })
  }
  deleteStorageBucket(bucket: Storage.StorageBucket): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Storage.deleteStorageBucket',
      params: { bucket: bucket },
    })
  }
  runBounceTrackingMitigations(): Promise<Storage.RunBounceTrackingMitigationsResult> {
    return this.transport.call<Storage.RunBounceTrackingMitigationsResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Storage.runBounceTrackingMitigations',
      params: {},
    })
  }
  setAttributionReportingLocalTestingMode(enabled: boolean): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Storage.setAttributionReportingLocalTestingMode',
      params: { enabled: enabled },
    })
  }
  setAttributionReportingTracking(enable: boolean): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Storage.setAttributionReportingTracking',
      params: { enable: enable },
    })
  }
  sendPendingAttributionReports(): Promise<Storage.SendPendingAttributionReportsResult> {
    return this.transport.call<Storage.SendPendingAttributionReportsResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Storage.sendPendingAttributionReports',
      params: {},
    })
  }
  getRelatedWebsiteSets(): Promise<Storage.GetRelatedWebsiteSetsResult> {
    return this.transport.call<Storage.GetRelatedWebsiteSetsResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Storage.getRelatedWebsiteSets',
      params: {},
    })
  }
  getAffectedUrlsForThirdPartyCookieMetadata(
    args: Storage.GetAffectedUrlsForThirdPartyCookieMetadataArgs
  ): Promise<Storage.GetAffectedUrlsForThirdPartyCookieMetadataResult> {
    return this.transport.call<Storage.GetAffectedUrlsForThirdPartyCookieMetadataResult>(
      {
        id: generateId(),
        sessionId: this.sessionId,
        method: 'Storage.getAffectedUrlsForThirdPartyCookieMetadata',
        params: args,
      }
    )
  }
  setProtectedAudienceKAnonymity(
    args: Storage.SetProtectedAudienceKAnonymityArgs
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Storage.setProtectedAudienceKAnonymity',
      params: args,
    })
  }
  on<K extends keyof Storage.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Storage.EventMap[K]>) => void
  ): () => void {
    const filteredListener: typeof listener = (event) => {
      if (event.sessionId !== this.sessionId) {
        return
      }
      listener(event)
    }
    this.listeners.set(
      listener as ChromeEventListener,
      filteredListener as ChromeEventListener
    )
    return this.transport.on('Storage.' + name, listener as ChromeEventListener)
  }
  off<K extends keyof Storage.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Storage.EventMap[K]>) => void
  ): void {
    const filteredListener = this.listeners.get(listener as ChromeEventListener)
    if (filteredListener === undefined) {
      return
    }
    this.listeners.delete(listener as ChromeEventListener)
    return this.transport.off(
      'Storage.' + name,
      listener as ChromeEventListener
    )
  }
}
class SystemInfoClient {
  transport: Transport
  sessionId: Target.SessionID | undefined
  listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  getInfo(): Promise<SystemInfo.GetInfoResult> {
    return this.transport.call<SystemInfo.GetInfoResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'SystemInfo.getInfo',
      params: {},
    })
  }
  getFeatureState(
    featureState: string
  ): Promise<SystemInfo.GetFeatureStateResult> {
    return this.transport.call<SystemInfo.GetFeatureStateResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'SystemInfo.getFeatureState',
      params: { featureState: featureState },
    })
  }
  getProcessInfo(): Promise<SystemInfo.GetProcessInfoResult> {
    return this.transport.call<SystemInfo.GetProcessInfoResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'SystemInfo.getProcessInfo',
      params: {},
    })
  }
}
class TargetClient {
  transport: Transport
  sessionId: Target.SessionID | undefined
  listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  activateTarget(targetId: Target.TargetID): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Target.activateTarget',
      params: { targetId: targetId },
    })
  }
  attachToTarget(
    args: Target.AttachToTargetArgs
  ): Promise<Target.AttachToTargetResult> {
    return this.transport.call<Target.AttachToTargetResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Target.attachToTarget',
      params: args,
    })
  }
  attachToBrowserTarget(): Promise<Target.AttachToBrowserTargetResult> {
    return this.transport.call<Target.AttachToBrowserTargetResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Target.attachToBrowserTarget',
      params: {},
    })
  }
  closeTarget(targetId: Target.TargetID): Promise<Target.CloseTargetResult> {
    return this.transport.call<Target.CloseTargetResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Target.closeTarget',
      params: { targetId: targetId },
    })
  }
  exposeDevToolsProtocol(
    args: Target.ExposeDevToolsProtocolArgs
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Target.exposeDevToolsProtocol',
      params: args,
    })
  }
  createBrowserContext(
    args?: Target.CreateBrowserContextArgs
  ): Promise<Target.CreateBrowserContextResult> {
    return this.transport.call<Target.CreateBrowserContextResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Target.createBrowserContext',
      params: args ?? {},
    })
  }
  getBrowserContexts(): Promise<Target.GetBrowserContextsResult> {
    return this.transport.call<Target.GetBrowserContextsResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Target.getBrowserContexts',
      params: {},
    })
  }
  createTarget(
    args: Target.CreateTargetArgs
  ): Promise<Target.CreateTargetResult> {
    return this.transport.call<Target.CreateTargetResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Target.createTarget',
      params: args,
    })
  }
  detachFromTarget(args?: Target.DetachFromTargetArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Target.detachFromTarget',
      params: args ?? {},
    })
  }
  disposeBrowserContext(
    browserContextId: Browser.BrowserContextID
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Target.disposeBrowserContext',
      params: { browserContextId: browserContextId },
    })
  }
  getTargetInfo(
    targetId?: Target.TargetID
  ): Promise<Target.GetTargetInfoResult> {
    return this.transport.call<Target.GetTargetInfoResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Target.getTargetInfo',
      params: { targetId: targetId },
    })
  }
  getTargets(filter?: Target.TargetFilter): Promise<Target.GetTargetsResult> {
    return this.transport.call<Target.GetTargetsResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Target.getTargets',
      params: { filter: filter },
    })
  }
  sendMessageToTarget(args: Target.SendMessageToTargetArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Target.sendMessageToTarget',
      params: args,
    })
  }
  setAutoAttach(args: Target.SetAutoAttachArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Target.setAutoAttach',
      params: args,
    })
  }
  autoAttachRelated(args: Target.AutoAttachRelatedArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Target.autoAttachRelated',
      params: args,
    })
  }
  setDiscoverTargets(args: Target.SetDiscoverTargetsArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Target.setDiscoverTargets',
      params: args,
    })
  }
  setRemoteLocations(locations: Target.RemoteLocation[]): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Target.setRemoteLocations',
      params: { locations: locations },
    })
  }
  on<K extends keyof Target.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Target.EventMap[K]>) => void
  ): () => void {
    const filteredListener: typeof listener = (event) => {
      if (event.sessionId !== this.sessionId) {
        return
      }
      listener(event)
    }
    this.listeners.set(
      listener as ChromeEventListener,
      filteredListener as ChromeEventListener
    )
    return this.transport.on('Target.' + name, listener as ChromeEventListener)
  }
  off<K extends keyof Target.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Target.EventMap[K]>) => void
  ): void {
    const filteredListener = this.listeners.get(listener as ChromeEventListener)
    if (filteredListener === undefined) {
      return
    }
    this.listeners.delete(listener as ChromeEventListener)
    return this.transport.off('Target.' + name, listener as ChromeEventListener)
  }
}
class TetheringClient {
  transport: Transport
  sessionId: Target.SessionID | undefined
  listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  bind(port: number): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Tethering.bind',
      params: { port: port },
    })
  }
  unbind(port: number): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Tethering.unbind',
      params: { port: port },
    })
  }
  on<K extends keyof Tethering.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Tethering.EventMap[K]>) => void
  ): () => void {
    const filteredListener: typeof listener = (event) => {
      if (event.sessionId !== this.sessionId) {
        return
      }
      listener(event)
    }
    this.listeners.set(
      listener as ChromeEventListener,
      filteredListener as ChromeEventListener
    )
    return this.transport.on(
      'Tethering.' + name,
      listener as ChromeEventListener
    )
  }
  off<K extends keyof Tethering.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Tethering.EventMap[K]>) => void
  ): void {
    const filteredListener = this.listeners.get(listener as ChromeEventListener)
    if (filteredListener === undefined) {
      return
    }
    this.listeners.delete(listener as ChromeEventListener)
    return this.transport.off(
      'Tethering.' + name,
      listener as ChromeEventListener
    )
  }
}
class TracingClient {
  transport: Transport
  sessionId: Target.SessionID | undefined
  listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  end(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Tracing.end',
      params: {},
    })
  }
  getCategories(): Promise<Tracing.GetCategoriesResult> {
    return this.transport.call<Tracing.GetCategoriesResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Tracing.getCategories',
      params: {},
    })
  }
  recordClockSyncMarker(syncId: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Tracing.recordClockSyncMarker',
      params: { syncId: syncId },
    })
  }
  requestMemoryDump(
    args?: Tracing.RequestMemoryDumpArgs
  ): Promise<Tracing.RequestMemoryDumpResult> {
    return this.transport.call<Tracing.RequestMemoryDumpResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Tracing.requestMemoryDump',
      params: args ?? {},
    })
  }
  start(args?: Tracing.StartArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Tracing.start',
      params: args ?? {},
    })
  }
  on<K extends keyof Tracing.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Tracing.EventMap[K]>) => void
  ): () => void {
    const filteredListener: typeof listener = (event) => {
      if (event.sessionId !== this.sessionId) {
        return
      }
      listener(event)
    }
    this.listeners.set(
      listener as ChromeEventListener,
      filteredListener as ChromeEventListener
    )
    return this.transport.on('Tracing.' + name, listener as ChromeEventListener)
  }
  off<K extends keyof Tracing.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Tracing.EventMap[K]>) => void
  ): void {
    const filteredListener = this.listeners.get(listener as ChromeEventListener)
    if (filteredListener === undefined) {
      return
    }
    this.listeners.delete(listener as ChromeEventListener)
    return this.transport.off(
      'Tracing.' + name,
      listener as ChromeEventListener
    )
  }
}
class FetchClient {
  transport: Transport
  sessionId: Target.SessionID | undefined
  listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  disable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Fetch.disable',
      params: {},
    })
  }
  enable(args?: Fetch.EnableArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Fetch.enable',
      params: args ?? {},
    })
  }
  failRequest(args: Fetch.FailRequestArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Fetch.failRequest',
      params: args,
    })
  }
  fulfillRequest(args: Fetch.FulfillRequestArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Fetch.fulfillRequest',
      params: args,
    })
  }
  continueRequest(args: Fetch.ContinueRequestArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Fetch.continueRequest',
      params: args,
    })
  }
  continueWithAuth(args: Fetch.ContinueWithAuthArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Fetch.continueWithAuth',
      params: args,
    })
  }
  continueResponse(args: Fetch.ContinueResponseArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Fetch.continueResponse',
      params: args,
    })
  }
  getResponseBody(
    requestId: Fetch.RequestId
  ): Promise<Fetch.GetResponseBodyResult> {
    return this.transport.call<Fetch.GetResponseBodyResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Fetch.getResponseBody',
      params: { requestId: requestId },
    })
  }
  takeResponseBodyAsStream(
    requestId: Fetch.RequestId
  ): Promise<Fetch.TakeResponseBodyAsStreamResult> {
    return this.transport.call<Fetch.TakeResponseBodyAsStreamResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Fetch.takeResponseBodyAsStream',
      params: { requestId: requestId },
    })
  }
  on<K extends keyof Fetch.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Fetch.EventMap[K]>) => void
  ): () => void {
    const filteredListener: typeof listener = (event) => {
      if (event.sessionId !== this.sessionId) {
        return
      }
      listener(event)
    }
    this.listeners.set(
      listener as ChromeEventListener,
      filteredListener as ChromeEventListener
    )
    return this.transport.on('Fetch.' + name, listener as ChromeEventListener)
  }
  off<K extends keyof Fetch.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Fetch.EventMap[K]>) => void
  ): void {
    const filteredListener = this.listeners.get(listener as ChromeEventListener)
    if (filteredListener === undefined) {
      return
    }
    this.listeners.delete(listener as ChromeEventListener)
    return this.transport.off('Fetch.' + name, listener as ChromeEventListener)
  }
}
class WebAudioClient {
  transport: Transport
  sessionId: Target.SessionID | undefined
  listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  enable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'WebAudio.enable',
      params: {},
    })
  }
  disable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'WebAudio.disable',
      params: {},
    })
  }
  getRealtimeData(
    contextId: WebAudio.GraphObjectId
  ): Promise<WebAudio.GetRealtimeDataResult> {
    return this.transport.call<WebAudio.GetRealtimeDataResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'WebAudio.getRealtimeData',
      params: { contextId: contextId },
    })
  }
  on<K extends keyof WebAudio.EventMap>(
    name: K,
    listener: (event: ChromeEvent<WebAudio.EventMap[K]>) => void
  ): () => void {
    const filteredListener: typeof listener = (event) => {
      if (event.sessionId !== this.sessionId) {
        return
      }
      listener(event)
    }
    this.listeners.set(
      listener as ChromeEventListener,
      filteredListener as ChromeEventListener
    )
    return this.transport.on(
      'WebAudio.' + name,
      listener as ChromeEventListener
    )
  }
  off<K extends keyof WebAudio.EventMap>(
    name: K,
    listener: (event: ChromeEvent<WebAudio.EventMap[K]>) => void
  ): void {
    const filteredListener = this.listeners.get(listener as ChromeEventListener)
    if (filteredListener === undefined) {
      return
    }
    this.listeners.delete(listener as ChromeEventListener)
    return this.transport.off(
      'WebAudio.' + name,
      listener as ChromeEventListener
    )
  }
}
class WebAuthnClient {
  transport: Transport
  sessionId: Target.SessionID | undefined
  listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  enable(enableUI?: boolean): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'WebAuthn.enable',
      params: { enableUI: enableUI },
    })
  }
  disable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'WebAuthn.disable',
      params: {},
    })
  }
  addVirtualAuthenticator(
    options: WebAuthn.VirtualAuthenticatorOptions
  ): Promise<WebAuthn.AddVirtualAuthenticatorResult> {
    return this.transport.call<WebAuthn.AddVirtualAuthenticatorResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'WebAuthn.addVirtualAuthenticator',
      params: { options: options },
    })
  }
  setResponseOverrideBits(
    args: WebAuthn.SetResponseOverrideBitsArgs
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'WebAuthn.setResponseOverrideBits',
      params: args,
    })
  }
  removeVirtualAuthenticator(
    authenticatorId: WebAuthn.AuthenticatorId
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'WebAuthn.removeVirtualAuthenticator',
      params: { authenticatorId: authenticatorId },
    })
  }
  addCredential(args: WebAuthn.AddCredentialArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'WebAuthn.addCredential',
      params: args,
    })
  }
  getCredential(
    args: WebAuthn.GetCredentialArgs
  ): Promise<WebAuthn.GetCredentialResult> {
    return this.transport.call<WebAuthn.GetCredentialResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'WebAuthn.getCredential',
      params: args,
    })
  }
  getCredentials(
    authenticatorId: WebAuthn.AuthenticatorId
  ): Promise<WebAuthn.GetCredentialsResult> {
    return this.transport.call<WebAuthn.GetCredentialsResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'WebAuthn.getCredentials',
      params: { authenticatorId: authenticatorId },
    })
  }
  removeCredential(args: WebAuthn.RemoveCredentialArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'WebAuthn.removeCredential',
      params: args,
    })
  }
  clearCredentials(authenticatorId: WebAuthn.AuthenticatorId): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'WebAuthn.clearCredentials',
      params: { authenticatorId: authenticatorId },
    })
  }
  setUserVerified(args: WebAuthn.SetUserVerifiedArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'WebAuthn.setUserVerified',
      params: args,
    })
  }
  setAutomaticPresenceSimulation(
    args: WebAuthn.SetAutomaticPresenceSimulationArgs
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'WebAuthn.setAutomaticPresenceSimulation',
      params: args,
    })
  }
  setCredentialProperties(
    args: WebAuthn.SetCredentialPropertiesArgs
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'WebAuthn.setCredentialProperties',
      params: args,
    })
  }
  on<K extends keyof WebAuthn.EventMap>(
    name: K,
    listener: (event: ChromeEvent<WebAuthn.EventMap[K]>) => void
  ): () => void {
    const filteredListener: typeof listener = (event) => {
      if (event.sessionId !== this.sessionId) {
        return
      }
      listener(event)
    }
    this.listeners.set(
      listener as ChromeEventListener,
      filteredListener as ChromeEventListener
    )
    return this.transport.on(
      'WebAuthn.' + name,
      listener as ChromeEventListener
    )
  }
  off<K extends keyof WebAuthn.EventMap>(
    name: K,
    listener: (event: ChromeEvent<WebAuthn.EventMap[K]>) => void
  ): void {
    const filteredListener = this.listeners.get(listener as ChromeEventListener)
    if (filteredListener === undefined) {
      return
    }
    this.listeners.delete(listener as ChromeEventListener)
    return this.transport.off(
      'WebAuthn.' + name,
      listener as ChromeEventListener
    )
  }
}
class MediaClient {
  transport: Transport
  sessionId: Target.SessionID | undefined
  listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  enable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Media.enable',
      params: {},
    })
  }
  disable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Media.disable',
      params: {},
    })
  }
  on<K extends keyof Media.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Media.EventMap[K]>) => void
  ): () => void {
    const filteredListener: typeof listener = (event) => {
      if (event.sessionId !== this.sessionId) {
        return
      }
      listener(event)
    }
    this.listeners.set(
      listener as ChromeEventListener,
      filteredListener as ChromeEventListener
    )
    return this.transport.on('Media.' + name, listener as ChromeEventListener)
  }
  off<K extends keyof Media.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Media.EventMap[K]>) => void
  ): void {
    const filteredListener = this.listeners.get(listener as ChromeEventListener)
    if (filteredListener === undefined) {
      return
    }
    this.listeners.delete(listener as ChromeEventListener)
    return this.transport.off('Media.' + name, listener as ChromeEventListener)
  }
}
class DeviceAccessClient {
  transport: Transport
  sessionId: Target.SessionID | undefined
  listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  enable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DeviceAccess.enable',
      params: {},
    })
  }
  disable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DeviceAccess.disable',
      params: {},
    })
  }
  selectPrompt(args: DeviceAccess.SelectPromptArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DeviceAccess.selectPrompt',
      params: args,
    })
  }
  cancelPrompt(id: DeviceAccess.RequestId): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DeviceAccess.cancelPrompt',
      params: { id: id },
    })
  }
  on<K extends keyof DeviceAccess.EventMap>(
    name: K,
    listener: (event: ChromeEvent<DeviceAccess.EventMap[K]>) => void
  ): () => void {
    const filteredListener: typeof listener = (event) => {
      if (event.sessionId !== this.sessionId) {
        return
      }
      listener(event)
    }
    this.listeners.set(
      listener as ChromeEventListener,
      filteredListener as ChromeEventListener
    )
    return this.transport.on(
      'DeviceAccess.' + name,
      listener as ChromeEventListener
    )
  }
  off<K extends keyof DeviceAccess.EventMap>(
    name: K,
    listener: (event: ChromeEvent<DeviceAccess.EventMap[K]>) => void
  ): void {
    const filteredListener = this.listeners.get(listener as ChromeEventListener)
    if (filteredListener === undefined) {
      return
    }
    this.listeners.delete(listener as ChromeEventListener)
    return this.transport.off(
      'DeviceAccess.' + name,
      listener as ChromeEventListener
    )
  }
}
class PreloadClient {
  transport: Transport
  sessionId: Target.SessionID | undefined
  listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  enable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Preload.enable',
      params: {},
    })
  }
  disable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Preload.disable',
      params: {},
    })
  }
  on<K extends keyof Preload.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Preload.EventMap[K]>) => void
  ): () => void {
    const filteredListener: typeof listener = (event) => {
      if (event.sessionId !== this.sessionId) {
        return
      }
      listener(event)
    }
    this.listeners.set(
      listener as ChromeEventListener,
      filteredListener as ChromeEventListener
    )
    return this.transport.on('Preload.' + name, listener as ChromeEventListener)
  }
  off<K extends keyof Preload.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Preload.EventMap[K]>) => void
  ): void {
    const filteredListener = this.listeners.get(listener as ChromeEventListener)
    if (filteredListener === undefined) {
      return
    }
    this.listeners.delete(listener as ChromeEventListener)
    return this.transport.off(
      'Preload.' + name,
      listener as ChromeEventListener
    )
  }
}
class FedCmClient {
  transport: Transport
  sessionId: Target.SessionID | undefined
  listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  enable(disableRejectionDelay?: boolean): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'FedCm.enable',
      params: { disableRejectionDelay: disableRejectionDelay },
    })
  }
  disable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'FedCm.disable',
      params: {},
    })
  }
  selectAccount(args: FedCm.SelectAccountArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'FedCm.selectAccount',
      params: args,
    })
  }
  clickDialogButton(args: FedCm.ClickDialogButtonArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'FedCm.clickDialogButton',
      params: args,
    })
  }
  openUrl(args: FedCm.OpenUrlArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'FedCm.openUrl',
      params: args,
    })
  }
  dismissDialog(args: FedCm.DismissDialogArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'FedCm.dismissDialog',
      params: args,
    })
  }
  resetCooldown(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'FedCm.resetCooldown',
      params: {},
    })
  }
  on<K extends keyof FedCm.EventMap>(
    name: K,
    listener: (event: ChromeEvent<FedCm.EventMap[K]>) => void
  ): () => void {
    const filteredListener: typeof listener = (event) => {
      if (event.sessionId !== this.sessionId) {
        return
      }
      listener(event)
    }
    this.listeners.set(
      listener as ChromeEventListener,
      filteredListener as ChromeEventListener
    )
    return this.transport.on('FedCm.' + name, listener as ChromeEventListener)
  }
  off<K extends keyof FedCm.EventMap>(
    name: K,
    listener: (event: ChromeEvent<FedCm.EventMap[K]>) => void
  ): void {
    const filteredListener = this.listeners.get(listener as ChromeEventListener)
    if (filteredListener === undefined) {
      return
    }
    this.listeners.delete(listener as ChromeEventListener)
    return this.transport.off('FedCm.' + name, listener as ChromeEventListener)
  }
}
class PWAClient {
  transport: Transport
  sessionId: Target.SessionID | undefined
  listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  getOsAppState(manifestId: string): Promise<PWA.GetOsAppStateResult> {
    return this.transport.call<PWA.GetOsAppStateResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'PWA.getOsAppState',
      params: { manifestId: manifestId },
    })
  }
  install(args: PWA.InstallArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'PWA.install',
      params: args,
    })
  }
  uninstall(manifestId: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'PWA.uninstall',
      params: { manifestId: manifestId },
    })
  }
  launch(args: PWA.LaunchArgs): Promise<PWA.LaunchResult> {
    return this.transport.call<PWA.LaunchResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'PWA.launch',
      params: args,
    })
  }
  launchFilesInApp(
    args: PWA.LaunchFilesInAppArgs
  ): Promise<PWA.LaunchFilesInAppResult> {
    return this.transport.call<PWA.LaunchFilesInAppResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'PWA.launchFilesInApp',
      params: args,
    })
  }
  openCurrentPageInApp(manifestId: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'PWA.openCurrentPageInApp',
      params: { manifestId: manifestId },
    })
  }
  changeAppUserSettings(args: PWA.ChangeAppUserSettingsArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'PWA.changeAppUserSettings',
      params: args,
    })
  }
}
class BluetoothEmulationClient {
  transport: Transport
  sessionId: Target.SessionID | undefined
  listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  enable(args: BluetoothEmulation.EnableArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'BluetoothEmulation.enable',
      params: args,
    })
  }
  setSimulatedCentralState(
    state: BluetoothEmulation.CentralState
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'BluetoothEmulation.setSimulatedCentralState',
      params: { state: state },
    })
  }
  disable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'BluetoothEmulation.disable',
      params: {},
    })
  }
  simulatePreconnectedPeripheral(
    args: BluetoothEmulation.SimulatePreconnectedPeripheralArgs
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'BluetoothEmulation.simulatePreconnectedPeripheral',
      params: args,
    })
  }
  simulateAdvertisement(entry: BluetoothEmulation.ScanEntry): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'BluetoothEmulation.simulateAdvertisement',
      params: { entry: entry },
    })
  }
  simulateGATTOperationResponse(
    args: BluetoothEmulation.SimulateGATTOperationResponseArgs
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'BluetoothEmulation.simulateGATTOperationResponse',
      params: args,
    })
  }
  simulateCharacteristicOperationResponse(
    args: BluetoothEmulation.SimulateCharacteristicOperationResponseArgs
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'BluetoothEmulation.simulateCharacteristicOperationResponse',
      params: args,
    })
  }
  simulateDescriptorOperationResponse(
    args: BluetoothEmulation.SimulateDescriptorOperationResponseArgs
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'BluetoothEmulation.simulateDescriptorOperationResponse',
      params: args,
    })
  }
  addService(
    args: BluetoothEmulation.AddServiceArgs
  ): Promise<BluetoothEmulation.AddServiceResult> {
    return this.transport.call<BluetoothEmulation.AddServiceResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'BluetoothEmulation.addService',
      params: args,
    })
  }
  removeService(serviceId: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'BluetoothEmulation.removeService',
      params: { serviceId: serviceId },
    })
  }
  addCharacteristic(
    args: BluetoothEmulation.AddCharacteristicArgs
  ): Promise<BluetoothEmulation.AddCharacteristicResult> {
    return this.transport.call<BluetoothEmulation.AddCharacteristicResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'BluetoothEmulation.addCharacteristic',
      params: args,
    })
  }
  removeCharacteristic(characteristicId: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'BluetoothEmulation.removeCharacteristic',
      params: { characteristicId: characteristicId },
    })
  }
  addDescriptor(
    args: BluetoothEmulation.AddDescriptorArgs
  ): Promise<BluetoothEmulation.AddDescriptorResult> {
    return this.transport.call<BluetoothEmulation.AddDescriptorResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'BluetoothEmulation.addDescriptor',
      params: args,
    })
  }
  removeDescriptor(descriptorId: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'BluetoothEmulation.removeDescriptor',
      params: { descriptorId: descriptorId },
    })
  }
  simulateGATTDisconnection(address: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'BluetoothEmulation.simulateGATTDisconnection',
      params: { address: address },
    })
  }
  on<K extends keyof BluetoothEmulation.EventMap>(
    name: K,
    listener: (event: ChromeEvent<BluetoothEmulation.EventMap[K]>) => void
  ): () => void {
    const filteredListener: typeof listener = (event) => {
      if (event.sessionId !== this.sessionId) {
        return
      }
      listener(event)
    }
    this.listeners.set(
      listener as ChromeEventListener,
      filteredListener as ChromeEventListener
    )
    return this.transport.on(
      'BluetoothEmulation.' + name,
      listener as ChromeEventListener
    )
  }
  off<K extends keyof BluetoothEmulation.EventMap>(
    name: K,
    listener: (event: ChromeEvent<BluetoothEmulation.EventMap[K]>) => void
  ): void {
    const filteredListener = this.listeners.get(listener as ChromeEventListener)
    if (filteredListener === undefined) {
      return
    }
    this.listeners.delete(listener as ChromeEventListener)
    return this.transport.off(
      'BluetoothEmulation.' + name,
      listener as ChromeEventListener
    )
  }
}
class ConsoleClient {
  transport: Transport
  sessionId: Target.SessionID | undefined
  listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  clearMessages(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Console.clearMessages',
      params: {},
    })
  }
  disable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Console.disable',
      params: {},
    })
  }
  enable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Console.enable',
      params: {},
    })
  }
  on<K extends keyof Console.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Console.EventMap[K]>) => void
  ): () => void {
    const filteredListener: typeof listener = (event) => {
      if (event.sessionId !== this.sessionId) {
        return
      }
      listener(event)
    }
    this.listeners.set(
      listener as ChromeEventListener,
      filteredListener as ChromeEventListener
    )
    return this.transport.on('Console.' + name, listener as ChromeEventListener)
  }
  off<K extends keyof Console.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Console.EventMap[K]>) => void
  ): void {
    const filteredListener = this.listeners.get(listener as ChromeEventListener)
    if (filteredListener === undefined) {
      return
    }
    this.listeners.delete(listener as ChromeEventListener)
    return this.transport.off(
      'Console.' + name,
      listener as ChromeEventListener
    )
  }
}
class DebuggerClient {
  transport: Transport
  sessionId: Target.SessionID | undefined
  listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  continueToLocation(args: Debugger.ContinueToLocationArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Debugger.continueToLocation',
      params: args,
    })
  }
  disable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Debugger.disable',
      params: {},
    })
  }
  enable(maxScriptsCacheSize?: number): Promise<Debugger.EnableResult> {
    return this.transport.call<Debugger.EnableResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Debugger.enable',
      params: { maxScriptsCacheSize: maxScriptsCacheSize },
    })
  }
  evaluateOnCallFrame(
    args: Debugger.EvaluateOnCallFrameArgs
  ): Promise<Debugger.EvaluateOnCallFrameResult> {
    return this.transport.call<Debugger.EvaluateOnCallFrameResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Debugger.evaluateOnCallFrame',
      params: args,
    })
  }
  getPossibleBreakpoints(
    args: Debugger.GetPossibleBreakpointsArgs
  ): Promise<Debugger.GetPossibleBreakpointsResult> {
    return this.transport.call<Debugger.GetPossibleBreakpointsResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Debugger.getPossibleBreakpoints',
      params: args,
    })
  }
  getScriptSource(
    scriptId: Runtime.ScriptId
  ): Promise<Debugger.GetScriptSourceResult> {
    return this.transport.call<Debugger.GetScriptSourceResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Debugger.getScriptSource',
      params: { scriptId: scriptId },
    })
  }
  disassembleWasmModule(
    scriptId: Runtime.ScriptId
  ): Promise<Debugger.DisassembleWasmModuleResult> {
    return this.transport.call<Debugger.DisassembleWasmModuleResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Debugger.disassembleWasmModule',
      params: { scriptId: scriptId },
    })
  }
  nextWasmDisassemblyChunk(
    streamId: string
  ): Promise<Debugger.NextWasmDisassemblyChunkResult> {
    return this.transport.call<Debugger.NextWasmDisassemblyChunkResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Debugger.nextWasmDisassemblyChunk',
      params: { streamId: streamId },
    })
  }
  getWasmBytecode(
    scriptId: Runtime.ScriptId
  ): Promise<Debugger.GetWasmBytecodeResult> {
    return this.transport.call<Debugger.GetWasmBytecodeResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Debugger.getWasmBytecode',
      params: { scriptId: scriptId },
    })
  }
  getStackTrace(
    stackTraceId: Runtime.StackTraceId
  ): Promise<Debugger.GetStackTraceResult> {
    return this.transport.call<Debugger.GetStackTraceResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Debugger.getStackTrace',
      params: { stackTraceId: stackTraceId },
    })
  }
  pause(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Debugger.pause',
      params: {},
    })
  }
  pauseOnAsyncCall(parentStackTraceId: Runtime.StackTraceId): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Debugger.pauseOnAsyncCall',
      params: { parentStackTraceId: parentStackTraceId },
    })
  }
  removeBreakpoint(breakpointId: Debugger.BreakpointId): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Debugger.removeBreakpoint',
      params: { breakpointId: breakpointId },
    })
  }
  restartFrame(
    args: Debugger.RestartFrameArgs
  ): Promise<Debugger.RestartFrameResult> {
    return this.transport.call<Debugger.RestartFrameResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Debugger.restartFrame',
      params: args,
    })
  }
  resume(terminateOnResume?: boolean): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Debugger.resume',
      params: { terminateOnResume: terminateOnResume },
    })
  }
  searchInContent(
    args: Debugger.SearchInContentArgs
  ): Promise<Debugger.SearchInContentResult> {
    return this.transport.call<Debugger.SearchInContentResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Debugger.searchInContent',
      params: args,
    })
  }
  setAsyncCallStackDepth(maxDepth: number): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Debugger.setAsyncCallStackDepth',
      params: { maxDepth: maxDepth },
    })
  }
  setBlackboxExecutionContexts(uniqueIds: string[]): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Debugger.setBlackboxExecutionContexts',
      params: { uniqueIds: uniqueIds },
    })
  }
  setBlackboxPatterns(args: Debugger.SetBlackboxPatternsArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Debugger.setBlackboxPatterns',
      params: args,
    })
  }
  setBlackboxedRanges(args: Debugger.SetBlackboxedRangesArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Debugger.setBlackboxedRanges',
      params: args,
    })
  }
  setBreakpoint(
    args: Debugger.SetBreakpointArgs
  ): Promise<Debugger.SetBreakpointResult> {
    return this.transport.call<Debugger.SetBreakpointResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Debugger.setBreakpoint',
      params: args,
    })
  }
  setInstrumentationBreakpoint(
    instrumentation:
      | 'beforeScriptExecution'
      | 'beforeScriptWithSourceMapExecution'
  ): Promise<Debugger.SetInstrumentationBreakpointResult> {
    return this.transport.call<Debugger.SetInstrumentationBreakpointResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Debugger.setInstrumentationBreakpoint',
      params: { instrumentation: instrumentation },
    })
  }
  setBreakpointByUrl(
    args: Debugger.SetBreakpointByUrlArgs
  ): Promise<Debugger.SetBreakpointByUrlResult> {
    return this.transport.call<Debugger.SetBreakpointByUrlResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Debugger.setBreakpointByUrl',
      params: args,
    })
  }
  setBreakpointOnFunctionCall(
    args: Debugger.SetBreakpointOnFunctionCallArgs
  ): Promise<Debugger.SetBreakpointOnFunctionCallResult> {
    return this.transport.call<Debugger.SetBreakpointOnFunctionCallResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Debugger.setBreakpointOnFunctionCall',
      params: args,
    })
  }
  setBreakpointsActive(active: boolean): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Debugger.setBreakpointsActive',
      params: { active: active },
    })
  }
  setPauseOnExceptions(
    state: 'none' | 'caught' | 'uncaught' | 'all'
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Debugger.setPauseOnExceptions',
      params: { state: state },
    })
  }
  setReturnValue(newValue: Runtime.CallArgument): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Debugger.setReturnValue',
      params: { newValue: newValue },
    })
  }
  setScriptSource(
    args: Debugger.SetScriptSourceArgs
  ): Promise<Debugger.SetScriptSourceResult> {
    return this.transport.call<Debugger.SetScriptSourceResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Debugger.setScriptSource',
      params: args,
    })
  }
  setSkipAllPauses(skip: boolean): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Debugger.setSkipAllPauses',
      params: { skip: skip },
    })
  }
  setVariableValue(args: Debugger.SetVariableValueArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Debugger.setVariableValue',
      params: args,
    })
  }
  stepInto(args?: Debugger.StepIntoArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Debugger.stepInto',
      params: args ?? {},
    })
  }
  stepOut(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Debugger.stepOut',
      params: {},
    })
  }
  stepOver(skipList?: Debugger.LocationRange[]): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Debugger.stepOver',
      params: { skipList: skipList },
    })
  }
  on<K extends keyof Debugger.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Debugger.EventMap[K]>) => void
  ): () => void {
    const filteredListener: typeof listener = (event) => {
      if (event.sessionId !== this.sessionId) {
        return
      }
      listener(event)
    }
    this.listeners.set(
      listener as ChromeEventListener,
      filteredListener as ChromeEventListener
    )
    return this.transport.on(
      'Debugger.' + name,
      listener as ChromeEventListener
    )
  }
  off<K extends keyof Debugger.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Debugger.EventMap[K]>) => void
  ): void {
    const filteredListener = this.listeners.get(listener as ChromeEventListener)
    if (filteredListener === undefined) {
      return
    }
    this.listeners.delete(listener as ChromeEventListener)
    return this.transport.off(
      'Debugger.' + name,
      listener as ChromeEventListener
    )
  }
}
class HeapProfilerClient {
  transport: Transport
  sessionId: Target.SessionID | undefined
  listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  addInspectedHeapObject(
    heapObjectId: HeapProfiler.HeapSnapshotObjectId
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'HeapProfiler.addInspectedHeapObject',
      params: { heapObjectId: heapObjectId },
    })
  }
  collectGarbage(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'HeapProfiler.collectGarbage',
      params: {},
    })
  }
  disable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'HeapProfiler.disable',
      params: {},
    })
  }
  enable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'HeapProfiler.enable',
      params: {},
    })
  }
  getHeapObjectId(
    objectId: Runtime.RemoteObjectId
  ): Promise<HeapProfiler.GetHeapObjectIdResult> {
    return this.transport.call<HeapProfiler.GetHeapObjectIdResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'HeapProfiler.getHeapObjectId',
      params: { objectId: objectId },
    })
  }
  getObjectByHeapObjectId(
    args: HeapProfiler.GetObjectByHeapObjectIdArgs
  ): Promise<HeapProfiler.GetObjectByHeapObjectIdResult> {
    return this.transport.call<HeapProfiler.GetObjectByHeapObjectIdResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'HeapProfiler.getObjectByHeapObjectId',
      params: args,
    })
  }
  getSamplingProfile(): Promise<HeapProfiler.GetSamplingProfileResult> {
    return this.transport.call<HeapProfiler.GetSamplingProfileResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'HeapProfiler.getSamplingProfile',
      params: {},
    })
  }
  startSampling(args?: HeapProfiler.StartSamplingArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'HeapProfiler.startSampling',
      params: args ?? {},
    })
  }
  startTrackingHeapObjects(trackAllocations?: boolean): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'HeapProfiler.startTrackingHeapObjects',
      params: { trackAllocations: trackAllocations },
    })
  }
  stopSampling(): Promise<HeapProfiler.StopSamplingResult> {
    return this.transport.call<HeapProfiler.StopSamplingResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'HeapProfiler.stopSampling',
      params: {},
    })
  }
  stopTrackingHeapObjects(
    args?: HeapProfiler.StopTrackingHeapObjectsArgs
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'HeapProfiler.stopTrackingHeapObjects',
      params: args ?? {},
    })
  }
  takeHeapSnapshot(args?: HeapProfiler.TakeHeapSnapshotArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'HeapProfiler.takeHeapSnapshot',
      params: args ?? {},
    })
  }
  on<K extends keyof HeapProfiler.EventMap>(
    name: K,
    listener: (event: ChromeEvent<HeapProfiler.EventMap[K]>) => void
  ): () => void {
    const filteredListener: typeof listener = (event) => {
      if (event.sessionId !== this.sessionId) {
        return
      }
      listener(event)
    }
    this.listeners.set(
      listener as ChromeEventListener,
      filteredListener as ChromeEventListener
    )
    return this.transport.on(
      'HeapProfiler.' + name,
      listener as ChromeEventListener
    )
  }
  off<K extends keyof HeapProfiler.EventMap>(
    name: K,
    listener: (event: ChromeEvent<HeapProfiler.EventMap[K]>) => void
  ): void {
    const filteredListener = this.listeners.get(listener as ChromeEventListener)
    if (filteredListener === undefined) {
      return
    }
    this.listeners.delete(listener as ChromeEventListener)
    return this.transport.off(
      'HeapProfiler.' + name,
      listener as ChromeEventListener
    )
  }
}
class ProfilerClient {
  transport: Transport
  sessionId: Target.SessionID | undefined
  listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  disable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Profiler.disable',
      params: {},
    })
  }
  enable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Profiler.enable',
      params: {},
    })
  }
  getBestEffortCoverage(): Promise<Profiler.GetBestEffortCoverageResult> {
    return this.transport.call<Profiler.GetBestEffortCoverageResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Profiler.getBestEffortCoverage',
      params: {},
    })
  }
  setSamplingInterval(interval: number): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Profiler.setSamplingInterval',
      params: { interval: interval },
    })
  }
  start(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Profiler.start',
      params: {},
    })
  }
  startPreciseCoverage(
    args?: Profiler.StartPreciseCoverageArgs
  ): Promise<Profiler.StartPreciseCoverageResult> {
    return this.transport.call<Profiler.StartPreciseCoverageResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Profiler.startPreciseCoverage',
      params: args ?? {},
    })
  }
  stop(): Promise<Profiler.StopResult> {
    return this.transport.call<Profiler.StopResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Profiler.stop',
      params: {},
    })
  }
  stopPreciseCoverage(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Profiler.stopPreciseCoverage',
      params: {},
    })
  }
  takePreciseCoverage(): Promise<Profiler.TakePreciseCoverageResult> {
    return this.transport.call<Profiler.TakePreciseCoverageResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Profiler.takePreciseCoverage',
      params: {},
    })
  }
  on<K extends keyof Profiler.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Profiler.EventMap[K]>) => void
  ): () => void {
    const filteredListener: typeof listener = (event) => {
      if (event.sessionId !== this.sessionId) {
        return
      }
      listener(event)
    }
    this.listeners.set(
      listener as ChromeEventListener,
      filteredListener as ChromeEventListener
    )
    return this.transport.on(
      'Profiler.' + name,
      listener as ChromeEventListener
    )
  }
  off<K extends keyof Profiler.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Profiler.EventMap[K]>) => void
  ): void {
    const filteredListener = this.listeners.get(listener as ChromeEventListener)
    if (filteredListener === undefined) {
      return
    }
    this.listeners.delete(listener as ChromeEventListener)
    return this.transport.off(
      'Profiler.' + name,
      listener as ChromeEventListener
    )
  }
}
class RuntimeClient {
  transport: Transport
  sessionId: Target.SessionID | undefined
  listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  awaitPromise(
    args: Runtime.AwaitPromiseArgs
  ): Promise<Runtime.AwaitPromiseResult> {
    return this.transport.call<Runtime.AwaitPromiseResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Runtime.awaitPromise',
      params: args,
    })
  }
  callFunctionOn(
    args: Runtime.CallFunctionOnArgs
  ): Promise<Runtime.CallFunctionOnResult> {
    return this.transport.call<Runtime.CallFunctionOnResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Runtime.callFunctionOn',
      params: args,
    })
  }
  compileScript(
    args: Runtime.CompileScriptArgs
  ): Promise<Runtime.CompileScriptResult> {
    return this.transport.call<Runtime.CompileScriptResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Runtime.compileScript',
      params: args,
    })
  }
  disable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Runtime.disable',
      params: {},
    })
  }
  discardConsoleEntries(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Runtime.discardConsoleEntries',
      params: {},
    })
  }
  enable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Runtime.enable',
      params: {},
    })
  }
  evaluate(args: Runtime.EvaluateArgs): Promise<Runtime.EvaluateResult> {
    return this.transport.call<Runtime.EvaluateResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Runtime.evaluate',
      params: args,
    })
  }
  getIsolateId(): Promise<Runtime.GetIsolateIdResult> {
    return this.transport.call<Runtime.GetIsolateIdResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Runtime.getIsolateId',
      params: {},
    })
  }
  getHeapUsage(): Promise<Runtime.GetHeapUsageResult> {
    return this.transport.call<Runtime.GetHeapUsageResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Runtime.getHeapUsage',
      params: {},
    })
  }
  getProperties(
    args: Runtime.GetPropertiesArgs
  ): Promise<Runtime.GetPropertiesResult> {
    return this.transport.call<Runtime.GetPropertiesResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Runtime.getProperties',
      params: args,
    })
  }
  globalLexicalScopeNames(
    executionContextId?: Runtime.ExecutionContextId
  ): Promise<Runtime.GlobalLexicalScopeNamesResult> {
    return this.transport.call<Runtime.GlobalLexicalScopeNamesResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Runtime.globalLexicalScopeNames',
      params: { executionContextId: executionContextId },
    })
  }
  queryObjects(
    args: Runtime.QueryObjectsArgs
  ): Promise<Runtime.QueryObjectsResult> {
    return this.transport.call<Runtime.QueryObjectsResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Runtime.queryObjects',
      params: args,
    })
  }
  releaseObject(objectId: Runtime.RemoteObjectId): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Runtime.releaseObject',
      params: { objectId: objectId },
    })
  }
  releaseObjectGroup(objectGroup: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Runtime.releaseObjectGroup',
      params: { objectGroup: objectGroup },
    })
  }
  runIfWaitingForDebugger(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Runtime.runIfWaitingForDebugger',
      params: {},
    })
  }
  runScript(args: Runtime.RunScriptArgs): Promise<Runtime.RunScriptResult> {
    return this.transport.call<Runtime.RunScriptResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Runtime.runScript',
      params: args,
    })
  }
  setAsyncCallStackDepth(maxDepth: number): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Runtime.setAsyncCallStackDepth',
      params: { maxDepth: maxDepth },
    })
  }
  setCustomObjectFormatterEnabled(enabled: boolean): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Runtime.setCustomObjectFormatterEnabled',
      params: { enabled: enabled },
    })
  }
  setMaxCallStackSizeToCapture(size: number): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Runtime.setMaxCallStackSizeToCapture',
      params: { size: size },
    })
  }
  terminateExecution(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Runtime.terminateExecution',
      params: {},
    })
  }
  addBinding(args: Runtime.AddBindingArgs): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Runtime.addBinding',
      params: args,
    })
  }
  removeBinding(name: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Runtime.removeBinding',
      params: { name: name },
    })
  }
  getExceptionDetails(
    errorObjectId: Runtime.RemoteObjectId
  ): Promise<Runtime.GetExceptionDetailsResult> {
    return this.transport.call<Runtime.GetExceptionDetailsResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Runtime.getExceptionDetails',
      params: { errorObjectId: errorObjectId },
    })
  }
  on<K extends keyof Runtime.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Runtime.EventMap[K]>) => void
  ): () => void {
    const filteredListener: typeof listener = (event) => {
      if (event.sessionId !== this.sessionId) {
        return
      }
      listener(event)
    }
    this.listeners.set(
      listener as ChromeEventListener,
      filteredListener as ChromeEventListener
    )
    return this.transport.on('Runtime.' + name, listener as ChromeEventListener)
  }
  off<K extends keyof Runtime.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Runtime.EventMap[K]>) => void
  ): void {
    const filteredListener = this.listeners.get(listener as ChromeEventListener)
    if (filteredListener === undefined) {
      return
    }
    this.listeners.delete(listener as ChromeEventListener)
    return this.transport.off(
      'Runtime.' + name,
      listener as ChromeEventListener
    )
  }
}
class SchemaClient {
  transport: Transport
  sessionId: Target.SessionID | undefined
  listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  getDomains(): Promise<Schema.GetDomainsResult> {
    return this.transport.call<Schema.GetDomainsResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Schema.getDomains',
      params: {},
    })
  }
}
export class ChromeDevToolsClient {
  transport: Transport
  sessionId: Target.SessionID | undefined
  accessibility: AccessibilityClient
  animation: AnimationClient
  audits: AuditsClient
  extensions: ExtensionsClient
  autofill: AutofillClient
  backgroundService: BackgroundServiceClient
  browser: BrowserClient
  css: CSSClient
  cacheStorage: CacheStorageClient
  cast: CastClient
  dom: DOMClient
  domDebugger: DOMDebuggerClient
  eventBreakpoints: EventBreakpointsClient
  domSnapshot: DOMSnapshotClient
  domStorage: DOMStorageClient
  deviceOrientation: DeviceOrientationClient
  emulation: EmulationClient
  headlessExperimental: HeadlessExperimentalClient
  io: IOClient
  fileSystem: FileSystemClient
  indexedDB: IndexedDBClient
  input: InputClient
  inspector: InspectorClient
  layerTree: LayerTreeClient
  log: LogClient
  memory: MemoryClient
  network: NetworkClient
  overlay: OverlayClient
  page: PageClient
  performance: PerformanceClient
  performanceTimeline: PerformanceTimelineClient
  security: SecurityClient
  serviceWorker: ServiceWorkerClient
  storage: StorageClient
  systemInfo: SystemInfoClient
  target: TargetClient
  tethering: TetheringClient
  tracing: TracingClient
  fetch: FetchClient
  webAudio: WebAudioClient
  webAuthn: WebAuthnClient
  media: MediaClient
  deviceAccess: DeviceAccessClient
  preload: PreloadClient
  fedCm: FedCmClient
  pwa: PWAClient
  bluetoothEmulation: BluetoothEmulationClient
  console: ConsoleClient
  debugger: DebuggerClient
  heapProfiler: HeapProfilerClient
  profiler: ProfilerClient
  runtime: RuntimeClient
  schema: SchemaClient
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.accessibility = new AccessibilityClient(this.transport, this.sessionId)
    this.animation = new AnimationClient(this.transport, this.sessionId)
    this.audits = new AuditsClient(this.transport, this.sessionId)
    this.extensions = new ExtensionsClient(this.transport, this.sessionId)
    this.autofill = new AutofillClient(this.transport, this.sessionId)
    this.backgroundService = new BackgroundServiceClient(
      this.transport,
      this.sessionId
    )
    this.browser = new BrowserClient(this.transport, this.sessionId)
    this.css = new CSSClient(this.transport, this.sessionId)
    this.cacheStorage = new CacheStorageClient(this.transport, this.sessionId)
    this.cast = new CastClient(this.transport, this.sessionId)
    this.dom = new DOMClient(this.transport, this.sessionId)
    this.domDebugger = new DOMDebuggerClient(this.transport, this.sessionId)
    this.eventBreakpoints = new EventBreakpointsClient(
      this.transport,
      this.sessionId
    )
    this.domSnapshot = new DOMSnapshotClient(this.transport, this.sessionId)
    this.domStorage = new DOMStorageClient(this.transport, this.sessionId)
    this.deviceOrientation = new DeviceOrientationClient(
      this.transport,
      this.sessionId
    )
    this.emulation = new EmulationClient(this.transport, this.sessionId)
    this.headlessExperimental = new HeadlessExperimentalClient(
      this.transport,
      this.sessionId
    )
    this.io = new IOClient(this.transport, this.sessionId)
    this.fileSystem = new FileSystemClient(this.transport, this.sessionId)
    this.indexedDB = new IndexedDBClient(this.transport, this.sessionId)
    this.input = new InputClient(this.transport, this.sessionId)
    this.inspector = new InspectorClient(this.transport, this.sessionId)
    this.layerTree = new LayerTreeClient(this.transport, this.sessionId)
    this.log = new LogClient(this.transport, this.sessionId)
    this.memory = new MemoryClient(this.transport, this.sessionId)
    this.network = new NetworkClient(this.transport, this.sessionId)
    this.overlay = new OverlayClient(this.transport, this.sessionId)
    this.page = new PageClient(this.transport, this.sessionId)
    this.performance = new PerformanceClient(this.transport, this.sessionId)
    this.performanceTimeline = new PerformanceTimelineClient(
      this.transport,
      this.sessionId
    )
    this.security = new SecurityClient(this.transport, this.sessionId)
    this.serviceWorker = new ServiceWorkerClient(this.transport, this.sessionId)
    this.storage = new StorageClient(this.transport, this.sessionId)
    this.systemInfo = new SystemInfoClient(this.transport, this.sessionId)
    this.target = new TargetClient(this.transport, this.sessionId)
    this.tethering = new TetheringClient(this.transport, this.sessionId)
    this.tracing = new TracingClient(this.transport, this.sessionId)
    this.fetch = new FetchClient(this.transport, this.sessionId)
    this.webAudio = new WebAudioClient(this.transport, this.sessionId)
    this.webAuthn = new WebAuthnClient(this.transport, this.sessionId)
    this.media = new MediaClient(this.transport, this.sessionId)
    this.deviceAccess = new DeviceAccessClient(this.transport, this.sessionId)
    this.preload = new PreloadClient(this.transport, this.sessionId)
    this.fedCm = new FedCmClient(this.transport, this.sessionId)
    this.pwa = new PWAClient(this.transport, this.sessionId)
    this.bluetoothEmulation = new BluetoothEmulationClient(
      this.transport,
      this.sessionId
    )
    this.console = new ConsoleClient(this.transport, this.sessionId)
    this.debugger = new DebuggerClient(this.transport, this.sessionId)
    this.heapProfiler = new HeapProfilerClient(this.transport, this.sessionId)
    this.profiler = new ProfilerClient(this.transport, this.sessionId)
    this.runtime = new RuntimeClient(this.transport, this.sessionId)
    this.schema = new SchemaClient(this.transport, this.sessionId)
  }
  withSession(sessionId: Target.SessionID) {
    return new ChromeDevToolsClient(this.transport, sessionId)
  }
  dispose() {
    this.transport.dispose()
  }
}
