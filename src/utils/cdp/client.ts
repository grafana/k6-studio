// This file is auto-generated by generateCdpTypes.ts. DO NOT EDIT!
/* eslint-disable @typescript-eslint/no-namespace */ let id = 0
function generateId() {
  return ++id
}
type DisposeFn = () => void
type ChromeEventListener<Event = unknown> = (event: ChromeEvent<Event>) => void
export interface Transport {
  call<Return>(command: ChromeCommand): Promise<Return>
  on(event: string, listener: ChromeEventListener): DisposeFn
  off(event: string, listener: ChromeEventListener): void
}
export interface ChromeCommand {
  id: number
  sessionId: string | undefined
  method: string
  params: Record<string, unknown>
}
export interface ChromeEvent<Event = unknown> {
  sessionId?: string
  name: string
  data: Event
}
export namespace Accessibility {
  export type AXNodeId = string
  export type AXValueType =
    | 'boolean'
    | 'tristate'
    | 'booleanOrUndefined'
    | 'idref'
    | 'idrefList'
    | 'integer'
    | 'node'
    | 'nodeList'
    | 'number'
    | 'string'
    | 'computedString'
    | 'token'
    | 'tokenList'
    | 'domRelation'
    | 'role'
    | 'internalRole'
    | 'valueUndefined'
  export type AXValueSourceType =
    | 'attribute'
    | 'implicit'
    | 'style'
    | 'contents'
    | 'placeholder'
    | 'relatedElement'
  export type AXValueNativeSourceType =
    | 'description'
    | 'figcaption'
    | 'label'
    | 'labelfor'
    | 'labelwrapped'
    | 'legend'
    | 'rubyannotation'
    | 'tablecaption'
    | 'title'
    | 'other'
  export type AXValueSource = {
    type: AXValueSourceType
    value?: AXValue
    attribute?: string
    attributeValue?: AXValue
    superseded?: boolean
    nativeSource?: AXValueNativeSourceType
    nativeSourceValue?: AXValue
    invalid?: boolean
    invalidReason?: string
  }
  export type AXRelatedNode = {
    backendDOMNodeId: DOM.BackendNodeId
    idref?: string
    text?: string
  }
  export type AXProperty = { name: AXPropertyName; value: AXValue }
  export type AXValue = {
    type: AXValueType
    value?: unknown
    relatedNodes?: AXRelatedNode[]
    sources?: AXValueSource[]
  }
  export type AXPropertyName =
    | 'actions'
    | 'busy'
    | 'disabled'
    | 'editable'
    | 'focusable'
    | 'focused'
    | 'hidden'
    | 'hiddenRoot'
    | 'invalid'
    | 'keyshortcuts'
    | 'settable'
    | 'roledescription'
    | 'live'
    | 'atomic'
    | 'relevant'
    | 'root'
    | 'autocomplete'
    | 'hasPopup'
    | 'level'
    | 'multiselectable'
    | 'orientation'
    | 'multiline'
    | 'readonly'
    | 'required'
    | 'valuemin'
    | 'valuemax'
    | 'valuetext'
    | 'checked'
    | 'expanded'
    | 'modal'
    | 'pressed'
    | 'selected'
    | 'activedescendant'
    | 'controls'
    | 'describedby'
    | 'details'
    | 'errormessage'
    | 'flowto'
    | 'labelledby'
    | 'owns'
    | 'url'
  export type AXNode = {
    nodeId: AXNodeId
    ignored: boolean
    ignoredReasons?: AXProperty[]
    role?: AXValue
    chromeRole?: AXValue
    name?: AXValue
    description?: AXValue
    value?: AXValue
    properties?: AXProperty[]
    parentId?: AXNodeId
    childIds?: AXNodeId[]
    backendDOMNodeId?: DOM.BackendNodeId
    frameId?: Page.FrameId
  }
  export interface GetPartialAXTreeResult {
    nodes: AXNode[]
  }
  export interface GetFullAXTreeResult {
    nodes: AXNode[]
  }
  export interface GetRootAXNodeResult {
    node: AXNode
  }
  export interface GetAXNodeAndAncestorsResult {
    nodes: AXNode[]
  }
  export interface GetChildAXNodesResult {
    nodes: AXNode[]
  }
  export interface QueryAXTreeResult {
    nodes: AXNode[]
  }
  export interface LoadCompleteEvent {
    root: AXNode
  }
  export interface NodesUpdatedEvent {
    nodes: AXNode[]
  }
  export interface EventMap {
    loadComplete: LoadCompleteEvent
    nodesUpdated: NodesUpdatedEvent
  }
}
export namespace Animation {
  export type Animation = {
    id: string
    name: string
    pausedState: boolean
    playState: string
    playbackRate: number
    startTime: number
    currentTime: number
    type: string
    source?: AnimationEffect
    cssId?: string
    viewOrScrollTimeline?: ViewOrScrollTimeline
  }
  export type ViewOrScrollTimeline = {
    sourceNodeId?: DOM.BackendNodeId
    startOffset?: number
    endOffset?: number
    subjectNodeId?: DOM.BackendNodeId
    axis: DOM.ScrollOrientation
  }
  export type AnimationEffect = {
    delay: number
    endDelay: number
    iterationStart: number
    iterations: number
    duration: number
    direction: string
    fill: string
    backendNodeId?: DOM.BackendNodeId
    keyframesRule?: KeyframesRule
    easing: string
  }
  export type KeyframesRule = { name?: string; keyframes: KeyframeStyle[] }
  export type KeyframeStyle = { offset: string; easing: string }
  export interface GetCurrentTimeResult {
    currentTime: number
  }
  export interface GetPlaybackRateResult {
    playbackRate: number
  }
  export interface ResolveAnimationResult {
    remoteObject: Runtime.RemoteObject
  }
  export interface AnimationCanceledEvent {
    id: string
  }
  export interface AnimationCreatedEvent {
    id: string
  }
  export interface AnimationStartedEvent {
    animation: Animation
  }
  export interface AnimationUpdatedEvent {
    animation: Animation
  }
  export interface EventMap {
    animationCanceled: AnimationCanceledEvent
    animationCreated: AnimationCreatedEvent
    animationStarted: AnimationStartedEvent
    animationUpdated: AnimationUpdatedEvent
  }
}
export namespace Audits {
  export type AffectedCookie = { name: string; path: string; domain: string }
  export type AffectedRequest = { requestId?: Network.RequestId; url: string }
  export type AffectedFrame = { frameId: Page.FrameId }
  export type CookieExclusionReason =
    | 'ExcludeSameSiteUnspecifiedTreatedAsLax'
    | 'ExcludeSameSiteNoneInsecure'
    | 'ExcludeSameSiteLax'
    | 'ExcludeSameSiteStrict'
    | 'ExcludeInvalidSameParty'
    | 'ExcludeSamePartyCrossPartyContext'
    | 'ExcludeDomainNonASCII'
    | 'ExcludeThirdPartyCookieBlockedInFirstPartySet'
    | 'ExcludeThirdPartyPhaseout'
    | 'ExcludePortMismatch'
    | 'ExcludeSchemeMismatch'
  export type CookieWarningReason =
    | 'WarnSameSiteUnspecifiedCrossSiteContext'
    | 'WarnSameSiteNoneInsecure'
    | 'WarnSameSiteUnspecifiedLaxAllowUnsafe'
    | 'WarnSameSiteStrictLaxDowngradeStrict'
    | 'WarnSameSiteStrictCrossDowngradeStrict'
    | 'WarnSameSiteStrictCrossDowngradeLax'
    | 'WarnSameSiteLaxCrossDowngradeStrict'
    | 'WarnSameSiteLaxCrossDowngradeLax'
    | 'WarnAttributeValueExceedsMaxSize'
    | 'WarnDomainNonASCII'
    | 'WarnThirdPartyPhaseout'
    | 'WarnCrossSiteRedirectDowngradeChangesInclusion'
    | 'WarnDeprecationTrialMetadata'
    | 'WarnThirdPartyCookieHeuristic'
  export type CookieOperation = 'SetCookie' | 'ReadCookie'
  export type InsightType = 'GitHubResource' | 'GracePeriod' | 'Heuristics'
  export type CookieIssueInsight = {
    type: InsightType
    tableEntryUrl?: string
  }
  export type CookieIssueDetails = {
    cookie?: AffectedCookie
    rawCookieLine?: string
    cookieWarningReasons: CookieWarningReason[]
    cookieExclusionReasons: CookieExclusionReason[]
    operation: CookieOperation
    siteForCookies?: string
    cookieUrl?: string
    request?: AffectedRequest
    insight?: CookieIssueInsight
  }
  export type MixedContentResolutionStatus =
    | 'MixedContentBlocked'
    | 'MixedContentAutomaticallyUpgraded'
    | 'MixedContentWarning'
  export type MixedContentResourceType =
    | 'AttributionSrc'
    | 'Audio'
    | 'Beacon'
    | 'CSPReport'
    | 'Download'
    | 'EventSource'
    | 'Favicon'
    | 'Font'
    | 'Form'
    | 'Frame'
    | 'Image'
    | 'Import'
    | 'JSON'
    | 'Manifest'
    | 'Ping'
    | 'PluginData'
    | 'PluginResource'
    | 'Prefetch'
    | 'Resource'
    | 'Script'
    | 'ServiceWorker'
    | 'SharedWorker'
    | 'SpeculationRules'
    | 'Stylesheet'
    | 'Track'
    | 'Video'
    | 'Worker'
    | 'XMLHttpRequest'
    | 'XSLT'
  export type MixedContentIssueDetails = {
    resourceType?: MixedContentResourceType
    resolutionStatus: MixedContentResolutionStatus
    insecureURL: string
    mainResourceURL: string
    request?: AffectedRequest
    frame?: AffectedFrame
  }
  export type BlockedByResponseReason =
    | 'CoepFrameResourceNeedsCoepHeader'
    | 'CoopSandboxedIFrameCannotNavigateToCoopPage'
    | 'CorpNotSameOrigin'
    | 'CorpNotSameOriginAfterDefaultedToSameOriginByCoep'
    | 'CorpNotSameOriginAfterDefaultedToSameOriginByDip'
    | 'CorpNotSameOriginAfterDefaultedToSameOriginByCoepAndDip'
    | 'CorpNotSameSite'
    | 'SRIMessageSignatureMismatch'
  export type BlockedByResponseIssueDetails = {
    request: AffectedRequest
    parentFrame?: AffectedFrame
    blockedFrame?: AffectedFrame
    reason: BlockedByResponseReason
  }
  export type HeavyAdResolutionStatus = 'HeavyAdBlocked' | 'HeavyAdWarning'
  export type HeavyAdReason =
    | 'NetworkTotalLimit'
    | 'CpuTotalLimit'
    | 'CpuPeakLimit'
  export type HeavyAdIssueDetails = {
    resolution: HeavyAdResolutionStatus
    reason: HeavyAdReason
    frame: AffectedFrame
  }
  export type ContentSecurityPolicyViolationType =
    | 'kInlineViolation'
    | 'kEvalViolation'
    | 'kURLViolation'
    | 'kSRIViolation'
    | 'kTrustedTypesSinkViolation'
    | 'kTrustedTypesPolicyViolation'
    | 'kWasmEvalViolation'
  export type SourceCodeLocation = {
    scriptId?: Runtime.ScriptId
    url: string
    lineNumber: number
    columnNumber: number
  }
  export type ContentSecurityPolicyIssueDetails = {
    blockedURL?: string
    violatedDirective: string
    isReportOnly: boolean
    contentSecurityPolicyViolationType: ContentSecurityPolicyViolationType
    frameAncestor?: AffectedFrame
    sourceCodeLocation?: SourceCodeLocation
    violatingNodeId?: DOM.BackendNodeId
  }
  export type SharedArrayBufferIssueType = 'TransferIssue' | 'CreationIssue'
  export type SharedArrayBufferIssueDetails = {
    sourceCodeLocation: SourceCodeLocation
    isWarning: boolean
    type: SharedArrayBufferIssueType
  }
  export type LowTextContrastIssueDetails = {
    violatingNodeId: DOM.BackendNodeId
    violatingNodeSelector: string
    contrastRatio: number
    thresholdAA: number
    thresholdAAA: number
    fontSize: string
    fontWeight: string
  }
  export type CorsIssueDetails = {
    corsErrorStatus: Network.CorsErrorStatus
    isWarning: boolean
    request: AffectedRequest
    location?: SourceCodeLocation
    initiatorOrigin?: string
    resourceIPAddressSpace?: Network.IPAddressSpace
    clientSecurityState?: Network.ClientSecurityState
  }
  export type AttributionReportingIssueType =
    | 'PermissionPolicyDisabled'
    | 'UntrustworthyReportingOrigin'
    | 'InsecureContext'
    | 'InvalidHeader'
    | 'InvalidRegisterTriggerHeader'
    | 'SourceAndTriggerHeaders'
    | 'SourceIgnored'
    | 'TriggerIgnored'
    | 'OsSourceIgnored'
    | 'OsTriggerIgnored'
    | 'InvalidRegisterOsSourceHeader'
    | 'InvalidRegisterOsTriggerHeader'
    | 'WebAndOsHeaders'
    | 'NoWebOrOsSupport'
    | 'NavigationRegistrationWithoutTransientUserActivation'
    | 'InvalidInfoHeader'
    | 'NoRegisterSourceHeader'
    | 'NoRegisterTriggerHeader'
    | 'NoRegisterOsSourceHeader'
    | 'NoRegisterOsTriggerHeader'
    | 'NavigationRegistrationUniqueScopeAlreadySet'
  export type SharedDictionaryError =
    | 'UseErrorCrossOriginNoCorsRequest'
    | 'UseErrorDictionaryLoadFailure'
    | 'UseErrorMatchingDictionaryNotUsed'
    | 'UseErrorUnexpectedContentDictionaryHeader'
    | 'WriteErrorCossOriginNoCorsRequest'
    | 'WriteErrorDisallowedBySettings'
    | 'WriteErrorExpiredResponse'
    | 'WriteErrorFeatureDisabled'
    | 'WriteErrorInsufficientResources'
    | 'WriteErrorInvalidMatchField'
    | 'WriteErrorInvalidStructuredHeader'
    | 'WriteErrorNavigationRequest'
    | 'WriteErrorNoMatchField'
    | 'WriteErrorNonListMatchDestField'
    | 'WriteErrorNonSecureContext'
    | 'WriteErrorNonStringIdField'
    | 'WriteErrorNonStringInMatchDestList'
    | 'WriteErrorNonStringMatchField'
    | 'WriteErrorNonTokenTypeField'
    | 'WriteErrorRequestAborted'
    | 'WriteErrorShuttingDown'
    | 'WriteErrorTooLongIdField'
    | 'WriteErrorUnsupportedType'
  export type SRIMessageSignatureError =
    | 'MissingSignatureHeader'
    | 'MissingSignatureInputHeader'
    | 'InvalidSignatureHeader'
    | 'InvalidSignatureInputHeader'
    | 'SignatureHeaderValueIsNotByteSequence'
    | 'SignatureHeaderValueIsParameterized'
    | 'SignatureHeaderValueIsIncorrectLength'
    | 'SignatureInputHeaderMissingLabel'
    | 'SignatureInputHeaderValueNotInnerList'
    | 'SignatureInputHeaderValueMissingComponents'
    | 'SignatureInputHeaderInvalidComponentType'
    | 'SignatureInputHeaderInvalidComponentName'
    | 'SignatureInputHeaderInvalidHeaderComponentParameter'
    | 'SignatureInputHeaderInvalidDerivedComponentParameter'
    | 'SignatureInputHeaderKeyIdLength'
    | 'SignatureInputHeaderInvalidParameter'
    | 'SignatureInputHeaderMissingRequiredParameters'
    | 'ValidationFailedSignatureExpired'
    | 'ValidationFailedInvalidLength'
    | 'ValidationFailedSignatureMismatch'
    | 'ValidationFailedIntegrityMismatch'
  export type AttributionReportingIssueDetails = {
    violationType: AttributionReportingIssueType
    request?: AffectedRequest
    violatingNodeId?: DOM.BackendNodeId
    invalidParameter?: string
  }
  export type QuirksModeIssueDetails = {
    isLimitedQuirksMode: boolean
    documentNodeId: DOM.BackendNodeId
    url: string
    frameId: Page.FrameId
    loaderId: Network.LoaderId
  }
  export type NavigatorUserAgentIssueDetails = {
    url: string
    location?: SourceCodeLocation
  }
  export type SharedDictionaryIssueDetails = {
    sharedDictionaryError: SharedDictionaryError
    request: AffectedRequest
  }
  export type SRIMessageSignatureIssueDetails = {
    error: SRIMessageSignatureError
    signatureBase: string
    integrityAssertions: string[]
    request: AffectedRequest
  }
  export type GenericIssueErrorType =
    | 'FormLabelForNameError'
    | 'FormDuplicateIdForInputError'
    | 'FormInputWithNoLabelError'
    | 'FormAutocompleteAttributeEmptyError'
    | 'FormEmptyIdAndNameAttributesForInputError'
    | 'FormAriaLabelledByToNonExistingId'
    | 'FormInputAssignedAutocompleteValueToIdOrNameAttributeError'
    | 'FormLabelHasNeitherForNorNestedInput'
    | 'FormLabelForMatchesNonExistingIdError'
    | 'FormInputHasWrongButWellIntendedAutocompleteValueError'
    | 'ResponseWasBlockedByORB'
  export type GenericIssueDetails = {
    errorType: GenericIssueErrorType
    frameId?: Page.FrameId
    violatingNodeId?: DOM.BackendNodeId
    violatingNodeAttribute?: string
    request?: AffectedRequest
  }
  export type DeprecationIssueDetails = {
    affectedFrame?: AffectedFrame
    sourceCodeLocation: SourceCodeLocation
    type: string
  }
  export type BounceTrackingIssueDetails = { trackingSites: string[] }
  export type CookieDeprecationMetadataIssueDetails = {
    allowedSites: string[]
    optOutPercentage: number
    isOptOutTopLevel: boolean
    operation: CookieOperation
  }
  export type ClientHintIssueReason =
    | 'MetaTagAllowListInvalidOrigin'
    | 'MetaTagModifiedHTML'
  export type FederatedAuthRequestIssueDetails = {
    federatedAuthRequestIssueReason: FederatedAuthRequestIssueReason
  }
  export type FederatedAuthRequestIssueReason =
    | 'ShouldEmbargo'
    | 'TooManyRequests'
    | 'WellKnownHttpNotFound'
    | 'WellKnownNoResponse'
    | 'WellKnownInvalidResponse'
    | 'WellKnownListEmpty'
    | 'WellKnownInvalidContentType'
    | 'ConfigNotInWellKnown'
    | 'WellKnownTooBig'
    | 'ConfigHttpNotFound'
    | 'ConfigNoResponse'
    | 'ConfigInvalidResponse'
    | 'ConfigInvalidContentType'
    | 'ClientMetadataHttpNotFound'
    | 'ClientMetadataNoResponse'
    | 'ClientMetadataInvalidResponse'
    | 'ClientMetadataInvalidContentType'
    | 'IdpNotPotentiallyTrustworthy'
    | 'DisabledInSettings'
    | 'DisabledInFlags'
    | 'ErrorFetchingSignin'
    | 'InvalidSigninResponse'
    | 'AccountsHttpNotFound'
    | 'AccountsNoResponse'
    | 'AccountsInvalidResponse'
    | 'AccountsListEmpty'
    | 'AccountsInvalidContentType'
    | 'IdTokenHttpNotFound'
    | 'IdTokenNoResponse'
    | 'IdTokenInvalidResponse'
    | 'IdTokenIdpErrorResponse'
    | 'IdTokenCrossSiteIdpErrorResponse'
    | 'IdTokenInvalidRequest'
    | 'IdTokenInvalidContentType'
    | 'ErrorIdToken'
    | 'Canceled'
    | 'RpPageNotVisible'
    | 'SilentMediationFailure'
    | 'ThirdPartyCookiesBlocked'
    | 'NotSignedInWithIdp'
    | 'MissingTransientUserActivation'
    | 'ReplacedByActiveMode'
    | 'InvalidFieldsSpecified'
    | 'RelyingPartyOriginIsOpaque'
    | 'TypeNotMatching'
    | 'UiDismissedNoEmbargo'
    | 'CorsError'
    | 'SuppressedBySegmentationPlatform'
  export type FederatedAuthUserInfoRequestIssueDetails = {
    federatedAuthUserInfoRequestIssueReason: FederatedAuthUserInfoRequestIssueReason
  }
  export type FederatedAuthUserInfoRequestIssueReason =
    | 'NotSameOrigin'
    | 'NotIframe'
    | 'NotPotentiallyTrustworthy'
    | 'NoApiPermission'
    | 'NotSignedInWithIdp'
    | 'NoAccountSharingPermission'
    | 'InvalidConfigOrWellKnown'
    | 'InvalidAccountsResponse'
    | 'NoReturningUserFromFetchedAccounts'
  export type ClientHintIssueDetails = {
    sourceCodeLocation: SourceCodeLocation
    clientHintIssueReason: ClientHintIssueReason
  }
  export type FailedRequestInfo = {
    url: string
    failureMessage: string
    requestId?: Network.RequestId
  }
  export type PartitioningBlobURLInfo =
    | 'BlockedCrossPartitionFetching'
    | 'EnforceNoopenerForNavigation'
  export type PartitioningBlobURLIssueDetails = {
    url: string
    partitioningBlobURLInfo: PartitioningBlobURLInfo
  }
  export type SelectElementAccessibilityIssueReason =
    | 'DisallowedSelectChild'
    | 'DisallowedOptGroupChild'
    | 'NonPhrasingContentOptionChild'
    | 'InteractiveContentOptionChild'
    | 'InteractiveContentLegendChild'
  export type SelectElementAccessibilityIssueDetails = {
    nodeId: DOM.BackendNodeId
    selectElementAccessibilityIssueReason: SelectElementAccessibilityIssueReason
    hasDisallowedAttributes: boolean
  }
  export type StyleSheetLoadingIssueReason = 'LateImportRule' | 'RequestFailed'
  export type StylesheetLoadingIssueDetails = {
    sourceCodeLocation: SourceCodeLocation
    styleSheetLoadingIssueReason: StyleSheetLoadingIssueReason
    failedRequestInfo?: FailedRequestInfo
  }
  export type PropertyRuleIssueReason =
    | 'InvalidSyntax'
    | 'InvalidInitialValue'
    | 'InvalidInherits'
    | 'InvalidName'
  export type PropertyRuleIssueDetails = {
    sourceCodeLocation: SourceCodeLocation
    propertyRuleIssueReason: PropertyRuleIssueReason
    propertyValue?: string
  }
  export type UserReidentificationIssueType =
    | 'BlockedFrameNavigation'
    | 'BlockedSubresource'
  export type UserReidentificationIssueDetails = {
    type: UserReidentificationIssueType
    request?: AffectedRequest
  }
  export type InspectorIssueCode =
    | 'CookieIssue'
    | 'MixedContentIssue'
    | 'BlockedByResponseIssue'
    | 'HeavyAdIssue'
    | 'ContentSecurityPolicyIssue'
    | 'SharedArrayBufferIssue'
    | 'LowTextContrastIssue'
    | 'CorsIssue'
    | 'AttributionReportingIssue'
    | 'QuirksModeIssue'
    | 'PartitioningBlobURLIssue'
    | 'NavigatorUserAgentIssue'
    | 'GenericIssue'
    | 'DeprecationIssue'
    | 'ClientHintIssue'
    | 'FederatedAuthRequestIssue'
    | 'BounceTrackingIssue'
    | 'CookieDeprecationMetadataIssue'
    | 'StylesheetLoadingIssue'
    | 'FederatedAuthUserInfoRequestIssue'
    | 'PropertyRuleIssue'
    | 'SharedDictionaryIssue'
    | 'SelectElementAccessibilityIssue'
    | 'SRIMessageSignatureIssue'
    | 'UserReidentificationIssue'
  export type InspectorIssueDetails = {
    cookieIssueDetails?: CookieIssueDetails
    mixedContentIssueDetails?: MixedContentIssueDetails
    blockedByResponseIssueDetails?: BlockedByResponseIssueDetails
    heavyAdIssueDetails?: HeavyAdIssueDetails
    contentSecurityPolicyIssueDetails?: ContentSecurityPolicyIssueDetails
    sharedArrayBufferIssueDetails?: SharedArrayBufferIssueDetails
    lowTextContrastIssueDetails?: LowTextContrastIssueDetails
    corsIssueDetails?: CorsIssueDetails
    attributionReportingIssueDetails?: AttributionReportingIssueDetails
    quirksModeIssueDetails?: QuirksModeIssueDetails
    partitioningBlobURLIssueDetails?: PartitioningBlobURLIssueDetails
    navigatorUserAgentIssueDetails?: NavigatorUserAgentIssueDetails
    genericIssueDetails?: GenericIssueDetails
    deprecationIssueDetails?: DeprecationIssueDetails
    clientHintIssueDetails?: ClientHintIssueDetails
    federatedAuthRequestIssueDetails?: FederatedAuthRequestIssueDetails
    bounceTrackingIssueDetails?: BounceTrackingIssueDetails
    cookieDeprecationMetadataIssueDetails?: CookieDeprecationMetadataIssueDetails
    stylesheetLoadingIssueDetails?: StylesheetLoadingIssueDetails
    propertyRuleIssueDetails?: PropertyRuleIssueDetails
    federatedAuthUserInfoRequestIssueDetails?: FederatedAuthUserInfoRequestIssueDetails
    sharedDictionaryIssueDetails?: SharedDictionaryIssueDetails
    selectElementAccessibilityIssueDetails?: SelectElementAccessibilityIssueDetails
    sriMessageSignatureIssueDetails?: SRIMessageSignatureIssueDetails
    userReidentificationIssueDetails?: UserReidentificationIssueDetails
  }
  export type IssueId = string
  export type InspectorIssue = {
    code: InspectorIssueCode
    details: InspectorIssueDetails
    issueId?: IssueId
  }
  export interface GetEncodedResponseResult {
    body: string
    originalSize: number
    encodedSize: number
  }
  export interface CheckFormsIssuesResult {
    formIssues: GenericIssueDetails[]
  }
  export interface IssueAddedEvent {
    issue: InspectorIssue
  }
  export interface EventMap {
    issueAdded: IssueAddedEvent
  }
}
export namespace Extensions {
  export type StorageArea = 'session' | 'local' | 'sync' | 'managed'
  export interface LoadUnpackedResult {
    id: string
  }
  export interface GetStorageItemsResult {
    data: Record<string, unknown>
  }
}
export namespace Autofill {
  export type CreditCard = {
    number: string
    name: string
    expiryMonth: string
    expiryYear: string
    cvc: string
  }
  export type AddressField = { name: string; value: string }
  export type AddressFields = { fields: AddressField[] }
  export type Address = { fields: AddressField[] }
  export type AddressUI = { addressFields: AddressFields[] }
  export type FillingStrategy = 'autocompleteAttribute' | 'autofillInferred'
  export type FilledField = {
    htmlType: string
    id: string
    name: string
    value: string
    autofillType: string
    fillingStrategy: FillingStrategy
    frameId: Page.FrameId
    fieldId: DOM.BackendNodeId
  }
  export interface AddressFormFilledEvent {
    filledFields: FilledField[]
    addressUi: AddressUI
  }
  export interface EventMap {
    addressFormFilled: AddressFormFilledEvent
  }
}
export namespace BackgroundService {
  export type ServiceName =
    | 'backgroundFetch'
    | 'backgroundSync'
    | 'pushMessaging'
    | 'notifications'
    | 'paymentHandler'
    | 'periodicBackgroundSync'
  export type EventMetadata = { key: string; value: string }
  export type BackgroundServiceEvent = {
    timestamp: Network.TimeSinceEpoch
    origin: string
    serviceWorkerRegistrationId: ServiceWorker.RegistrationID
    service: ServiceName
    eventName: string
    instanceId: string
    eventMetadata: EventMetadata[]
    storageKey: string
  }
  export interface RecordingStateChangedEvent {
    isRecording: boolean
    service: ServiceName
  }
  export interface BackgroundServiceEventReceivedEvent {
    backgroundServiceEvent: BackgroundServiceEvent
  }
  export interface EventMap {
    recordingStateChanged: RecordingStateChangedEvent
    backgroundServiceEventReceived: BackgroundServiceEventReceivedEvent
  }
}
export namespace Browser {
  export type BrowserContextID = string
  export type WindowID = number
  export type WindowState = 'normal' | 'minimized' | 'maximized' | 'fullscreen'
  export type Bounds = {
    left?: number
    top?: number
    width?: number
    height?: number
    windowState?: WindowState
  }
  export type PermissionType =
    | 'ar'
    | 'audioCapture'
    | 'automaticFullscreen'
    | 'backgroundFetch'
    | 'backgroundSync'
    | 'cameraPanTiltZoom'
    | 'capturedSurfaceControl'
    | 'clipboardReadWrite'
    | 'clipboardSanitizedWrite'
    | 'displayCapture'
    | 'durableStorage'
    | 'geolocation'
    | 'handTracking'
    | 'idleDetection'
    | 'keyboardLock'
    | 'localFonts'
    | 'localNetworkAccess'
    | 'midi'
    | 'midiSysex'
    | 'nfc'
    | 'notifications'
    | 'paymentHandler'
    | 'periodicBackgroundSync'
    | 'pointerLock'
    | 'protectedMediaIdentifier'
    | 'sensors'
    | 'smartCard'
    | 'speakerSelection'
    | 'storageAccess'
    | 'topLevelStorageAccess'
    | 'videoCapture'
    | 'vr'
    | 'wakeLockScreen'
    | 'wakeLockSystem'
    | 'webAppInstallation'
    | 'webPrinting'
    | 'windowManagement'
  export type PermissionSetting = 'granted' | 'denied' | 'prompt'
  export type PermissionDescriptor = {
    name: string
    sysex?: boolean
    userVisibleOnly?: boolean
    allowWithoutSanitization?: boolean
    allowWithoutGesture?: boolean
    panTiltZoom?: boolean
  }
  export type BrowserCommandId = 'openTabSearch' | 'closeTabSearch' | 'openGlic'
  export type Bucket = { low: number; high: number; count: number }
  export type Histogram = {
    name: string
    sum: number
    count: number
    buckets: Bucket[]
  }
  export type PrivacySandboxAPI =
    | 'BiddingAndAuctionServices'
    | 'TrustedKeyValue'
  export interface GetVersionResult {
    protocolVersion: string
    product: string
    revision: string
    userAgent: string
    jsVersion: string
  }
  export interface GetBrowserCommandLineResult {
    arguments: string[]
  }
  export interface GetHistogramsResult {
    histograms: Histogram[]
  }
  export interface GetHistogramResult {
    histogram: Histogram
  }
  export interface GetWindowBoundsResult {
    bounds: Bounds
  }
  export interface GetWindowForTargetResult {
    windowId: WindowID
    bounds: Bounds
  }
  export interface DownloadWillBeginEvent {
    frameId: Page.FrameId
    guid: string
    url: string
    suggestedFilename: string
  }
  export interface DownloadProgressEvent {
    guid: string
    totalBytes: number
    receivedBytes: number
    state: string
    filePath: string
  }
  export interface EventMap {
    downloadWillBegin: DownloadWillBeginEvent
    downloadProgress: DownloadProgressEvent
  }
}
export namespace CSS {
  export type StyleSheetId = string
  export type StyleSheetOrigin =
    | 'injected'
    | 'user-agent'
    | 'inspector'
    | 'regular'
  export type PseudoElementMatches = {
    pseudoType: DOM.PseudoType
    pseudoIdentifier?: string
    matches: RuleMatch[]
  }
  export type CSSAnimationStyle = { name?: string; style: CSSStyle }
  export type InheritedStyleEntry = {
    inlineStyle?: CSSStyle
    matchedCSSRules: RuleMatch[]
  }
  export type InheritedAnimatedStyleEntry = {
    animationStyles?: CSSAnimationStyle[]
    transitionsStyle?: CSSStyle
  }
  export type InheritedPseudoElementMatches = {
    pseudoElements: PseudoElementMatches[]
  }
  export type RuleMatch = { rule: CSSRule; matchingSelectors: number[] }
  export type Value = {
    text: string
    range?: SourceRange
    specificity?: Specificity
  }
  export type Specificity = { a: number; b: number; c: number }
  export type SelectorList = { selectors: Value[]; text: string }
  export type CSSStyleSheetHeader = {
    styleSheetId: StyleSheetId
    frameId: Page.FrameId
    sourceURL: string
    sourceMapURL?: string
    origin: StyleSheetOrigin
    title: string
    ownerNode?: DOM.BackendNodeId
    disabled: boolean
    hasSourceURL?: boolean
    isInline: boolean
    isMutable: boolean
    isConstructed: boolean
    startLine: number
    startColumn: number
    length: number
    endLine: number
    endColumn: number
    loadingFailed?: boolean
  }
  export type CSSRule = {
    styleSheetId?: StyleSheetId
    selectorList: SelectorList
    nestingSelectors?: string[]
    origin: StyleSheetOrigin
    style: CSSStyle
    media?: CSSMedia[]
    containerQueries?: CSSContainerQuery[]
    supports?: CSSSupports[]
    layers?: CSSLayer[]
    scopes?: CSSScope[]
    ruleTypes?: CSSRuleType[]
    startingStyles?: CSSStartingStyle[]
  }
  export type CSSRuleType =
    | 'MediaRule'
    | 'SupportsRule'
    | 'ContainerRule'
    | 'LayerRule'
    | 'ScopeRule'
    | 'StyleRule'
    | 'StartingStyleRule'
  export type RuleUsage = {
    styleSheetId: StyleSheetId
    startOffset: number
    endOffset: number
    used: boolean
  }
  export type SourceRange = {
    startLine: number
    startColumn: number
    endLine: number
    endColumn: number
  }
  export type ShorthandEntry = {
    name: string
    value: string
    important?: boolean
  }
  export type CSSComputedStyleProperty = { name: string; value: string }
  export type CSSStyle = {
    styleSheetId?: StyleSheetId
    cssProperties: CSSProperty[]
    shorthandEntries: ShorthandEntry[]
    cssText?: string
    range?: SourceRange
  }
  export type CSSProperty = {
    name: string
    value: string
    important?: boolean
    implicit?: boolean
    text?: string
    parsedOk?: boolean
    disabled?: boolean
    range?: SourceRange
    longhandProperties?: CSSProperty[]
  }
  export type CSSMedia = {
    text: string
    source: string
    sourceURL?: string
    range?: SourceRange
    styleSheetId?: StyleSheetId
    mediaList?: MediaQuery[]
  }
  export type MediaQuery = {
    expressions: MediaQueryExpression[]
    active: boolean
  }
  export type MediaQueryExpression = {
    value: number
    unit: string
    feature: string
    valueRange?: SourceRange
    computedLength?: number
  }
  export type CSSContainerQuery = {
    text: string
    range?: SourceRange
    styleSheetId?: StyleSheetId
    name?: string
    physicalAxes?: DOM.PhysicalAxes
    logicalAxes?: DOM.LogicalAxes
    queriesScrollState?: boolean
  }
  export type CSSSupports = {
    text: string
    active: boolean
    range?: SourceRange
    styleSheetId?: StyleSheetId
  }
  export type CSSScope = {
    text: string
    range?: SourceRange
    styleSheetId?: StyleSheetId
  }
  export type CSSLayer = {
    text: string
    range?: SourceRange
    styleSheetId?: StyleSheetId
  }
  export type CSSStartingStyle = {
    range?: SourceRange
    styleSheetId?: StyleSheetId
  }
  export type CSSLayerData = {
    name: string
    subLayers?: CSSLayerData[]
    order: number
  }
  export type PlatformFontUsage = {
    familyName: string
    postScriptName: string
    isCustomFont: boolean
    glyphCount: number
  }
  export type FontVariationAxis = {
    tag: string
    name: string
    minValue: number
    maxValue: number
    defaultValue: number
  }
  export type FontFace = {
    fontFamily: string
    fontStyle: string
    fontVariant: string
    fontWeight: string
    fontStretch: string
    fontDisplay: string
    unicodeRange: string
    src: string
    platformFontFamily: string
    fontVariationAxes?: FontVariationAxis[]
  }
  export type CSSTryRule = {
    styleSheetId?: StyleSheetId
    origin: StyleSheetOrigin
    style: CSSStyle
  }
  export type CSSPositionTryRule = {
    name: Value
    styleSheetId?: StyleSheetId
    origin: StyleSheetOrigin
    style: CSSStyle
    active: boolean
  }
  export type CSSKeyframesRule = {
    animationName: Value
    keyframes: CSSKeyframeRule[]
  }
  export type CSSPropertyRegistration = {
    propertyName: string
    initialValue?: Value
    inherits: boolean
    syntax: string
  }
  export type CSSFontPaletteValuesRule = {
    styleSheetId?: StyleSheetId
    origin: StyleSheetOrigin
    fontPaletteName: Value
    style: CSSStyle
  }
  export type CSSPropertyRule = {
    styleSheetId?: StyleSheetId
    origin: StyleSheetOrigin
    propertyName: Value
    style: CSSStyle
  }
  export type CSSFunctionParameter = { name: string; type: string }
  export type CSSFunctionConditionNode = {
    media?: CSSMedia
    containerQueries?: CSSContainerQuery
    supports?: CSSSupports
    children: CSSFunctionNode[]
    conditionText: string
  }
  export type CSSFunctionNode = {
    condition?: CSSFunctionConditionNode
    style?: CSSStyle
  }
  export type CSSFunctionRule = {
    name: Value
    styleSheetId?: StyleSheetId
    origin: StyleSheetOrigin
    parameters: CSSFunctionParameter[]
    children: CSSFunctionNode[]
  }
  export type CSSKeyframeRule = {
    styleSheetId?: StyleSheetId
    origin: StyleSheetOrigin
    keyText: Value
    style: CSSStyle
  }
  export type StyleDeclarationEdit = {
    styleSheetId: StyleSheetId
    range: SourceRange
    text: string
  }
  export interface AddRuleResult {
    rule: CSSRule
  }
  export interface CollectClassNamesResult {
    classNames: string[]
  }
  export interface CreateStyleSheetResult {
    styleSheetId: StyleSheetId
  }
  export interface GetBackgroundColorsResult {
    backgroundColors: string[]
    computedFontSize: string
    computedFontWeight: string
  }
  export interface GetComputedStyleForNodeResult {
    computedStyle: CSSComputedStyleProperty[]
  }
  export interface ResolveValuesResult {
    results: string[]
  }
  export interface GetLonghandPropertiesResult {
    longhandProperties: CSSProperty[]
  }
  export interface GetInlineStylesForNodeResult {
    inlineStyle: CSSStyle
    attributesStyle: CSSStyle
  }
  export interface GetAnimatedStylesForNodeResult {
    animationStyles: CSSAnimationStyle[]
    transitionsStyle: CSSStyle
    inherited: InheritedAnimatedStyleEntry[]
  }
  export interface GetMatchedStylesForNodeResult {
    inlineStyle: CSSStyle
    attributesStyle: CSSStyle
    matchedCSSRules: RuleMatch[]
    pseudoElements: PseudoElementMatches[]
    inherited: InheritedStyleEntry[]
    inheritedPseudoElements: InheritedPseudoElementMatches[]
    cssKeyframesRules: CSSKeyframesRule[]
    cssPositionTryRules: CSSPositionTryRule[]
    activePositionFallbackIndex: number
    cssPropertyRules: CSSPropertyRule[]
    cssPropertyRegistrations: CSSPropertyRegistration[]
    cssFontPaletteValuesRule: CSSFontPaletteValuesRule
    parentLayoutNodeId: DOM.NodeId
    cssFunctionRules: CSSFunctionRule[]
  }
  export interface GetMediaQueriesResult {
    medias: CSSMedia[]
  }
  export interface GetPlatformFontsForNodeResult {
    fonts: PlatformFontUsage[]
  }
  export interface GetStyleSheetTextResult {
    text: string
  }
  export interface GetLayersForNodeResult {
    rootLayer: CSSLayerData
  }
  export interface GetLocationForSelectorResult {
    ranges: SourceRange[]
  }
  export interface TakeComputedStyleUpdatesResult {
    nodeIds: DOM.NodeId[]
  }
  export interface SetPropertyRulePropertyNameResult {
    propertyName: Value
  }
  export interface SetKeyframeKeyResult {
    keyText: Value
  }
  export interface SetMediaTextResult {
    media: CSSMedia
  }
  export interface SetContainerQueryTextResult {
    containerQuery: CSSContainerQuery
  }
  export interface SetSupportsTextResult {
    supports: CSSSupports
  }
  export interface SetScopeTextResult {
    scope: CSSScope
  }
  export interface SetRuleSelectorResult {
    selectorList: SelectorList
  }
  export interface SetStyleSheetTextResult {
    sourceMapURL: string
  }
  export interface SetStyleTextsResult {
    styles: CSSStyle[]
  }
  export interface StopRuleUsageTrackingResult {
    ruleUsage: RuleUsage[]
  }
  export interface TakeCoverageDeltaResult {
    coverage: RuleUsage[]
    timestamp: number
  }
  export interface FontsUpdatedEvent {
    font: FontFace
  }
  export interface MediaQueryResultChangedEvent {}
  export interface StyleSheetAddedEvent {
    header: CSSStyleSheetHeader
  }
  export interface StyleSheetChangedEvent {
    styleSheetId: StyleSheetId
  }
  export interface StyleSheetRemovedEvent {
    styleSheetId: StyleSheetId
  }
  export interface ComputedStyleUpdatedEvent {
    nodeId: DOM.NodeId
  }
  export interface EventMap {
    fontsUpdated: FontsUpdatedEvent
    mediaQueryResultChanged: MediaQueryResultChangedEvent
    styleSheetAdded: StyleSheetAddedEvent
    styleSheetChanged: StyleSheetChangedEvent
    styleSheetRemoved: StyleSheetRemovedEvent
    computedStyleUpdated: ComputedStyleUpdatedEvent
  }
}
export namespace CacheStorage {
  export type CacheId = string
  export type CachedResponseType =
    | 'basic'
    | 'cors'
    | 'default'
    | 'error'
    | 'opaqueResponse'
    | 'opaqueRedirect'
  export type DataEntry = {
    requestURL: string
    requestMethod: string
    requestHeaders: Header[]
    responseTime: number
    responseStatus: number
    responseStatusText: string
    responseType: CachedResponseType
    responseHeaders: Header[]
  }
  export type Cache = {
    cacheId: CacheId
    securityOrigin: string
    storageKey: string
    storageBucket?: Storage.StorageBucket
    cacheName: string
  }
  export type Header = { name: string; value: string }
  export type CachedResponse = { body: string }
  export interface RequestCacheNamesResult {
    caches: Cache[]
  }
  export interface RequestCachedResponseResult {
    response: CachedResponse
  }
  export interface RequestEntriesResult {
    cacheDataEntries: DataEntry[]
    returnCount: number
  }
}
export namespace Cast {
  export type Sink = { name: string; id: string; session?: string }
  export interface SinksUpdatedEvent {
    sinks: Sink[]
  }
  export interface IssueUpdatedEvent {
    issueMessage: string
  }
  export interface EventMap {
    sinksUpdated: SinksUpdatedEvent
    issueUpdated: IssueUpdatedEvent
  }
}
export namespace DOM {
  export type NodeId = number
  export type BackendNodeId = number
  export type BackendNode = {
    nodeType: number
    nodeName: string
    backendNodeId: BackendNodeId
  }
  export type PseudoType =
    | 'first-line'
    | 'first-letter'
    | 'checkmark'
    | 'before'
    | 'after'
    | 'picker-icon'
    | 'marker'
    | 'backdrop'
    | 'column'
    | 'selection'
    | 'search-text'
    | 'target-text'
    | 'spelling-error'
    | 'grammar-error'
    | 'highlight'
    | 'first-line-inherited'
    | 'scroll-marker'
    | 'scroll-marker-group'
    | 'scroll-button'
    | 'scrollbar'
    | 'scrollbar-thumb'
    | 'scrollbar-button'
    | 'scrollbar-track'
    | 'scrollbar-track-piece'
    | 'scrollbar-corner'
    | 'resizer'
    | 'input-list-button'
    | 'view-transition'
    | 'view-transition-group'
    | 'view-transition-image-pair'
    | 'view-transition-group-children'
    | 'view-transition-old'
    | 'view-transition-new'
    | 'placeholder'
    | 'file-selector-button'
    | 'details-content'
    | 'picker'
    | 'permission-icon'
  export type ShadowRootType = 'user-agent' | 'open' | 'closed'
  export type CompatibilityMode =
    | 'QuirksMode'
    | 'LimitedQuirksMode'
    | 'NoQuirksMode'
  export type PhysicalAxes = 'Horizontal' | 'Vertical' | 'Both'
  export type LogicalAxes = 'Inline' | 'Block' | 'Both'
  export type ScrollOrientation = 'horizontal' | 'vertical'
  export type Node = {
    nodeId: NodeId
    parentId?: NodeId
    backendNodeId: BackendNodeId
    nodeType: number
    nodeName: string
    localName: string
    nodeValue: string
    childNodeCount?: number
    children?: Node[]
    attributes?: string[]
    documentURL?: string
    baseURL?: string
    publicId?: string
    systemId?: string
    internalSubset?: string
    xmlVersion?: string
    name?: string
    value?: string
    pseudoType?: PseudoType
    pseudoIdentifier?: string
    shadowRootType?: ShadowRootType
    frameId?: Page.FrameId
    contentDocument?: Node
    shadowRoots?: Node[]
    templateContent?: Node
    pseudoElements?: Node[]
    importedDocument?: Node
    distributedNodes?: BackendNode[]
    isSVG?: boolean
    compatibilityMode?: CompatibilityMode
    assignedSlot?: BackendNode
    isScrollable?: boolean
  }
  export type DetachedElementInfo = {
    treeNode: Node
    retainedNodeIds: NodeId[]
  }
  export type RGBA = { r: number; g: number; b: number; a?: number }
  export type Quad = number[]
  export type BoxModel = {
    content: Quad
    padding: Quad
    border: Quad
    margin: Quad
    width: number
    height: number
    shapeOutside?: ShapeOutsideInfo
  }
  export type ShapeOutsideInfo = {
    bounds: Quad
    shape: unknown[]
    marginShape: unknown[]
  }
  export type Rect = { x: number; y: number; width: number; height: number }
  export type CSSComputedStyleProperty = { name: string; value: string }
  export interface CollectClassNamesFromSubtreeResult {
    classNames: string[]
  }
  export interface CopyToResult {
    nodeId: NodeId
  }
  export interface DescribeNodeResult {
    node: Node
  }
  export interface GetAttributesResult {
    attributes: string[]
  }
  export interface GetBoxModelResult {
    model: BoxModel
  }
  export interface GetContentQuadsResult {
    quads: Quad[]
  }
  export interface GetDocumentResult {
    root: Node
  }
  export interface GetFlattenedDocumentResult {
    nodes: Node[]
  }
  export interface GetNodesForSubtreeByStyleResult {
    nodeIds: NodeId[]
  }
  export interface GetNodeForLocationResult {
    backendNodeId: BackendNodeId
    frameId: Page.FrameId
    nodeId: NodeId
  }
  export interface GetOuterHTMLResult {
    outerHTML: string
  }
  export interface GetRelayoutBoundaryResult {
    nodeId: NodeId
  }
  export interface GetSearchResultsResult {
    nodeIds: NodeId[]
  }
  export interface MoveToResult {
    nodeId: NodeId
  }
  export interface PerformSearchResult {
    searchId: string
    resultCount: number
  }
  export interface PushNodeByPathToFrontendResult {
    nodeId: NodeId
  }
  export interface PushNodesByBackendIdsToFrontendResult {
    nodeIds: NodeId[]
  }
  export interface QuerySelectorResult {
    nodeId: NodeId
  }
  export interface QuerySelectorAllResult {
    nodeIds: NodeId[]
  }
  export interface GetTopLayerElementsResult {
    nodeIds: NodeId[]
  }
  export interface GetElementByRelationResult {
    nodeId: NodeId
  }
  export interface RequestNodeResult {
    nodeId: NodeId
  }
  export interface ResolveNodeResult {
    object: Runtime.RemoteObject
  }
  export interface GetNodeStackTracesResult {
    creation: Runtime.StackTrace
  }
  export interface GetFileInfoResult {
    path: string
  }
  export interface GetDetachedDomNodesResult {
    detachedNodes: DetachedElementInfo[]
  }
  export interface SetNodeNameResult {
    nodeId: NodeId
  }
  export interface GetFrameOwnerResult {
    backendNodeId: BackendNodeId
    nodeId: NodeId
  }
  export interface GetContainerForNodeResult {
    nodeId: NodeId
  }
  export interface GetQueryingDescendantsForContainerResult {
    nodeIds: NodeId[]
  }
  export interface GetAnchorElementResult {
    nodeId: NodeId
  }
  export interface AttributeModifiedEvent {
    nodeId: NodeId
    name: string
    value: string
  }
  export interface AttributeRemovedEvent {
    nodeId: NodeId
    name: string
  }
  export interface CharacterDataModifiedEvent {
    nodeId: NodeId
    characterData: string
  }
  export interface ChildNodeCountUpdatedEvent {
    nodeId: NodeId
    childNodeCount: number
  }
  export interface ChildNodeInsertedEvent {
    parentNodeId: NodeId
    previousNodeId: NodeId
    node: Node
  }
  export interface ChildNodeRemovedEvent {
    parentNodeId: NodeId
    nodeId: NodeId
  }
  export interface DistributedNodesUpdatedEvent {
    insertionPointId: NodeId
    distributedNodes: BackendNode[]
  }
  export interface DocumentUpdatedEvent {}
  export interface InlineStyleInvalidatedEvent {
    nodeIds: NodeId[]
  }
  export interface PseudoElementAddedEvent {
    parentId: NodeId
    pseudoElement: Node
  }
  export interface TopLayerElementsUpdatedEvent {}
  export interface ScrollableFlagUpdatedEvent {
    nodeId: DOM.NodeId
    isScrollable: boolean
  }
  export interface PseudoElementRemovedEvent {
    parentId: NodeId
    pseudoElementId: NodeId
  }
  export interface SetChildNodesEvent {
    parentId: NodeId
    nodes: Node[]
  }
  export interface ShadowRootPoppedEvent {
    hostId: NodeId
    rootId: NodeId
  }
  export interface ShadowRootPushedEvent {
    hostId: NodeId
    root: Node
  }
  export interface EventMap {
    attributeModified: AttributeModifiedEvent
    attributeRemoved: AttributeRemovedEvent
    characterDataModified: CharacterDataModifiedEvent
    childNodeCountUpdated: ChildNodeCountUpdatedEvent
    childNodeInserted: ChildNodeInsertedEvent
    childNodeRemoved: ChildNodeRemovedEvent
    distributedNodesUpdated: DistributedNodesUpdatedEvent
    documentUpdated: DocumentUpdatedEvent
    inlineStyleInvalidated: InlineStyleInvalidatedEvent
    pseudoElementAdded: PseudoElementAddedEvent
    topLayerElementsUpdated: TopLayerElementsUpdatedEvent
    scrollableFlagUpdated: ScrollableFlagUpdatedEvent
    pseudoElementRemoved: PseudoElementRemovedEvent
    setChildNodes: SetChildNodesEvent
    shadowRootPopped: ShadowRootPoppedEvent
    shadowRootPushed: ShadowRootPushedEvent
  }
}
export namespace DOMDebugger {
  export type DOMBreakpointType =
    | 'subtree-modified'
    | 'attribute-modified'
    | 'node-removed'
  export type CSPViolationType =
    | 'trustedtype-sink-violation'
    | 'trustedtype-policy-violation'
  export type EventListener = {
    type: string
    useCapture: boolean
    passive: boolean
    once: boolean
    scriptId: Runtime.ScriptId
    lineNumber: number
    columnNumber: number
    handler?: Runtime.RemoteObject
    originalHandler?: Runtime.RemoteObject
    backendNodeId?: DOM.BackendNodeId
  }
  export interface GetEventListenersResult {
    listeners: EventListener[]
  }
}
export namespace EventBreakpoints {}
export namespace DOMSnapshot {
  export type DOMNode = {
    nodeType: number
    nodeName: string
    nodeValue: string
    textValue?: string
    inputValue?: string
    inputChecked?: boolean
    optionSelected?: boolean
    backendNodeId: DOM.BackendNodeId
    childNodeIndexes?: number[]
    attributes?: NameValue[]
    pseudoElementIndexes?: number[]
    layoutNodeIndex?: number
    documentURL?: string
    baseURL?: string
    contentLanguage?: string
    documentEncoding?: string
    publicId?: string
    systemId?: string
    frameId?: Page.FrameId
    contentDocumentIndex?: number
    pseudoType?: DOM.PseudoType
    shadowRootType?: DOM.ShadowRootType
    isClickable?: boolean
    eventListeners?: DOMDebugger.EventListener[]
    currentSourceURL?: string
    originURL?: string
    scrollOffsetX?: number
    scrollOffsetY?: number
  }
  export type InlineTextBox = {
    boundingBox: DOM.Rect
    startCharacterIndex: number
    numCharacters: number
  }
  export type LayoutTreeNode = {
    domNodeIndex: number
    boundingBox: DOM.Rect
    layoutText?: string
    inlineTextNodes?: InlineTextBox[]
    styleIndex?: number
    paintOrder?: number
    isStackingContext?: boolean
  }
  export type ComputedStyle = { properties: NameValue[] }
  export type NameValue = { name: string; value: string }
  export type StringIndex = number
  export type ArrayOfStrings = StringIndex[]
  export type RareStringData = { index: number[]; value: StringIndex[] }
  export type RareBooleanData = { index: number[] }
  export type RareIntegerData = { index: number[]; value: number[] }
  export type Rectangle = number[]
  export type DocumentSnapshot = {
    documentURL: StringIndex
    title: StringIndex
    baseURL: StringIndex
    contentLanguage: StringIndex
    encodingName: StringIndex
    publicId: StringIndex
    systemId: StringIndex
    frameId: StringIndex
    nodes: NodeTreeSnapshot
    layout: LayoutTreeSnapshot
    textBoxes: TextBoxSnapshot
    scrollOffsetX?: number
    scrollOffsetY?: number
    contentWidth?: number
    contentHeight?: number
  }
  export type NodeTreeSnapshot = {
    parentIndex?: number[]
    nodeType?: number[]
    shadowRootType?: RareStringData
    nodeName?: StringIndex[]
    nodeValue?: StringIndex[]
    backendNodeId?: DOM.BackendNodeId[]
    attributes?: ArrayOfStrings[]
    textValue?: RareStringData
    inputValue?: RareStringData
    inputChecked?: RareBooleanData
    optionSelected?: RareBooleanData
    contentDocumentIndex?: RareIntegerData
    pseudoType?: RareStringData
    pseudoIdentifier?: RareStringData
    isClickable?: RareBooleanData
    currentSourceURL?: RareStringData
    originURL?: RareStringData
  }
  export type LayoutTreeSnapshot = {
    nodeIndex: number[]
    styles: ArrayOfStrings[]
    bounds: Rectangle[]
    text: StringIndex[]
    stackingContexts: RareBooleanData
    paintOrders?: number[]
    offsetRects?: Rectangle[]
    scrollRects?: Rectangle[]
    clientRects?: Rectangle[]
    blendedBackgroundColors?: StringIndex[]
    textColorOpacities?: number[]
  }
  export type TextBoxSnapshot = {
    layoutIndex: number[]
    bounds: Rectangle[]
    start: number[]
    length: number[]
  }
  export interface GetSnapshotResult {
    domNodes: DOMNode[]
    layoutTreeNodes: LayoutTreeNode[]
    computedStyles: ComputedStyle[]
  }
  export interface CaptureSnapshotResult {
    documents: DocumentSnapshot[]
    strings: string[]
  }
}
export namespace DOMStorage {
  export type SerializedStorageKey = string
  export type StorageId = {
    securityOrigin?: string
    storageKey?: SerializedStorageKey
    isLocalStorage: boolean
  }
  export type Item = string[]
  export interface GetDOMStorageItemsResult {
    entries: Item[]
  }
  export interface DomStorageItemAddedEvent {
    storageId: StorageId
    key: string
    newValue: string
  }
  export interface DomStorageItemRemovedEvent {
    storageId: StorageId
    key: string
  }
  export interface DomStorageItemUpdatedEvent {
    storageId: StorageId
    key: string
    oldValue: string
    newValue: string
  }
  export interface DomStorageItemsClearedEvent {
    storageId: StorageId
  }
  export interface EventMap {
    domStorageItemAdded: DomStorageItemAddedEvent
    domStorageItemRemoved: DomStorageItemRemovedEvent
    domStorageItemUpdated: DomStorageItemUpdatedEvent
    domStorageItemsCleared: DomStorageItemsClearedEvent
  }
}
export namespace DeviceOrientation {}
export namespace Emulation {
  export type SafeAreaInsets = {
    top?: number
    topMax?: number
    left?: number
    leftMax?: number
    bottom?: number
    bottomMax?: number
    right?: number
    rightMax?: number
  }
  export type ScreenOrientation = { type: string; angle: number }
  export type DisplayFeature = {
    orientation: string
    offset: number
    maskLength: number
  }
  export type DevicePosture = { type: string }
  export type MediaFeature = { name: string; value: string }
  export type VirtualTimePolicy =
    | 'advance'
    | 'pause'
    | 'pauseIfNetworkFetchesPending'
  export type UserAgentBrandVersion = { brand: string; version: string }
  export type UserAgentMetadata = {
    brands?: UserAgentBrandVersion[]
    fullVersionList?: UserAgentBrandVersion[]
    fullVersion?: string
    platform: string
    platformVersion: string
    architecture: string
    model: string
    mobile: boolean
    bitness?: string
    wow64?: boolean
  }
  export type SensorType =
    | 'absolute-orientation'
    | 'accelerometer'
    | 'ambient-light'
    | 'gravity'
    | 'gyroscope'
    | 'linear-acceleration'
    | 'magnetometer'
    | 'relative-orientation'
  export type SensorMetadata = {
    available?: boolean
    minimumFrequency?: number
    maximumFrequency?: number
  }
  export type SensorReadingSingle = { value: number }
  export type SensorReadingXYZ = { x: number; y: number; z: number }
  export type SensorReadingQuaternion = {
    x: number
    y: number
    z: number
    w: number
  }
  export type SensorReading = {
    single?: SensorReadingSingle
    xyz?: SensorReadingXYZ
    quaternion?: SensorReadingQuaternion
  }
  export type PressureSource = 'cpu'
  export type PressureState = 'nominal' | 'fair' | 'serious' | 'critical'
  export type PressureMetadata = { available?: boolean }
  export type DisabledImageType = 'avif' | 'webp'
  export interface CanEmulateResult {
    result: boolean
  }
  export interface GetOverriddenSensorInformationResult {
    requestedSamplingFrequency: number
  }
  export interface SetVirtualTimePolicyResult {
    virtualTimeTicksBase: number
  }
  export interface VirtualTimeBudgetExpiredEvent {}
  export interface EventMap {
    virtualTimeBudgetExpired: VirtualTimeBudgetExpiredEvent
  }
}
export namespace HeadlessExperimental {
  export type ScreenshotParams = {
    format?: string
    quality?: number
    optimizeForSpeed?: boolean
  }
  export interface BeginFrameResult {
    hasDamage: boolean
    screenshotData: string
  }
}
export namespace IO {
  export type StreamHandle = string
  export interface ReadResult {
    base64Encoded: boolean
    data: string
    eof: boolean
  }
  export interface ResolveBlobResult {
    uuid: string
  }
}
export namespace FileSystem {
  export type File = {
    name: string
    lastModified: Network.TimeSinceEpoch
    size: number
    type: string
  }
  export type Directory = {
    name: string
    nestedDirectories: string[]
    nestedFiles: File[]
  }
  export type BucketFileSystemLocator = {
    storageKey: Storage.SerializedStorageKey
    bucketName?: string
    pathComponents: string[]
  }
  export interface GetDirectoryResult {
    directory: Directory
  }
}
export namespace IndexedDB {
  export type DatabaseWithObjectStores = {
    name: string
    version: number
    objectStores: ObjectStore[]
  }
  export type ObjectStore = {
    name: string
    keyPath: KeyPath
    autoIncrement: boolean
    indexes: ObjectStoreIndex[]
  }
  export type ObjectStoreIndex = {
    name: string
    keyPath: KeyPath
    unique: boolean
    multiEntry: boolean
  }
  export type Key = {
    type: string
    number?: number
    string?: string
    date?: number
    array?: Key[]
  }
  export type KeyRange = {
    lower?: Key
    upper?: Key
    lowerOpen: boolean
    upperOpen: boolean
  }
  export type DataEntry = {
    key: Runtime.RemoteObject
    primaryKey: Runtime.RemoteObject
    value: Runtime.RemoteObject
  }
  export type KeyPath = { type: string; string?: string; array?: string[] }
  export interface RequestDataResult {
    objectStoreDataEntries: DataEntry[]
    hasMore: boolean
  }
  export interface GetMetadataResult {
    entriesCount: number
    keyGeneratorValue: number
  }
  export interface RequestDatabaseResult {
    databaseWithObjectStores: DatabaseWithObjectStores
  }
  export interface RequestDatabaseNamesResult {
    databaseNames: string[]
  }
}
export namespace Input {
  export type TouchPoint = {
    x: number
    y: number
    radiusX?: number
    radiusY?: number
    rotationAngle?: number
    force?: number
    tangentialPressure?: number
    tiltX?: number
    tiltY?: number
    twist?: number
    id?: number
  }
  export type GestureSourceType = 'default' | 'touch' | 'mouse'
  export type MouseButton =
    | 'none'
    | 'left'
    | 'middle'
    | 'right'
    | 'back'
    | 'forward'
  export type TimeSinceEpoch = number
  export type DragDataItem = {
    mimeType: string
    data: string
    title?: string
    baseURL?: string
  }
  export type DragData = {
    items: DragDataItem[]
    files?: string[]
    dragOperationsMask: number
  }
  export interface DragInterceptedEvent {
    data: DragData
  }
  export interface EventMap {
    dragIntercepted: DragInterceptedEvent
  }
}
export namespace Inspector {
  export interface DetachedEvent {
    reason: string
  }
  export interface TargetCrashedEvent {}
  export interface TargetReloadedAfterCrashEvent {}
  export interface EventMap {
    detached: DetachedEvent
    targetCrashed: TargetCrashedEvent
    targetReloadedAfterCrash: TargetReloadedAfterCrashEvent
  }
}
export namespace LayerTree {
  export type LayerId = string
  export type SnapshotId = string
  export type ScrollRect = { rect: DOM.Rect; type: string }
  export type StickyPositionConstraint = {
    stickyBoxRect: DOM.Rect
    containingBlockRect: DOM.Rect
    nearestLayerShiftingStickyBox?: LayerId
    nearestLayerShiftingContainingBlock?: LayerId
  }
  export type PictureTile = { x: number; y: number; picture: string }
  export type Layer = {
    layerId: LayerId
    parentLayerId?: LayerId
    backendNodeId?: DOM.BackendNodeId
    offsetX: number
    offsetY: number
    width: number
    height: number
    transform?: number[]
    anchorX?: number
    anchorY?: number
    anchorZ?: number
    paintCount: number
    drawsContent: boolean
    invisible?: boolean
    scrollRects?: ScrollRect[]
    stickyPositionConstraint?: StickyPositionConstraint
  }
  export type PaintProfile = number[]
  export interface CompositingReasonsResult {
    compositingReasons: string[]
    compositingReasonIds: string[]
  }
  export interface LoadSnapshotResult {
    snapshotId: SnapshotId
  }
  export interface MakeSnapshotResult {
    snapshotId: SnapshotId
  }
  export interface ProfileSnapshotResult {
    timings: PaintProfile[]
  }
  export interface ReplaySnapshotResult {
    dataURL: string
  }
  export interface SnapshotCommandLogResult {
    commandLog: Record<string, unknown>[]
  }
  export interface LayerPaintedEvent {
    layerId: LayerId
    clip: DOM.Rect
  }
  export interface LayerTreeDidChangeEvent {
    layers: Layer[]
  }
  export interface EventMap {
    layerPainted: LayerPaintedEvent
    layerTreeDidChange: LayerTreeDidChangeEvent
  }
}
export namespace Log {
  export type LogEntry = {
    source: string
    level: string
    text: string
    category?: string
    timestamp: Runtime.Timestamp
    url?: string
    lineNumber?: number
    stackTrace?: Runtime.StackTrace
    networkRequestId?: Network.RequestId
    workerId?: string
    args?: Runtime.RemoteObject[]
  }
  export type ViolationSetting = { name: string; threshold: number }
  export interface EntryAddedEvent {
    entry: LogEntry
  }
  export interface EventMap {
    entryAdded: EntryAddedEvent
  }
}
export namespace Memory {
  export type PressureLevel = 'moderate' | 'critical'
  export type SamplingProfileNode = {
    size: number
    total: number
    stack: string[]
  }
  export type SamplingProfile = {
    samples: SamplingProfileNode[]
    modules: Module[]
  }
  export type Module = {
    name: string
    uuid: string
    baseAddress: string
    size: number
  }
  export type DOMCounter = { name: string; count: number }
  export interface GetDOMCountersResult {
    documents: number
    nodes: number
    jsEventListeners: number
  }
  export interface GetDOMCountersForLeakDetectionResult {
    counters: DOMCounter[]
  }
  export interface GetAllTimeSamplingProfileResult {
    profile: SamplingProfile
  }
  export interface GetBrowserSamplingProfileResult {
    profile: SamplingProfile
  }
  export interface GetSamplingProfileResult {
    profile: SamplingProfile
  }
}
export namespace Network {
  export type ResourceType =
    | 'Document'
    | 'Stylesheet'
    | 'Image'
    | 'Media'
    | 'Font'
    | 'Script'
    | 'TextTrack'
    | 'XHR'
    | 'Fetch'
    | 'Prefetch'
    | 'EventSource'
    | 'WebSocket'
    | 'Manifest'
    | 'SignedExchange'
    | 'Ping'
    | 'CSPViolationReport'
    | 'Preflight'
    | 'FedCM'
    | 'Other'
  export type LoaderId = string
  export type RequestId = string
  export type InterceptionId = string
  export type ErrorReason =
    | 'Failed'
    | 'Aborted'
    | 'TimedOut'
    | 'AccessDenied'
    | 'ConnectionClosed'
    | 'ConnectionReset'
    | 'ConnectionRefused'
    | 'ConnectionAborted'
    | 'ConnectionFailed'
    | 'NameNotResolved'
    | 'InternetDisconnected'
    | 'AddressUnreachable'
    | 'BlockedByClient'
    | 'BlockedByResponse'
  export type TimeSinceEpoch = number
  export type MonotonicTime = number
  export type Headers = Record<string, string>
  export type ConnectionType =
    | 'none'
    | 'cellular2g'
    | 'cellular3g'
    | 'cellular4g'
    | 'bluetooth'
    | 'ethernet'
    | 'wifi'
    | 'wimax'
    | 'other'
  export type CookieSameSite = 'Strict' | 'Lax' | 'None'
  export type CookiePriority = 'Low' | 'Medium' | 'High'
  export type CookieSourceScheme = 'Unset' | 'NonSecure' | 'Secure'
  export type ResourceTiming = {
    requestTime: number
    proxyStart: number
    proxyEnd: number
    dnsStart: number
    dnsEnd: number
    connectStart: number
    connectEnd: number
    sslStart: number
    sslEnd: number
    workerStart: number
    workerReady: number
    workerFetchStart: number
    workerRespondWithSettled: number
    workerRouterEvaluationStart?: number
    workerCacheLookupStart?: number
    sendStart: number
    sendEnd: number
    pushStart: number
    pushEnd: number
    receiveHeadersStart: number
    receiveHeadersEnd: number
  }
  export type ResourcePriority =
    | 'VeryLow'
    | 'Low'
    | 'Medium'
    | 'High'
    | 'VeryHigh'
  export type PostDataEntry = { bytes?: string }
  export type Request = {
    url: string
    urlFragment?: string
    method: string
    headers: Headers
    postData?: string
    hasPostData?: boolean
    postDataEntries?: PostDataEntry[]
    mixedContentType?: Security.MixedContentType
    initialPriority: ResourcePriority
    referrerPolicy: string
    isLinkPreload?: boolean
    trustTokenParams?: TrustTokenParams
    isSameSite?: boolean
  }
  export type SignedCertificateTimestamp = {
    status: string
    origin: string
    logDescription: string
    logId: string
    timestamp: number
    hashAlgorithm: string
    signatureAlgorithm: string
    signatureData: string
  }
  export type SecurityDetails = {
    protocol: string
    keyExchange: string
    keyExchangeGroup?: string
    cipher: string
    mac?: string
    certificateId: Security.CertificateId
    subjectName: string
    sanList: string[]
    issuer: string
    validFrom: TimeSinceEpoch
    validTo: TimeSinceEpoch
    signedCertificateTimestampList: SignedCertificateTimestamp[]
    certificateTransparencyCompliance: CertificateTransparencyCompliance
    serverSignatureAlgorithm?: number
    encryptedClientHello: boolean
  }
  export type CertificateTransparencyCompliance =
    | 'unknown'
    | 'not-compliant'
    | 'compliant'
  export type BlockedReason =
    | 'other'
    | 'csp'
    | 'mixed-content'
    | 'origin'
    | 'inspector'
    | 'integrity'
    | 'subresource-filter'
    | 'content-type'
    | 'coep-frame-resource-needs-coep-header'
    | 'coop-sandboxed-iframe-cannot-navigate-to-coop-page'
    | 'corp-not-same-origin'
    | 'corp-not-same-origin-after-defaulted-to-same-origin-by-coep'
    | 'corp-not-same-origin-after-defaulted-to-same-origin-by-dip'
    | 'corp-not-same-origin-after-defaulted-to-same-origin-by-coep-and-dip'
    | 'corp-not-same-site'
    | 'sri-message-signature-mismatch'
  export type CorsError =
    | 'DisallowedByMode'
    | 'InvalidResponse'
    | 'WildcardOriginNotAllowed'
    | 'MissingAllowOriginHeader'
    | 'MultipleAllowOriginValues'
    | 'InvalidAllowOriginValue'
    | 'AllowOriginMismatch'
    | 'InvalidAllowCredentials'
    | 'CorsDisabledScheme'
    | 'PreflightInvalidStatus'
    | 'PreflightDisallowedRedirect'
    | 'PreflightWildcardOriginNotAllowed'
    | 'PreflightMissingAllowOriginHeader'
    | 'PreflightMultipleAllowOriginValues'
    | 'PreflightInvalidAllowOriginValue'
    | 'PreflightAllowOriginMismatch'
    | 'PreflightInvalidAllowCredentials'
    | 'PreflightMissingAllowExternal'
    | 'PreflightInvalidAllowExternal'
    | 'PreflightMissingAllowPrivateNetwork'
    | 'PreflightInvalidAllowPrivateNetwork'
    | 'InvalidAllowMethodsPreflightResponse'
    | 'InvalidAllowHeadersPreflightResponse'
    | 'MethodDisallowedByPreflightResponse'
    | 'HeaderDisallowedByPreflightResponse'
    | 'RedirectContainsCredentials'
    | 'InsecurePrivateNetwork'
    | 'InvalidPrivateNetworkAccess'
    | 'UnexpectedPrivateNetworkAccess'
    | 'NoCorsRedirectModeNotFollow'
    | 'PreflightMissingPrivateNetworkAccessId'
    | 'PreflightMissingPrivateNetworkAccessName'
    | 'PrivateNetworkAccessPermissionUnavailable'
    | 'PrivateNetworkAccessPermissionDenied'
    | 'LocalNetworkAccessPermissionDenied'
  export type CorsErrorStatus = {
    corsError: CorsError
    failedParameter: string
  }
  export type ServiceWorkerResponseSource =
    | 'cache-storage'
    | 'http-cache'
    | 'fallback-code'
    | 'network'
  export type TrustTokenParams = {
    operation: TrustTokenOperationType
    refreshPolicy: string
    issuers?: string[]
  }
  export type TrustTokenOperationType = 'Issuance' | 'Redemption' | 'Signing'
  export type AlternateProtocolUsage =
    | 'alternativeJobWonWithoutRace'
    | 'alternativeJobWonRace'
    | 'mainJobWonRace'
    | 'mappingMissing'
    | 'broken'
    | 'dnsAlpnH3JobWonWithoutRace'
    | 'dnsAlpnH3JobWonRace'
    | 'unspecifiedReason'
  export type ServiceWorkerRouterSource =
    | 'network'
    | 'cache'
    | 'fetch-event'
    | 'race-network-and-fetch-handler'
    | 'race-network-and-cache'
  export type ServiceWorkerRouterInfo = {
    ruleIdMatched?: number
    matchedSourceType?: ServiceWorkerRouterSource
    actualSourceType?: ServiceWorkerRouterSource
  }
  export type Response = {
    url: string
    status: number
    statusText: string
    headers: Headers
    headersText?: string
    mimeType: string
    charset: string
    requestHeaders?: Headers
    requestHeadersText?: string
    connectionReused: boolean
    connectionId: number
    remoteIPAddress?: string
    remotePort?: number
    fromDiskCache?: boolean
    fromServiceWorker?: boolean
    fromPrefetchCache?: boolean
    fromEarlyHints?: boolean
    serviceWorkerRouterInfo?: ServiceWorkerRouterInfo
    encodedDataLength: number
    timing?: ResourceTiming
    serviceWorkerResponseSource?: ServiceWorkerResponseSource
    responseTime?: TimeSinceEpoch
    cacheStorageCacheName?: string
    protocol?: string
    alternateProtocolUsage?: AlternateProtocolUsage
    securityState: Security.SecurityState
    securityDetails?: SecurityDetails
  }
  export type WebSocketRequest = { headers: Headers }
  export type WebSocketResponse = {
    status: number
    statusText: string
    headers: Headers
    headersText?: string
    requestHeaders?: Headers
    requestHeadersText?: string
  }
  export type WebSocketFrame = {
    opcode: number
    mask: boolean
    payloadData: string
  }
  export type CachedResource = {
    url: string
    type: ResourceType
    response?: Response
    bodySize: number
  }
  export type Initiator = {
    type: string
    stack?: Runtime.StackTrace
    url?: string
    lineNumber?: number
    columnNumber?: number
    requestId?: RequestId
  }
  export type CookiePartitionKey = {
    topLevelSite: string
    hasCrossSiteAncestor: boolean
  }
  export type Cookie = {
    name: string
    value: string
    domain: string
    path: string
    expires: number
    size: number
    httpOnly: boolean
    secure: boolean
    session: boolean
    sameSite?: CookieSameSite
    priority: CookiePriority
    sameParty: boolean
    sourceScheme: CookieSourceScheme
    sourcePort: number
    partitionKey?: CookiePartitionKey
    partitionKeyOpaque?: boolean
  }
  export type SetCookieBlockedReason =
    | 'SecureOnly'
    | 'SameSiteStrict'
    | 'SameSiteLax'
    | 'SameSiteUnspecifiedTreatedAsLax'
    | 'SameSiteNoneInsecure'
    | 'UserPreferences'
    | 'ThirdPartyPhaseout'
    | 'ThirdPartyBlockedInFirstPartySet'
    | 'SyntaxError'
    | 'SchemeNotSupported'
    | 'OverwriteSecure'
    | 'InvalidDomain'
    | 'InvalidPrefix'
    | 'UnknownError'
    | 'SchemefulSameSiteStrict'
    | 'SchemefulSameSiteLax'
    | 'SchemefulSameSiteUnspecifiedTreatedAsLax'
    | 'SamePartyFromCrossPartyContext'
    | 'SamePartyConflictsWithOtherAttributes'
    | 'NameValuePairExceedsMaxSize'
    | 'DisallowedCharacter'
    | 'NoCookieContent'
  export type CookieBlockedReason =
    | 'SecureOnly'
    | 'NotOnPath'
    | 'DomainMismatch'
    | 'SameSiteStrict'
    | 'SameSiteLax'
    | 'SameSiteUnspecifiedTreatedAsLax'
    | 'SameSiteNoneInsecure'
    | 'UserPreferences'
    | 'ThirdPartyPhaseout'
    | 'ThirdPartyBlockedInFirstPartySet'
    | 'UnknownError'
    | 'SchemefulSameSiteStrict'
    | 'SchemefulSameSiteLax'
    | 'SchemefulSameSiteUnspecifiedTreatedAsLax'
    | 'SamePartyFromCrossPartyContext'
    | 'NameValuePairExceedsMaxSize'
    | 'PortMismatch'
    | 'SchemeMismatch'
    | 'AnonymousContext'
  export type CookieExemptionReason =
    | 'None'
    | 'UserSetting'
    | 'TPCDMetadata'
    | 'TPCDDeprecationTrial'
    | 'TopLevelTPCDDeprecationTrial'
    | 'TPCDHeuristics'
    | 'EnterprisePolicy'
    | 'StorageAccess'
    | 'TopLevelStorageAccess'
    | 'Scheme'
    | 'SameSiteNoneCookiesInSandbox'
  export type BlockedSetCookieWithReason = {
    blockedReasons: SetCookieBlockedReason[]
    cookieLine: string
    cookie?: Cookie
  }
  export type ExemptedSetCookieWithReason = {
    exemptionReason: CookieExemptionReason
    cookieLine: string
    cookie: Cookie
  }
  export type AssociatedCookie = {
    cookie: Cookie
    blockedReasons: CookieBlockedReason[]
    exemptionReason?: CookieExemptionReason
  }
  export type CookieParam = {
    name: string
    value: string
    url?: string
    domain?: string
    path?: string
    secure?: boolean
    httpOnly?: boolean
    sameSite?: CookieSameSite
    expires?: TimeSinceEpoch
    priority?: CookiePriority
    sameParty?: boolean
    sourceScheme?: CookieSourceScheme
    sourcePort?: number
    partitionKey?: CookiePartitionKey
  }
  export type AuthChallenge = {
    source?: string
    origin: string
    scheme: string
    realm: string
  }
  export type AuthChallengeResponse = {
    response: string
    username?: string
    password?: string
  }
  export type InterceptionStage = 'Request' | 'HeadersReceived'
  export type RequestPattern = {
    urlPattern?: string
    resourceType?: ResourceType
    interceptionStage?: InterceptionStage
  }
  export type SignedExchangeSignature = {
    label: string
    signature: string
    integrity: string
    certUrl?: string
    certSha256?: string
    validityUrl: string
    date: number
    expires: number
    certificates?: string[]
  }
  export type SignedExchangeHeader = {
    requestUrl: string
    responseCode: number
    responseHeaders: Headers
    signatures: SignedExchangeSignature[]
    headerIntegrity: string
  }
  export type SignedExchangeErrorField =
    | 'signatureSig'
    | 'signatureIntegrity'
    | 'signatureCertUrl'
    | 'signatureCertSha256'
    | 'signatureValidityUrl'
    | 'signatureTimestamps'
  export type SignedExchangeError = {
    message: string
    signatureIndex?: number
    errorField?: SignedExchangeErrorField
  }
  export type SignedExchangeInfo = {
    outerResponse: Response
    header?: SignedExchangeHeader
    securityDetails?: SecurityDetails
    errors?: SignedExchangeError[]
  }
  export type ContentEncoding = 'deflate' | 'gzip' | 'br' | 'zstd'
  export type DirectSocketDnsQueryType = 'ipv4' | 'ipv6'
  export type DirectTCPSocketOptions = {
    noDelay: boolean
    keepAliveDelay?: number
    sendBufferSize?: number
    receiveBufferSize?: number
    dnsQueryType?: DirectSocketDnsQueryType
  }
  export type DirectUDPSocketOptions = {
    remoteAddr?: string
    remotePort?: number
    localAddr?: string
    localPort?: number
    dnsQueryType?: DirectSocketDnsQueryType
    sendBufferSize?: number
    receiveBufferSize?: number
  }
  export type DirectUDPMessage = {
    data: string
    remoteAddr?: string
    remotePort?: number
  }
  export type PrivateNetworkRequestPolicy =
    | 'Allow'
    | 'BlockFromInsecureToMorePrivate'
    | 'WarnFromInsecureToMorePrivate'
    | 'PreflightBlock'
    | 'PreflightWarn'
    | 'PermissionBlock'
    | 'PermissionWarn'
  export type IPAddressSpace = 'Local' | 'Private' | 'Public' | 'Unknown'
  export type ConnectTiming = { requestTime: number }
  export type ClientSecurityState = {
    initiatorIsSecureContext: boolean
    initiatorIPAddressSpace: IPAddressSpace
    privateNetworkRequestPolicy: PrivateNetworkRequestPolicy
  }
  export type CrossOriginOpenerPolicyValue =
    | 'SameOrigin'
    | 'SameOriginAllowPopups'
    | 'RestrictProperties'
    | 'UnsafeNone'
    | 'SameOriginPlusCoep'
    | 'RestrictPropertiesPlusCoep'
    | 'NoopenerAllowPopups'
  export type CrossOriginOpenerPolicyStatus = {
    value: CrossOriginOpenerPolicyValue
    reportOnlyValue: CrossOriginOpenerPolicyValue
    reportingEndpoint?: string
    reportOnlyReportingEndpoint?: string
  }
  export type CrossOriginEmbedderPolicyValue =
    | 'None'
    | 'Credentialless'
    | 'RequireCorp'
  export type CrossOriginEmbedderPolicyStatus = {
    value: CrossOriginEmbedderPolicyValue
    reportOnlyValue: CrossOriginEmbedderPolicyValue
    reportingEndpoint?: string
    reportOnlyReportingEndpoint?: string
  }
  export type ContentSecurityPolicySource = 'HTTP' | 'Meta'
  export type ContentSecurityPolicyStatus = {
    effectiveDirectives: string
    isEnforced: boolean
    source: ContentSecurityPolicySource
  }
  export type SecurityIsolationStatus = {
    coop?: CrossOriginOpenerPolicyStatus
    coep?: CrossOriginEmbedderPolicyStatus
    csp?: ContentSecurityPolicyStatus[]
  }
  export type ReportStatus =
    | 'Queued'
    | 'Pending'
    | 'MarkedForRemoval'
    | 'Success'
  export type ReportId = string
  export type ReportingApiReport = {
    id: ReportId
    initiatorUrl: string
    destination: string
    type: string
    timestamp: Network.TimeSinceEpoch
    depth: number
    completedAttempts: number
    body: Record<string, unknown>
    status: ReportStatus
  }
  export type ReportingApiEndpoint = { url: string; groupName: string }
  export type LoadNetworkResourcePageResult = {
    success: boolean
    netError?: number
    netErrorName?: string
    httpStatusCode?: number
    stream?: IO.StreamHandle
    headers?: Network.Headers
  }
  export type LoadNetworkResourceOptions = {
    disableCache: boolean
    includeCredentials: boolean
  }
  export interface CanClearBrowserCacheResult {
    result: boolean
  }
  export interface CanClearBrowserCookiesResult {
    result: boolean
  }
  export interface CanEmulateNetworkConditionsResult {
    result: boolean
  }
  export interface GetAllCookiesResult {
    cookies: Cookie[]
  }
  export interface GetCertificateResult {
    tableNames: string[]
  }
  export interface GetCookiesResult {
    cookies: Cookie[]
  }
  export interface GetResponseBodyResult {
    body: string
    base64Encoded: boolean
  }
  export interface GetRequestPostDataResult {
    postData: string
  }
  export interface GetResponseBodyForInterceptionResult {
    body: string
    base64Encoded: boolean
  }
  export interface TakeResponseBodyForInterceptionAsStreamResult {
    stream: IO.StreamHandle
  }
  export interface SearchInResponseBodyResult {
    result: Debugger.SearchMatch[]
  }
  export interface SetCookieResult {
    success: boolean
  }
  export interface StreamResourceContentResult {
    bufferedData: string
  }
  export interface GetSecurityIsolationStatusResult {
    status: SecurityIsolationStatus
  }
  export interface LoadNetworkResourceResult {
    resource: LoadNetworkResourcePageResult
  }
  export interface DataReceivedEvent {
    requestId: RequestId
    timestamp: MonotonicTime
    dataLength: number
    encodedDataLength: number
    data: string
  }
  export interface EventSourceMessageReceivedEvent {
    requestId: RequestId
    timestamp: MonotonicTime
    eventName: string
    eventId: string
    data: string
  }
  export interface LoadingFailedEvent {
    requestId: RequestId
    timestamp: MonotonicTime
    type: ResourceType
    errorText: string
    canceled: boolean
    blockedReason: BlockedReason
    corsErrorStatus: CorsErrorStatus
  }
  export interface LoadingFinishedEvent {
    requestId: RequestId
    timestamp: MonotonicTime
    encodedDataLength: number
  }
  export interface RequestInterceptedEvent {
    interceptionId: InterceptionId
    request: Request
    frameId: Page.FrameId
    resourceType: ResourceType
    isNavigationRequest: boolean
    isDownload: boolean
    redirectUrl: string
    authChallenge: AuthChallenge
    responseErrorReason: ErrorReason
    responseStatusCode: number
    responseHeaders: Headers
    requestId: RequestId
  }
  export interface RequestServedFromCacheEvent {
    requestId: RequestId
  }
  export interface RequestWillBeSentEvent {
    requestId: RequestId
    loaderId: LoaderId
    documentURL: string
    request: Request
    timestamp: MonotonicTime
    wallTime: TimeSinceEpoch
    initiator: Initiator
    redirectHasExtraInfo: boolean
    redirectResponse: Response
    type: ResourceType
    frameId: Page.FrameId
    hasUserGesture: boolean
  }
  export interface ResourceChangedPriorityEvent {
    requestId: RequestId
    newPriority: ResourcePriority
    timestamp: MonotonicTime
  }
  export interface SignedExchangeReceivedEvent {
    requestId: RequestId
    info: SignedExchangeInfo
  }
  export interface ResponseReceivedEvent {
    requestId: RequestId
    loaderId: LoaderId
    timestamp: MonotonicTime
    type: ResourceType
    response: Response
    hasExtraInfo: boolean
    frameId: Page.FrameId
  }
  export interface WebSocketClosedEvent {
    requestId: RequestId
    timestamp: MonotonicTime
  }
  export interface WebSocketCreatedEvent {
    requestId: RequestId
    url: string
    initiator: Initiator
  }
  export interface WebSocketFrameErrorEvent {
    requestId: RequestId
    timestamp: MonotonicTime
    errorMessage: string
  }
  export interface WebSocketFrameReceivedEvent {
    requestId: RequestId
    timestamp: MonotonicTime
    response: WebSocketFrame
  }
  export interface WebSocketFrameSentEvent {
    requestId: RequestId
    timestamp: MonotonicTime
    response: WebSocketFrame
  }
  export interface WebSocketHandshakeResponseReceivedEvent {
    requestId: RequestId
    timestamp: MonotonicTime
    response: WebSocketResponse
  }
  export interface WebSocketWillSendHandshakeRequestEvent {
    requestId: RequestId
    timestamp: MonotonicTime
    wallTime: TimeSinceEpoch
    request: WebSocketRequest
  }
  export interface WebTransportCreatedEvent {
    transportId: RequestId
    url: string
    timestamp: MonotonicTime
    initiator: Initiator
  }
  export interface WebTransportConnectionEstablishedEvent {
    transportId: RequestId
    timestamp: MonotonicTime
  }
  export interface WebTransportClosedEvent {
    transportId: RequestId
    timestamp: MonotonicTime
  }
  export interface DirectTCPSocketCreatedEvent {
    identifier: RequestId
    remoteAddr: string
    remotePort: number
    options: DirectTCPSocketOptions
    timestamp: MonotonicTime
    initiator: Initiator
  }
  export interface DirectTCPSocketOpenedEvent {
    identifier: RequestId
    remoteAddr: string
    remotePort: number
    timestamp: MonotonicTime
    localAddr: string
    localPort: number
  }
  export interface DirectTCPSocketAbortedEvent {
    identifier: RequestId
    errorMessage: string
    timestamp: MonotonicTime
  }
  export interface DirectTCPSocketClosedEvent {
    identifier: RequestId
    timestamp: MonotonicTime
  }
  export interface DirectTCPSocketChunkSentEvent {
    identifier: RequestId
    data: string
    timestamp: MonotonicTime
  }
  export interface DirectTCPSocketChunkReceivedEvent {
    identifier: RequestId
    data: string
    timestamp: MonotonicTime
  }
  export interface DirectUDPSocketCreatedEvent {
    identifier: RequestId
    options: DirectUDPSocketOptions
    timestamp: MonotonicTime
    initiator: Initiator
  }
  export interface DirectUDPSocketOpenedEvent {
    identifier: RequestId
    localAddr: string
    localPort: number
    timestamp: MonotonicTime
    remoteAddr: string
    remotePort: number
  }
  export interface DirectUDPSocketAbortedEvent {
    identifier: RequestId
    errorMessage: string
    timestamp: MonotonicTime
  }
  export interface DirectUDPSocketClosedEvent {
    identifier: RequestId
    timestamp: MonotonicTime
  }
  export interface DirectUDPSocketChunkSentEvent {
    identifier: RequestId
    message: DirectUDPMessage
    timestamp: MonotonicTime
  }
  export interface DirectUDPSocketChunkReceivedEvent {
    identifier: RequestId
    message: DirectUDPMessage
    timestamp: MonotonicTime
  }
  export interface RequestWillBeSentExtraInfoEvent {
    requestId: RequestId
    associatedCookies: AssociatedCookie[]
    headers: Headers
    connectTiming: ConnectTiming
    clientSecurityState: ClientSecurityState
    siteHasCookieInOtherPartition: boolean
  }
  export interface ResponseReceivedExtraInfoEvent {
    requestId: RequestId
    blockedCookies: BlockedSetCookieWithReason[]
    headers: Headers
    resourceIPAddressSpace: IPAddressSpace
    statusCode: number
    headersText: string
    cookiePartitionKey: CookiePartitionKey
    cookiePartitionKeyOpaque: boolean
    exemptedCookies: ExemptedSetCookieWithReason[]
  }
  export interface ResponseReceivedEarlyHintsEvent {
    requestId: RequestId
    headers: Headers
  }
  export interface TrustTokenOperationDoneEvent {
    status: string
    type: TrustTokenOperationType
    requestId: RequestId
    topLevelOrigin: string
    issuerOrigin: string
    issuedTokenCount: number
  }
  export interface PolicyUpdatedEvent {}
  export interface SubresourceWebBundleMetadataReceivedEvent {
    requestId: RequestId
    urls: string[]
  }
  export interface SubresourceWebBundleMetadataErrorEvent {
    requestId: RequestId
    errorMessage: string
  }
  export interface SubresourceWebBundleInnerResponseParsedEvent {
    innerRequestId: RequestId
    innerRequestURL: string
    bundleRequestId: RequestId
  }
  export interface SubresourceWebBundleInnerResponseErrorEvent {
    innerRequestId: RequestId
    innerRequestURL: string
    errorMessage: string
    bundleRequestId: RequestId
  }
  export interface ReportingApiReportAddedEvent {
    report: ReportingApiReport
  }
  export interface ReportingApiReportUpdatedEvent {
    report: ReportingApiReport
  }
  export interface ReportingApiEndpointsChangedForOriginEvent {
    origin: string
    endpoints: ReportingApiEndpoint[]
  }
  export interface EventMap {
    dataReceived: DataReceivedEvent
    eventSourceMessageReceived: EventSourceMessageReceivedEvent
    loadingFailed: LoadingFailedEvent
    loadingFinished: LoadingFinishedEvent
    requestIntercepted: RequestInterceptedEvent
    requestServedFromCache: RequestServedFromCacheEvent
    requestWillBeSent: RequestWillBeSentEvent
    resourceChangedPriority: ResourceChangedPriorityEvent
    signedExchangeReceived: SignedExchangeReceivedEvent
    responseReceived: ResponseReceivedEvent
    webSocketClosed: WebSocketClosedEvent
    webSocketCreated: WebSocketCreatedEvent
    webSocketFrameError: WebSocketFrameErrorEvent
    webSocketFrameReceived: WebSocketFrameReceivedEvent
    webSocketFrameSent: WebSocketFrameSentEvent
    webSocketHandshakeResponseReceived: WebSocketHandshakeResponseReceivedEvent
    webSocketWillSendHandshakeRequest: WebSocketWillSendHandshakeRequestEvent
    webTransportCreated: WebTransportCreatedEvent
    webTransportConnectionEstablished: WebTransportConnectionEstablishedEvent
    webTransportClosed: WebTransportClosedEvent
    directTCPSocketCreated: DirectTCPSocketCreatedEvent
    directTCPSocketOpened: DirectTCPSocketOpenedEvent
    directTCPSocketAborted: DirectTCPSocketAbortedEvent
    directTCPSocketClosed: DirectTCPSocketClosedEvent
    directTCPSocketChunkSent: DirectTCPSocketChunkSentEvent
    directTCPSocketChunkReceived: DirectTCPSocketChunkReceivedEvent
    directUDPSocketCreated: DirectUDPSocketCreatedEvent
    directUDPSocketOpened: DirectUDPSocketOpenedEvent
    directUDPSocketAborted: DirectUDPSocketAbortedEvent
    directUDPSocketClosed: DirectUDPSocketClosedEvent
    directUDPSocketChunkSent: DirectUDPSocketChunkSentEvent
    directUDPSocketChunkReceived: DirectUDPSocketChunkReceivedEvent
    requestWillBeSentExtraInfo: RequestWillBeSentExtraInfoEvent
    responseReceivedExtraInfo: ResponseReceivedExtraInfoEvent
    responseReceivedEarlyHints: ResponseReceivedEarlyHintsEvent
    trustTokenOperationDone: TrustTokenOperationDoneEvent
    policyUpdated: PolicyUpdatedEvent
    subresourceWebBundleMetadataReceived: SubresourceWebBundleMetadataReceivedEvent
    subresourceWebBundleMetadataError: SubresourceWebBundleMetadataErrorEvent
    subresourceWebBundleInnerResponseParsed: SubresourceWebBundleInnerResponseParsedEvent
    subresourceWebBundleInnerResponseError: SubresourceWebBundleInnerResponseErrorEvent
    reportingApiReportAdded: ReportingApiReportAddedEvent
    reportingApiReportUpdated: ReportingApiReportUpdatedEvent
    reportingApiEndpointsChangedForOrigin: ReportingApiEndpointsChangedForOriginEvent
  }
}
export namespace Overlay {
  export type SourceOrderConfig = {
    parentOutlineColor: DOM.RGBA
    childOutlineColor: DOM.RGBA
  }
  export type GridHighlightConfig = {
    showGridExtensionLines?: boolean
    showPositiveLineNumbers?: boolean
    showNegativeLineNumbers?: boolean
    showAreaNames?: boolean
    showLineNames?: boolean
    showTrackSizes?: boolean
    gridBorderColor?: DOM.RGBA
    cellBorderColor?: DOM.RGBA
    rowLineColor?: DOM.RGBA
    columnLineColor?: DOM.RGBA
    gridBorderDash?: boolean
    cellBorderDash?: boolean
    rowLineDash?: boolean
    columnLineDash?: boolean
    rowGapColor?: DOM.RGBA
    rowHatchColor?: DOM.RGBA
    columnGapColor?: DOM.RGBA
    columnHatchColor?: DOM.RGBA
    areaBorderColor?: DOM.RGBA
    gridBackgroundColor?: DOM.RGBA
  }
  export type FlexContainerHighlightConfig = {
    containerBorder?: LineStyle
    lineSeparator?: LineStyle
    itemSeparator?: LineStyle
    mainDistributedSpace?: BoxStyle
    crossDistributedSpace?: BoxStyle
    rowGapSpace?: BoxStyle
    columnGapSpace?: BoxStyle
    crossAlignment?: LineStyle
  }
  export type FlexItemHighlightConfig = {
    baseSizeBox?: BoxStyle
    baseSizeBorder?: LineStyle
    flexibilityArrow?: LineStyle
  }
  export type LineStyle = { color?: DOM.RGBA; pattern?: string }
  export type BoxStyle = { fillColor?: DOM.RGBA; hatchColor?: DOM.RGBA }
  export type ContrastAlgorithm = 'aa' | 'aaa' | 'apca'
  export type HighlightConfig = {
    showInfo?: boolean
    showStyles?: boolean
    showRulers?: boolean
    showAccessibilityInfo?: boolean
    showExtensionLines?: boolean
    contentColor?: DOM.RGBA
    paddingColor?: DOM.RGBA
    borderColor?: DOM.RGBA
    marginColor?: DOM.RGBA
    eventTargetColor?: DOM.RGBA
    shapeColor?: DOM.RGBA
    shapeMarginColor?: DOM.RGBA
    cssGridColor?: DOM.RGBA
    colorFormat?: ColorFormat
    gridHighlightConfig?: GridHighlightConfig
    flexContainerHighlightConfig?: FlexContainerHighlightConfig
    flexItemHighlightConfig?: FlexItemHighlightConfig
    contrastAlgorithm?: ContrastAlgorithm
    containerQueryContainerHighlightConfig?: ContainerQueryContainerHighlightConfig
  }
  export type ColorFormat = 'rgb' | 'hsl' | 'hwb' | 'hex'
  export type GridNodeHighlightConfig = {
    gridHighlightConfig: GridHighlightConfig
    nodeId: DOM.NodeId
  }
  export type FlexNodeHighlightConfig = {
    flexContainerHighlightConfig: FlexContainerHighlightConfig
    nodeId: DOM.NodeId
  }
  export type ScrollSnapContainerHighlightConfig = {
    snapportBorder?: LineStyle
    snapAreaBorder?: LineStyle
    scrollMarginColor?: DOM.RGBA
    scrollPaddingColor?: DOM.RGBA
  }
  export type ScrollSnapHighlightConfig = {
    scrollSnapContainerHighlightConfig: ScrollSnapContainerHighlightConfig
    nodeId: DOM.NodeId
  }
  export type HingeConfig = {
    rect: DOM.Rect
    contentColor?: DOM.RGBA
    outlineColor?: DOM.RGBA
  }
  export type WindowControlsOverlayConfig = {
    showCSS: boolean
    selectedPlatform: string
    themeColor: string
  }
  export type ContainerQueryHighlightConfig = {
    containerQueryContainerHighlightConfig: ContainerQueryContainerHighlightConfig
    nodeId: DOM.NodeId
  }
  export type ContainerQueryContainerHighlightConfig = {
    containerBorder?: LineStyle
    descendantBorder?: LineStyle
  }
  export type IsolatedElementHighlightConfig = {
    isolationModeHighlightConfig: IsolationModeHighlightConfig
    nodeId: DOM.NodeId
  }
  export type IsolationModeHighlightConfig = {
    resizerColor?: DOM.RGBA
    resizerHandleColor?: DOM.RGBA
    maskColor?: DOM.RGBA
  }
  export type InspectMode =
    | 'searchForNode'
    | 'searchForUAShadowDOM'
    | 'captureAreaScreenshot'
    | 'showDistances'
    | 'none'
  export interface GetHighlightObjectForTestResult {
    highlight: Record<string, unknown>
  }
  export interface GetGridHighlightObjectsForTestResult {
    highlights: Record<string, unknown>
  }
  export interface GetSourceOrderHighlightObjectForTestResult {
    highlight: Record<string, unknown>
  }
  export interface InspectNodeRequestedEvent {
    backendNodeId: DOM.BackendNodeId
  }
  export interface NodeHighlightRequestedEvent {
    nodeId: DOM.NodeId
  }
  export interface ScreenshotRequestedEvent {
    viewport: Page.Viewport
  }
  export interface InspectModeCanceledEvent {}
  export interface EventMap {
    inspectNodeRequested: InspectNodeRequestedEvent
    nodeHighlightRequested: NodeHighlightRequestedEvent
    screenshotRequested: ScreenshotRequestedEvent
    inspectModeCanceled: InspectModeCanceledEvent
  }
}
export namespace Page {
  export type FrameId = string
  export type AdFrameType = 'none' | 'child' | 'root'
  export type AdFrameExplanation =
    | 'ParentIsAd'
    | 'CreatedByAdScript'
    | 'MatchedBlockingRule'
  export type AdFrameStatus = {
    adFrameType: AdFrameType
    explanations?: AdFrameExplanation[]
  }
  export type AdScriptId = {
    scriptId: Runtime.ScriptId
    debuggerId: Runtime.UniqueDebuggerId
  }
  export type AdScriptAncestry = {
    ancestryChain: AdScriptId[]
    rootScriptFilterlistRule?: string
  }
  export type SecureContextType =
    | 'Secure'
    | 'SecureLocalhost'
    | 'InsecureScheme'
    | 'InsecureAncestor'
  export type CrossOriginIsolatedContextType =
    | 'Isolated'
    | 'NotIsolated'
    | 'NotIsolatedFeatureDisabled'
  export type GatedAPIFeatures =
    | 'SharedArrayBuffers'
    | 'SharedArrayBuffersTransferAllowed'
    | 'PerformanceMeasureMemory'
    | 'PerformanceProfile'
  export type PermissionsPolicyFeature =
    | 'accelerometer'
    | 'all-screens-capture'
    | 'ambient-light-sensor'
    | 'attribution-reporting'
    | 'autoplay'
    | 'bluetooth'
    | 'browsing-topics'
    | 'camera'
    | 'captured-surface-control'
    | 'ch-dpr'
    | 'ch-device-memory'
    | 'ch-downlink'
    | 'ch-ect'
    | 'ch-prefers-color-scheme'
    | 'ch-prefers-reduced-motion'
    | 'ch-prefers-reduced-transparency'
    | 'ch-rtt'
    | 'ch-save-data'
    | 'ch-ua'
    | 'ch-ua-arch'
    | 'ch-ua-bitness'
    | 'ch-ua-high-entropy-values'
    | 'ch-ua-platform'
    | 'ch-ua-model'
    | 'ch-ua-mobile'
    | 'ch-ua-form-factors'
    | 'ch-ua-full-version'
    | 'ch-ua-full-version-list'
    | 'ch-ua-platform-version'
    | 'ch-ua-wow64'
    | 'ch-viewport-height'
    | 'ch-viewport-width'
    | 'ch-width'
    | 'clipboard-read'
    | 'clipboard-write'
    | 'compute-pressure'
    | 'controlled-frame'
    | 'cross-origin-isolated'
    | 'deferred-fetch'
    | 'deferred-fetch-minimal'
    | 'device-attributes'
    | 'digital-credentials-get'
    | 'direct-sockets'
    | 'direct-sockets-private'
    | 'display-capture'
    | 'document-domain'
    | 'encrypted-media'
    | 'execution-while-out-of-viewport'
    | 'execution-while-not-rendered'
    | 'fenced-unpartitioned-storage-read'
    | 'focus-without-user-activation'
    | 'fullscreen'
    | 'frobulate'
    | 'gamepad'
    | 'geolocation'
    | 'gyroscope'
    | 'hid'
    | 'identity-credentials-get'
    | 'idle-detection'
    | 'interest-cohort'
    | 'join-ad-interest-group'
    | 'keyboard-map'
    | 'language-detector'
    | 'local-fonts'
    | 'local-network-access'
    | 'magnetometer'
    | 'media-playback-while-not-visible'
    | 'microphone'
    | 'midi'
    | 'on-device-speech-recognition'
    | 'otp-credentials'
    | 'payment'
    | 'picture-in-picture'
    | 'popins'
    | 'private-aggregation'
    | 'private-state-token-issuance'
    | 'private-state-token-redemption'
    | 'publickey-credentials-create'
    | 'publickey-credentials-get'
    | 'record-ad-auction-events'
    | 'rewriter'
    | 'run-ad-auction'
    | 'screen-wake-lock'
    | 'serial'
    | 'shared-autofill'
    | 'shared-storage'
    | 'shared-storage-select-url'
    | 'smart-card'
    | 'speaker-selection'
    | 'storage-access'
    | 'sub-apps'
    | 'summarizer'
    | 'sync-xhr'
    | 'translator'
    | 'unload'
    | 'usb'
    | 'usb-unrestricted'
    | 'vertical-scroll'
    | 'web-app-installation'
    | 'web-printing'
    | 'web-share'
    | 'window-management'
    | 'writer'
    | 'xr-spatial-tracking'
  export type PermissionsPolicyBlockReason =
    | 'Header'
    | 'IframeAttribute'
    | 'InFencedFrameTree'
    | 'InIsolatedApp'
  export type PermissionsPolicyBlockLocator = {
    frameId: FrameId
    blockReason: PermissionsPolicyBlockReason
  }
  export type PermissionsPolicyFeatureState = {
    feature: PermissionsPolicyFeature
    allowed: boolean
    locator?: PermissionsPolicyBlockLocator
  }
  export type OriginTrialTokenStatus =
    | 'Success'
    | 'NotSupported'
    | 'Insecure'
    | 'Expired'
    | 'WrongOrigin'
    | 'InvalidSignature'
    | 'Malformed'
    | 'WrongVersion'
    | 'FeatureDisabled'
    | 'TokenDisabled'
    | 'FeatureDisabledForUser'
    | 'UnknownTrial'
  export type OriginTrialStatus =
    | 'Enabled'
    | 'ValidTokenNotProvided'
    | 'OSNotSupported'
    | 'TrialNotAllowed'
  export type OriginTrialUsageRestriction = 'None' | 'Subset'
  export type OriginTrialToken = {
    origin: string
    matchSubDomains: boolean
    trialName: string
    expiryTime: Network.TimeSinceEpoch
    isThirdParty: boolean
    usageRestriction: OriginTrialUsageRestriction
  }
  export type OriginTrialTokenWithStatus = {
    rawTokenText: string
    parsedToken?: OriginTrialToken
    status: OriginTrialTokenStatus
  }
  export type OriginTrial = {
    trialName: string
    status: OriginTrialStatus
    tokensWithStatus: OriginTrialTokenWithStatus[]
  }
  export type SecurityOriginDetails = { isLocalhost: boolean }
  export type Frame = {
    id: FrameId
    parentId?: FrameId
    loaderId: Network.LoaderId
    name?: string
    url: string
    urlFragment?: string
    domainAndRegistry: string
    securityOrigin: string
    securityOriginDetails?: SecurityOriginDetails
    mimeType: string
    unreachableUrl?: string
    adFrameStatus?: AdFrameStatus
    secureContextType: SecureContextType
    crossOriginIsolatedContextType: CrossOriginIsolatedContextType
    gatedAPIFeatures: GatedAPIFeatures[]
  }
  export type FrameResource = {
    url: string
    type: Network.ResourceType
    mimeType: string
    lastModified?: Network.TimeSinceEpoch
    contentSize?: number
    failed?: boolean
    canceled?: boolean
  }
  export type FrameResourceTree = {
    frame: Frame
    childFrames?: FrameResourceTree[]
    resources: FrameResource[]
  }
  export type FrameTree = { frame: Frame; childFrames?: FrameTree[] }
  export type ScriptIdentifier = string
  export type TransitionType =
    | 'link'
    | 'typed'
    | 'address_bar'
    | 'auto_bookmark'
    | 'auto_subframe'
    | 'manual_subframe'
    | 'generated'
    | 'auto_toplevel'
    | 'form_submit'
    | 'reload'
    | 'keyword'
    | 'keyword_generated'
    | 'other'
  export type NavigationEntry = {
    id: number
    url: string
    userTypedURL: string
    title: string
    transitionType: TransitionType
  }
  export type ScreencastFrameMetadata = {
    offsetTop: number
    pageScaleFactor: number
    deviceWidth: number
    deviceHeight: number
    scrollOffsetX: number
    scrollOffsetY: number
    timestamp?: Network.TimeSinceEpoch
  }
  export type DialogType = 'alert' | 'confirm' | 'prompt' | 'beforeunload'
  export type AppManifestError = {
    message: string
    critical: number
    line: number
    column: number
  }
  export type AppManifestParsedProperties = { scope: string }
  export type LayoutViewport = {
    pageX: number
    pageY: number
    clientWidth: number
    clientHeight: number
  }
  export type VisualViewport = {
    offsetX: number
    offsetY: number
    pageX: number
    pageY: number
    clientWidth: number
    clientHeight: number
    scale: number
    zoom?: number
  }
  export type Viewport = {
    x: number
    y: number
    width: number
    height: number
    scale: number
  }
  export type FontFamilies = {
    standard?: string
    fixed?: string
    serif?: string
    sansSerif?: string
    cursive?: string
    fantasy?: string
    math?: string
  }
  export type ScriptFontFamilies = {
    script: string
    fontFamilies: FontFamilies
  }
  export type FontSizes = { standard?: number; fixed?: number }
  export type ClientNavigationReason =
    | 'anchorClick'
    | 'formSubmissionGet'
    | 'formSubmissionPost'
    | 'httpHeaderRefresh'
    | 'initialFrameNavigation'
    | 'metaTagRefresh'
    | 'other'
    | 'pageBlockInterstitial'
    | 'reload'
    | 'scriptInitiated'
  export type ClientNavigationDisposition =
    | 'currentTab'
    | 'newTab'
    | 'newWindow'
    | 'download'
  export type InstallabilityErrorArgument = { name: string; value: string }
  export type InstallabilityError = {
    errorId: string
    errorArguments: InstallabilityErrorArgument[]
  }
  export type ReferrerPolicy =
    | 'noReferrer'
    | 'noReferrerWhenDowngrade'
    | 'origin'
    | 'originWhenCrossOrigin'
    | 'sameOrigin'
    | 'strictOrigin'
    | 'strictOriginWhenCrossOrigin'
    | 'unsafeUrl'
  export type CompilationCacheParams = { url: string; eager?: boolean }
  export type FileFilter = { name?: string; accepts?: string[] }
  export type FileHandler = {
    action: string
    name: string
    icons?: ImageResource[]
    accepts?: FileFilter[]
    launchType: string
  }
  export type ImageResource = { url: string; sizes?: string; type?: string }
  export type LaunchHandler = { clientMode: string }
  export type ProtocolHandler = { protocol: string; url: string }
  export type RelatedApplication = { id?: string; url: string }
  export type ScopeExtension = { origin: string; hasOriginWildcard: boolean }
  export type Screenshot = {
    image: ImageResource
    formFactor: string
    label?: string
  }
  export type ShareTarget = {
    action: string
    method: string
    enctype: string
    title?: string
    text?: string
    url?: string
    files?: FileFilter[]
  }
  export type Shortcut = { name: string; url: string }
  export type WebAppManifest = {
    backgroundColor?: string
    description?: string
    dir?: string
    display?: string
    displayOverrides?: string[]
    fileHandlers?: FileHandler[]
    icons?: ImageResource[]
    id?: string
    lang?: string
    launchHandler?: LaunchHandler
    name?: string
    orientation?: string
    preferRelatedApplications?: boolean
    protocolHandlers?: ProtocolHandler[]
    relatedApplications?: RelatedApplication[]
    scope?: string
    scopeExtensions?: ScopeExtension[]
    screenshots?: Screenshot[]
    shareTarget?: ShareTarget
    shortName?: string
    shortcuts?: Shortcut[]
    startUrl?: string
    themeColor?: string
  }
  export type AutoResponseMode =
    | 'none'
    | 'autoAccept'
    | 'autoReject'
    | 'autoOptOut'
  export type NavigationType = 'Navigation' | 'BackForwardCacheRestore'
  export type BackForwardCacheNotRestoredReason =
    | 'NotPrimaryMainFrame'
    | 'BackForwardCacheDisabled'
    | 'RelatedActiveContentsExist'
    | 'HTTPStatusNotOK'
    | 'SchemeNotHTTPOrHTTPS'
    | 'Loading'
    | 'WasGrantedMediaAccess'
    | 'DisableForRenderFrameHostCalled'
    | 'DomainNotAllowed'
    | 'HTTPMethodNotGET'
    | 'SubframeIsNavigating'
    | 'Timeout'
    | 'CacheLimit'
    | 'JavaScriptExecution'
    | 'RendererProcessKilled'
    | 'RendererProcessCrashed'
    | 'SchedulerTrackedFeatureUsed'
    | 'ConflictingBrowsingInstance'
    | 'CacheFlushed'
    | 'ServiceWorkerVersionActivation'
    | 'SessionRestored'
    | 'ServiceWorkerPostMessage'
    | 'EnteredBackForwardCacheBeforeServiceWorkerHostAdded'
    | 'RenderFrameHostReused_SameSite'
    | 'RenderFrameHostReused_CrossSite'
    | 'ServiceWorkerClaim'
    | 'IgnoreEventAndEvict'
    | 'HaveInnerContents'
    | 'TimeoutPuttingInCache'
    | 'BackForwardCacheDisabledByLowMemory'
    | 'BackForwardCacheDisabledByCommandLine'
    | 'NetworkRequestDatapipeDrainedAsBytesConsumer'
    | 'NetworkRequestRedirected'
    | 'NetworkRequestTimeout'
    | 'NetworkExceedsBufferLimit'
    | 'NavigationCancelledWhileRestoring'
    | 'NotMostRecentNavigationEntry'
    | 'BackForwardCacheDisabledForPrerender'
    | 'UserAgentOverrideDiffers'
    | 'ForegroundCacheLimit'
    | 'BrowsingInstanceNotSwapped'
    | 'BackForwardCacheDisabledForDelegate'
    | 'UnloadHandlerExistsInMainFrame'
    | 'UnloadHandlerExistsInSubFrame'
    | 'ServiceWorkerUnregistration'
    | 'CacheControlNoStore'
    | 'CacheControlNoStoreCookieModified'
    | 'CacheControlNoStoreHTTPOnlyCookieModified'
    | 'NoResponseHead'
    | 'Unknown'
    | 'ActivationNavigationsDisallowedForBug1234857'
    | 'ErrorDocument'
    | 'FencedFramesEmbedder'
    | 'CookieDisabled'
    | 'HTTPAuthRequired'
    | 'CookieFlushed'
    | 'BroadcastChannelOnMessage'
    | 'WebViewSettingsChanged'
    | 'WebViewJavaScriptObjectChanged'
    | 'WebViewMessageListenerInjected'
    | 'WebViewSafeBrowsingAllowlistChanged'
    | 'WebViewDocumentStartJavascriptChanged'
    | 'WebSocket'
    | 'WebTransport'
    | 'WebRTC'
    | 'MainResourceHasCacheControlNoStore'
    | 'MainResourceHasCacheControlNoCache'
    | 'SubresourceHasCacheControlNoStore'
    | 'SubresourceHasCacheControlNoCache'
    | 'ContainsPlugins'
    | 'DocumentLoaded'
    | 'OutstandingNetworkRequestOthers'
    | 'RequestedMIDIPermission'
    | 'RequestedAudioCapturePermission'
    | 'RequestedVideoCapturePermission'
    | 'RequestedBackForwardCacheBlockedSensors'
    | 'RequestedBackgroundWorkPermission'
    | 'BroadcastChannel'
    | 'WebXR'
    | 'SharedWorker'
    | 'WebLocks'
    | 'WebHID'
    | 'WebShare'
    | 'RequestedStorageAccessGrant'
    | 'WebNfc'
    | 'OutstandingNetworkRequestFetch'
    | 'OutstandingNetworkRequestXHR'
    | 'AppBanner'
    | 'Printing'
    | 'WebDatabase'
    | 'PictureInPicture'
    | 'SpeechRecognizer'
    | 'IdleManager'
    | 'PaymentManager'
    | 'SpeechSynthesis'
    | 'KeyboardLock'
    | 'WebOTPService'
    | 'OutstandingNetworkRequestDirectSocket'
    | 'InjectedJavascript'
    | 'InjectedStyleSheet'
    | 'KeepaliveRequest'
    | 'IndexedDBEvent'
    | 'Dummy'
    | 'JsNetworkRequestReceivedCacheControlNoStoreResource'
    | 'WebRTCSticky'
    | 'WebTransportSticky'
    | 'WebSocketSticky'
    | 'SmartCard'
    | 'LiveMediaStreamTrack'
    | 'UnloadHandler'
    | 'ParserAborted'
    | 'ContentSecurityHandler'
    | 'ContentWebAuthenticationAPI'
    | 'ContentFileChooser'
    | 'ContentSerial'
    | 'ContentFileSystemAccess'
    | 'ContentMediaDevicesDispatcherHost'
    | 'ContentWebBluetooth'
    | 'ContentWebUSB'
    | 'ContentMediaSessionService'
    | 'ContentScreenReader'
    | 'ContentDiscarded'
    | 'EmbedderPopupBlockerTabHelper'
    | 'EmbedderSafeBrowsingTriggeredPopupBlocker'
    | 'EmbedderSafeBrowsingThreatDetails'
    | 'EmbedderAppBannerManager'
    | 'EmbedderDomDistillerViewerSource'
    | 'EmbedderDomDistillerSelfDeletingRequestDelegate'
    | 'EmbedderOomInterventionTabHelper'
    | 'EmbedderOfflinePage'
    | 'EmbedderChromePasswordManagerClientBindCredentialManager'
    | 'EmbedderPermissionRequestManager'
    | 'EmbedderModalDialog'
    | 'EmbedderExtensions'
    | 'EmbedderExtensionMessaging'
    | 'EmbedderExtensionMessagingForOpenPort'
    | 'EmbedderExtensionSentMessageToCachedFrame'
    | 'RequestedByWebViewClient'
    | 'PostMessageByWebViewClient'
    | 'CacheControlNoStoreDeviceBoundSessionTerminated'
    | 'CacheLimitPrunedOnModerateMemoryPressure'
    | 'CacheLimitPrunedOnCriticalMemoryPressure'
  export type BackForwardCacheNotRestoredReasonType =
    | 'SupportPending'
    | 'PageSupportNeeded'
    | 'Circumstantial'
  export type BackForwardCacheBlockingDetails = {
    url?: string
    function?: string
    lineNumber: number
    columnNumber: number
  }
  export type BackForwardCacheNotRestoredExplanation = {
    type: BackForwardCacheNotRestoredReasonType
    reason: BackForwardCacheNotRestoredReason
    context?: string
    details?: BackForwardCacheBlockingDetails[]
  }
  export type BackForwardCacheNotRestoredExplanationTree = {
    url: string
    explanations: BackForwardCacheNotRestoredExplanation[]
    children: BackForwardCacheNotRestoredExplanationTree[]
  }
  export interface AddScriptToEvaluateOnLoadResult {
    identifier: ScriptIdentifier
  }
  export interface AddScriptToEvaluateOnNewDocumentResult {
    identifier: ScriptIdentifier
  }
  export interface CaptureScreenshotResult {
    data: string
  }
  export interface CaptureSnapshotResult {
    data: string
  }
  export interface CreateIsolatedWorldResult {
    executionContextId: Runtime.ExecutionContextId
  }
  export interface GetAppManifestResult {
    url: string
    errors: AppManifestError[]
    data: string
    parsed: AppManifestParsedProperties
    manifest: WebAppManifest
  }
  export interface GetInstallabilityErrorsResult {
    installabilityErrors: InstallabilityError[]
  }
  export interface GetManifestIconsResult {
    primaryIcon: string
  }
  export interface GetAppIdResult {
    appId: string
    recommendedId: string
  }
  export interface GetAdScriptAncestryResult {
    adScriptAncestry: AdScriptAncestry
  }
  export interface GetFrameTreeResult {
    frameTree: FrameTree
  }
  export interface GetLayoutMetricsResult {
    layoutViewport: LayoutViewport
    visualViewport: VisualViewport
    contentSize: DOM.Rect
    cssLayoutViewport: LayoutViewport
    cssVisualViewport: VisualViewport
    cssContentSize: DOM.Rect
  }
  export interface GetNavigationHistoryResult {
    currentIndex: number
    entries: NavigationEntry[]
  }
  export interface GetResourceContentResult {
    content: string
    base64Encoded: boolean
  }
  export interface GetResourceTreeResult {
    frameTree: FrameResourceTree
  }
  export interface NavigateResult {
    frameId: FrameId
    loaderId: Network.LoaderId
    errorText: string
  }
  export interface PrintToPDFResult {
    data: string
    stream: IO.StreamHandle
  }
  export interface SearchInResourceResult {
    result: Debugger.SearchMatch[]
  }
  export interface GetPermissionsPolicyStateResult {
    states: PermissionsPolicyFeatureState[]
  }
  export interface GetOriginTrialsResult {
    originTrials: OriginTrial[]
  }
  export interface DomContentEventFiredEvent {
    timestamp: Network.MonotonicTime
  }
  export interface FileChooserOpenedEvent {
    frameId: FrameId
    mode: string
    backendNodeId: DOM.BackendNodeId
  }
  export interface FrameAttachedEvent {
    frameId: FrameId
    parentFrameId: FrameId
    stack: Runtime.StackTrace
  }
  export interface FrameClearedScheduledNavigationEvent {
    frameId: FrameId
  }
  export interface FrameDetachedEvent {
    frameId: FrameId
    reason: string
  }
  export interface FrameSubtreeWillBeDetachedEvent {
    frameId: FrameId
  }
  export interface FrameNavigatedEvent {
    frame: Frame
    type: NavigationType
  }
  export interface DocumentOpenedEvent {
    frame: Frame
  }
  export interface FrameResizedEvent {}
  export interface FrameStartedNavigatingEvent {
    frameId: FrameId
    url: string
    loaderId: Network.LoaderId
    navigationType: string
  }
  export interface FrameRequestedNavigationEvent {
    frameId: FrameId
    reason: ClientNavigationReason
    url: string
    disposition: ClientNavigationDisposition
  }
  export interface FrameScheduledNavigationEvent {
    frameId: FrameId
    delay: number
    reason: ClientNavigationReason
    url: string
  }
  export interface FrameStartedLoadingEvent {
    frameId: FrameId
  }
  export interface FrameStoppedLoadingEvent {
    frameId: FrameId
  }
  export interface DownloadWillBeginEvent {
    frameId: FrameId
    guid: string
    url: string
    suggestedFilename: string
  }
  export interface DownloadProgressEvent {
    guid: string
    totalBytes: number
    receivedBytes: number
    state: string
  }
  export interface InterstitialHiddenEvent {}
  export interface InterstitialShownEvent {}
  export interface JavascriptDialogClosedEvent {
    frameId: FrameId
    result: boolean
    userInput: string
  }
  export interface JavascriptDialogOpeningEvent {
    url: string
    frameId: FrameId
    message: string
    type: DialogType
    hasBrowserHandler: boolean
    defaultPrompt: string
  }
  export interface LifecycleEventEvent {
    frameId: FrameId
    loaderId: Network.LoaderId
    name: string
    timestamp: Network.MonotonicTime
  }
  export interface BackForwardCacheNotUsedEvent {
    loaderId: Network.LoaderId
    frameId: FrameId
    notRestoredExplanations: BackForwardCacheNotRestoredExplanation[]
    notRestoredExplanationsTree: BackForwardCacheNotRestoredExplanationTree
  }
  export interface LoadEventFiredEvent {
    timestamp: Network.MonotonicTime
  }
  export interface NavigatedWithinDocumentEvent {
    frameId: FrameId
    url: string
    navigationType: string
  }
  export interface ScreencastFrameEvent {
    data: string
    metadata: ScreencastFrameMetadata
    sessionId: number
  }
  export interface ScreencastVisibilityChangedEvent {
    visible: boolean
  }
  export interface WindowOpenEvent {
    url: string
    windowName: string
    windowFeatures: string[]
    userGesture: boolean
  }
  export interface CompilationCacheProducedEvent {
    url: string
    data: string
  }
  export interface EventMap {
    domContentEventFired: DomContentEventFiredEvent
    fileChooserOpened: FileChooserOpenedEvent
    frameAttached: FrameAttachedEvent
    frameClearedScheduledNavigation: FrameClearedScheduledNavigationEvent
    frameDetached: FrameDetachedEvent
    frameSubtreeWillBeDetached: FrameSubtreeWillBeDetachedEvent
    frameNavigated: FrameNavigatedEvent
    documentOpened: DocumentOpenedEvent
    frameResized: FrameResizedEvent
    frameStartedNavigating: FrameStartedNavigatingEvent
    frameRequestedNavigation: FrameRequestedNavigationEvent
    frameScheduledNavigation: FrameScheduledNavigationEvent
    frameStartedLoading: FrameStartedLoadingEvent
    frameStoppedLoading: FrameStoppedLoadingEvent
    downloadWillBegin: DownloadWillBeginEvent
    downloadProgress: DownloadProgressEvent
    interstitialHidden: InterstitialHiddenEvent
    interstitialShown: InterstitialShownEvent
    javascriptDialogClosed: JavascriptDialogClosedEvent
    javascriptDialogOpening: JavascriptDialogOpeningEvent
    lifecycleEvent: LifecycleEventEvent
    backForwardCacheNotUsed: BackForwardCacheNotUsedEvent
    loadEventFired: LoadEventFiredEvent
    navigatedWithinDocument: NavigatedWithinDocumentEvent
    screencastFrame: ScreencastFrameEvent
    screencastVisibilityChanged: ScreencastVisibilityChangedEvent
    windowOpen: WindowOpenEvent
    compilationCacheProduced: CompilationCacheProducedEvent
  }
}
export namespace Performance {
  export type Metric = { name: string; value: number }
  export interface GetMetricsResult {
    metrics: Metric[]
  }
  export interface MetricsEvent {
    metrics: Metric[]
    title: string
  }
  export interface EventMap {
    metrics: MetricsEvent
  }
}
export namespace PerformanceTimeline {
  export type LargestContentfulPaint = {
    renderTime: Network.TimeSinceEpoch
    loadTime: Network.TimeSinceEpoch
    size: number
    elementId?: string
    url?: string
    nodeId?: DOM.BackendNodeId
  }
  export type LayoutShiftAttribution = {
    previousRect: DOM.Rect
    currentRect: DOM.Rect
    nodeId?: DOM.BackendNodeId
  }
  export type LayoutShift = {
    value: number
    hadRecentInput: boolean
    lastInputTime: Network.TimeSinceEpoch
    sources: LayoutShiftAttribution[]
  }
  export type TimelineEvent = {
    frameId: Page.FrameId
    type: string
    name: string
    time: Network.TimeSinceEpoch
    duration?: number
    lcpDetails?: LargestContentfulPaint
    layoutShiftDetails?: LayoutShift
  }
  export interface TimelineEventAddedEvent {
    event: TimelineEvent
  }
  export interface EventMap {
    timelineEventAdded: TimelineEventAddedEvent
  }
}
export namespace Security {
  export type CertificateId = number
  export type MixedContentType = 'blockable' | 'optionally-blockable' | 'none'
  export type SecurityState =
    | 'unknown'
    | 'neutral'
    | 'insecure'
    | 'secure'
    | 'info'
    | 'insecure-broken'
  export type CertificateSecurityState = {
    protocol: string
    keyExchange: string
    keyExchangeGroup?: string
    cipher: string
    mac?: string
    certificate: string[]
    subjectName: string
    issuer: string
    validFrom: Network.TimeSinceEpoch
    validTo: Network.TimeSinceEpoch
    certificateNetworkError?: string
    certificateHasWeakSignature: boolean
    certificateHasSha1Signature: boolean
    modernSSL: boolean
    obsoleteSslProtocol: boolean
    obsoleteSslKeyExchange: boolean
    obsoleteSslCipher: boolean
    obsoleteSslSignature: boolean
  }
  export type SafetyTipStatus = 'badReputation' | 'lookalike'
  export type SafetyTipInfo = {
    safetyTipStatus: SafetyTipStatus
    safeUrl?: string
  }
  export type VisibleSecurityState = {
    securityState: SecurityState
    certificateSecurityState?: CertificateSecurityState
    safetyTipInfo?: SafetyTipInfo
    securityStateIssueIds: string[]
  }
  export type SecurityStateExplanation = {
    securityState: SecurityState
    title: string
    summary: string
    description: string
    mixedContentType: MixedContentType
    certificate: string[]
    recommendations?: string[]
  }
  export type InsecureContentStatus = {
    ranMixedContent: boolean
    displayedMixedContent: boolean
    containedMixedForm: boolean
    ranContentWithCertErrors: boolean
    displayedContentWithCertErrors: boolean
    ranInsecureContentStyle: SecurityState
    displayedInsecureContentStyle: SecurityState
  }
  export type CertificateErrorAction = 'continue' | 'cancel'
  export interface CertificateErrorEvent {
    eventId: number
    errorType: string
    requestURL: string
  }
  export interface VisibleSecurityStateChangedEvent {
    visibleSecurityState: VisibleSecurityState
  }
  export interface SecurityStateChangedEvent {
    securityState: SecurityState
    schemeIsCryptographic: boolean
    explanations: SecurityStateExplanation[]
    insecureContentStatus: InsecureContentStatus
    summary: string
  }
  export interface EventMap {
    certificateError: CertificateErrorEvent
    visibleSecurityStateChanged: VisibleSecurityStateChangedEvent
    securityStateChanged: SecurityStateChangedEvent
  }
}
export namespace ServiceWorker {
  export type RegistrationID = string
  export type ServiceWorkerRegistration = {
    registrationId: RegistrationID
    scopeURL: string
    isDeleted: boolean
  }
  export type ServiceWorkerVersionRunningStatus =
    | 'stopped'
    | 'starting'
    | 'running'
    | 'stopping'
  export type ServiceWorkerVersionStatus =
    | 'new'
    | 'installing'
    | 'installed'
    | 'activating'
    | 'activated'
    | 'redundant'
  export type ServiceWorkerVersion = {
    versionId: string
    registrationId: RegistrationID
    scriptURL: string
    runningStatus: ServiceWorkerVersionRunningStatus
    status: ServiceWorkerVersionStatus
    scriptLastModified?: number
    scriptResponseTime?: number
    controlledClients?: Target.TargetID[]
    targetId?: Target.TargetID
    routerRules?: string
  }
  export type ServiceWorkerErrorMessage = {
    errorMessage: string
    registrationId: RegistrationID
    versionId: string
    sourceURL: string
    lineNumber: number
    columnNumber: number
  }
  export interface WorkerErrorReportedEvent {
    errorMessage: ServiceWorkerErrorMessage
  }
  export interface WorkerRegistrationUpdatedEvent {
    registrations: ServiceWorkerRegistration[]
  }
  export interface WorkerVersionUpdatedEvent {
    versions: ServiceWorkerVersion[]
  }
  export interface EventMap {
    workerErrorReported: WorkerErrorReportedEvent
    workerRegistrationUpdated: WorkerRegistrationUpdatedEvent
    workerVersionUpdated: WorkerVersionUpdatedEvent
  }
}
export namespace Storage {
  export type SerializedStorageKey = string
  export type StorageType =
    | 'cookies'
    | 'file_systems'
    | 'indexeddb'
    | 'local_storage'
    | 'shader_cache'
    | 'websql'
    | 'service_workers'
    | 'cache_storage'
    | 'interest_groups'
    | 'shared_storage'
    | 'storage_buckets'
    | 'all'
    | 'other'
  export type UsageForType = { storageType: StorageType; usage: number }
  export type TrustTokens = { issuerOrigin: string; count: number }
  export type InterestGroupAuctionId = string
  export type InterestGroupAccessType =
    | 'join'
    | 'leave'
    | 'update'
    | 'loaded'
    | 'bid'
    | 'win'
    | 'additionalBid'
    | 'additionalBidWin'
    | 'topLevelBid'
    | 'topLevelAdditionalBid'
    | 'clear'
  export type InterestGroupAuctionEventType = 'started' | 'configResolved'
  export type InterestGroupAuctionFetchType =
    | 'bidderJs'
    | 'bidderWasm'
    | 'sellerJs'
    | 'bidderTrustedSignals'
    | 'sellerTrustedSignals'
  export type SharedStorageAccessScope =
    | 'window'
    | 'sharedStorageWorklet'
    | 'protectedAudienceWorklet'
    | 'header'
  export type SharedStorageAccessMethod =
    | 'addModule'
    | 'createWorklet'
    | 'selectURL'
    | 'run'
    | 'batchUpdate'
    | 'set'
    | 'append'
    | 'delete'
    | 'clear'
    | 'get'
    | 'keys'
    | 'values'
    | 'entries'
    | 'length'
    | 'remainingBudget'
  export type SharedStorageEntry = { key: string; value: string }
  export type SharedStorageMetadata = {
    creationTime: Network.TimeSinceEpoch
    length: number
    remainingBudget: number
    bytesUsed: number
  }
  export type SharedStoragePrivateAggregationConfig = {
    aggregationCoordinatorOrigin?: string
    contextId?: string
    filteringIdMaxBytes: number
    maxContributions?: number
  }
  export type SharedStorageReportingMetadata = {
    eventType: string
    reportingUrl: string
  }
  export type SharedStorageUrlWithMetadata = {
    url: string
    reportingMetadata: SharedStorageReportingMetadata[]
  }
  export type SharedStorageAccessParams = {
    scriptSourceUrl?: string
    dataOrigin?: string
    operationName?: string
    operationId?: string
    keepAlive?: boolean
    privateAggregationConfig?: SharedStoragePrivateAggregationConfig
    serializedData?: string
    urlsWithMetadata?: SharedStorageUrlWithMetadata[]
    urnUuid?: string
    key?: string
    value?: string
    ignoreIfPresent?: boolean
    workletOrdinal?: number
    workletTargetId?: Target.TargetID
    withLock?: string
    batchUpdateId?: string
    batchSize?: number
  }
  export type StorageBucketsDurability = 'relaxed' | 'strict'
  export type StorageBucket = {
    storageKey: SerializedStorageKey
    name?: string
  }
  export type StorageBucketInfo = {
    bucket: StorageBucket
    id: string
    expiration: Network.TimeSinceEpoch
    quota: number
    persistent: boolean
    durability: StorageBucketsDurability
  }
  export type AttributionReportingSourceType = 'navigation' | 'event'
  export type UnsignedInt64AsBase10 = string
  export type UnsignedInt128AsBase16 = string
  export type SignedInt64AsBase10 = string
  export type AttributionReportingFilterDataEntry = {
    key: string
    values: string[]
  }
  export type AttributionReportingFilterConfig = {
    filterValues: AttributionReportingFilterDataEntry[]
    lookbackWindow?: number
  }
  export type AttributionReportingFilterPair = {
    filters: AttributionReportingFilterConfig[]
    notFilters: AttributionReportingFilterConfig[]
  }
  export type AttributionReportingAggregationKeysEntry = {
    key: string
    value: UnsignedInt128AsBase16
  }
  export type AttributionReportingEventReportWindows = {
    start: number
    ends: number[]
  }
  export type AttributionReportingTriggerDataMatching = 'exact' | 'modulus'
  export type AttributionReportingAggregatableDebugReportingData = {
    keyPiece: UnsignedInt128AsBase16
    value: number
    types: string[]
  }
  export type AttributionReportingAggregatableDebugReportingConfig = {
    budget?: number
    keyPiece: UnsignedInt128AsBase16
    debugData: AttributionReportingAggregatableDebugReportingData[]
    aggregationCoordinatorOrigin?: string
  }
  export type AttributionScopesData = {
    values: string[]
    limit: number
    maxEventStates: number
  }
  export type AttributionReportingNamedBudgetDef = {
    name: string
    budget: number
  }
  export type AttributionReportingSourceRegistration = {
    time: Network.TimeSinceEpoch
    expiry: number
    triggerData: number[]
    eventReportWindows: AttributionReportingEventReportWindows
    aggregatableReportWindow: number
    type: AttributionReportingSourceType
    sourceOrigin: string
    reportingOrigin: string
    destinationSites: string[]
    eventId: UnsignedInt64AsBase10
    priority: SignedInt64AsBase10
    filterData: AttributionReportingFilterDataEntry[]
    aggregationKeys: AttributionReportingAggregationKeysEntry[]
    debugKey?: UnsignedInt64AsBase10
    triggerDataMatching: AttributionReportingTriggerDataMatching
    destinationLimitPriority: SignedInt64AsBase10
    aggregatableDebugReportingConfig: AttributionReportingAggregatableDebugReportingConfig
    scopesData?: AttributionScopesData
    maxEventLevelReports: number
    namedBudgets: AttributionReportingNamedBudgetDef[]
    debugReporting: boolean
    eventLevelEpsilon: number
  }
  export type AttributionReportingSourceRegistrationResult =
    | 'success'
    | 'internalError'
    | 'insufficientSourceCapacity'
    | 'insufficientUniqueDestinationCapacity'
    | 'excessiveReportingOrigins'
    | 'prohibitedByBrowserPolicy'
    | 'successNoised'
    | 'destinationReportingLimitReached'
    | 'destinationGlobalLimitReached'
    | 'destinationBothLimitsReached'
    | 'reportingOriginsPerSiteLimitReached'
    | 'exceedsMaxChannelCapacity'
    | 'exceedsMaxScopesChannelCapacity'
    | 'exceedsMaxTriggerStateCardinality'
    | 'exceedsMaxEventStatesLimit'
    | 'destinationPerDayReportingLimitReached'
  export type AttributionReportingSourceRegistrationTimeConfig =
    | 'include'
    | 'exclude'
  export type AttributionReportingAggregatableValueDictEntry = {
    key: string
    value: number
    filteringId: UnsignedInt64AsBase10
  }
  export type AttributionReportingAggregatableValueEntry = {
    values: AttributionReportingAggregatableValueDictEntry[]
    filters: AttributionReportingFilterPair
  }
  export type AttributionReportingEventTriggerData = {
    data: UnsignedInt64AsBase10
    priority: SignedInt64AsBase10
    dedupKey?: UnsignedInt64AsBase10
    filters: AttributionReportingFilterPair
  }
  export type AttributionReportingAggregatableTriggerData = {
    keyPiece: UnsignedInt128AsBase16
    sourceKeys: string[]
    filters: AttributionReportingFilterPair
  }
  export type AttributionReportingAggregatableDedupKey = {
    dedupKey?: UnsignedInt64AsBase10
    filters: AttributionReportingFilterPair
  }
  export type AttributionReportingNamedBudgetCandidate = {
    name?: string
    filters: AttributionReportingFilterPair
  }
  export type AttributionReportingTriggerRegistration = {
    filters: AttributionReportingFilterPair
    debugKey?: UnsignedInt64AsBase10
    aggregatableDedupKeys: AttributionReportingAggregatableDedupKey[]
    eventTriggerData: AttributionReportingEventTriggerData[]
    aggregatableTriggerData: AttributionReportingAggregatableTriggerData[]
    aggregatableValues: AttributionReportingAggregatableValueEntry[]
    aggregatableFilteringIdMaxBytes: number
    debugReporting: boolean
    aggregationCoordinatorOrigin?: string
    sourceRegistrationTimeConfig: AttributionReportingSourceRegistrationTimeConfig
    triggerContextId?: string
    aggregatableDebugReportingConfig: AttributionReportingAggregatableDebugReportingConfig
    scopes: string[]
    namedBudgets: AttributionReportingNamedBudgetCandidate[]
  }
  export type AttributionReportingEventLevelResult =
    | 'success'
    | 'successDroppedLowerPriority'
    | 'internalError'
    | 'noCapacityForAttributionDestination'
    | 'noMatchingSources'
    | 'deduplicated'
    | 'excessiveAttributions'
    | 'priorityTooLow'
    | 'neverAttributedSource'
    | 'excessiveReportingOrigins'
    | 'noMatchingSourceFilterData'
    | 'prohibitedByBrowserPolicy'
    | 'noMatchingConfigurations'
    | 'excessiveReports'
    | 'falselyAttributedSource'
    | 'reportWindowPassed'
    | 'notRegistered'
    | 'reportWindowNotStarted'
    | 'noMatchingTriggerData'
  export type AttributionReportingAggregatableResult =
    | 'success'
    | 'internalError'
    | 'noCapacityForAttributionDestination'
    | 'noMatchingSources'
    | 'excessiveAttributions'
    | 'excessiveReportingOrigins'
    | 'noHistograms'
    | 'insufficientBudget'
    | 'insufficientNamedBudget'
    | 'noMatchingSourceFilterData'
    | 'notRegistered'
    | 'prohibitedByBrowserPolicy'
    | 'deduplicated'
    | 'reportWindowPassed'
    | 'excessiveReports'
  export type AttributionReportingReportResult =
    | 'sent'
    | 'prohibited'
    | 'failedToAssemble'
    | 'expired'
  export type RelatedWebsiteSet = {
    primarySites: string[]
    associatedSites: string[]
    serviceSites: string[]
  }
  export interface GetStorageKeyForFrameResult {
    storageKey: SerializedStorageKey
  }
  export interface GetCookiesResult {
    cookies: Network.Cookie[]
  }
  export interface GetUsageAndQuotaResult {
    usage: number
    quota: number
    overrideActive: boolean
    usageBreakdown: UsageForType[]
  }
  export interface GetTrustTokensResult {
    tokens: TrustTokens[]
  }
  export interface ClearTrustTokensResult {
    didDeleteTokens: boolean
  }
  export interface GetInterestGroupDetailsResult {
    details: Record<string, unknown>
  }
  export interface GetSharedStorageMetadataResult {
    metadata: SharedStorageMetadata
  }
  export interface GetSharedStorageEntriesResult {
    entries: SharedStorageEntry[]
  }
  export interface RunBounceTrackingMitigationsResult {
    deletedSites: string[]
  }
  export interface SendPendingAttributionReportsResult {
    numSent: number
  }
  export interface GetRelatedWebsiteSetsResult {
    sets: RelatedWebsiteSet[]
  }
  export interface GetAffectedUrlsForThirdPartyCookieMetadataResult {
    matchedUrls: string[]
  }
  export interface CacheStorageContentUpdatedEvent {
    origin: string
    storageKey: string
    bucketId: string
    cacheName: string
  }
  export interface CacheStorageListUpdatedEvent {
    origin: string
    storageKey: string
    bucketId: string
  }
  export interface IndexedDBContentUpdatedEvent {
    origin: string
    storageKey: string
    bucketId: string
    databaseName: string
    objectStoreName: string
  }
  export interface IndexedDBListUpdatedEvent {
    origin: string
    storageKey: string
    bucketId: string
  }
  export interface InterestGroupAccessedEvent {
    accessTime: Network.TimeSinceEpoch
    type: InterestGroupAccessType
    ownerOrigin: string
    name: string
    componentSellerOrigin: string
    bid: number
    bidCurrency: string
    uniqueAuctionId: InterestGroupAuctionId
  }
  export interface InterestGroupAuctionEventOccurredEvent {
    eventTime: Network.TimeSinceEpoch
    type: InterestGroupAuctionEventType
    uniqueAuctionId: InterestGroupAuctionId
    parentAuctionId: InterestGroupAuctionId
    auctionConfig: Record<string, unknown>
  }
  export interface InterestGroupAuctionNetworkRequestCreatedEvent {
    type: InterestGroupAuctionFetchType
    requestId: Network.RequestId
    auctions: InterestGroupAuctionId[]
  }
  export interface SharedStorageAccessedEvent {
    accessTime: Network.TimeSinceEpoch
    scope: SharedStorageAccessScope
    method: SharedStorageAccessMethod
    mainFrameId: Page.FrameId
    ownerOrigin: string
    ownerSite: string
    params: SharedStorageAccessParams
  }
  export interface SharedStorageWorkletOperationExecutionFinishedEvent {
    finishedTime: Network.TimeSinceEpoch
    executionTime: number
    method: SharedStorageAccessMethod
    operationId: string
    workletTargetId: Target.TargetID
    mainFrameId: Page.FrameId
    ownerOrigin: string
  }
  export interface StorageBucketCreatedOrUpdatedEvent {
    bucketInfo: StorageBucketInfo
  }
  export interface StorageBucketDeletedEvent {
    bucketId: string
  }
  export interface AttributionReportingSourceRegisteredEvent {
    registration: AttributionReportingSourceRegistration
    result: AttributionReportingSourceRegistrationResult
  }
  export interface AttributionReportingTriggerRegisteredEvent {
    registration: AttributionReportingTriggerRegistration
    eventLevel: AttributionReportingEventLevelResult
    aggregatable: AttributionReportingAggregatableResult
  }
  export interface AttributionReportingReportSentEvent {
    url: string
    body: Record<string, unknown>
    result: AttributionReportingReportResult
    netError: number
    netErrorName: string
    httpStatusCode: number
  }
  export interface EventMap {
    cacheStorageContentUpdated: CacheStorageContentUpdatedEvent
    cacheStorageListUpdated: CacheStorageListUpdatedEvent
    indexedDBContentUpdated: IndexedDBContentUpdatedEvent
    indexedDBListUpdated: IndexedDBListUpdatedEvent
    interestGroupAccessed: InterestGroupAccessedEvent
    interestGroupAuctionEventOccurred: InterestGroupAuctionEventOccurredEvent
    interestGroupAuctionNetworkRequestCreated: InterestGroupAuctionNetworkRequestCreatedEvent
    sharedStorageAccessed: SharedStorageAccessedEvent
    sharedStorageWorkletOperationExecutionFinished: SharedStorageWorkletOperationExecutionFinishedEvent
    storageBucketCreatedOrUpdated: StorageBucketCreatedOrUpdatedEvent
    storageBucketDeleted: StorageBucketDeletedEvent
    attributionReportingSourceRegistered: AttributionReportingSourceRegisteredEvent
    attributionReportingTriggerRegistered: AttributionReportingTriggerRegisteredEvent
    attributionReportingReportSent: AttributionReportingReportSentEvent
  }
}
export namespace SystemInfo {
  export type GPUDevice = {
    vendorId: number
    deviceId: number
    subSysId?: number
    revision?: number
    vendorString: string
    deviceString: string
    driverVendor: string
    driverVersion: string
  }
  export type Size = { width: number; height: number }
  export type VideoDecodeAcceleratorCapability = {
    profile: string
    maxResolution: Size
    minResolution: Size
  }
  export type VideoEncodeAcceleratorCapability = {
    profile: string
    maxResolution: Size
    maxFramerateNumerator: number
    maxFramerateDenominator: number
  }
  export type SubsamplingFormat = 'yuv420' | 'yuv422' | 'yuv444'
  export type ImageType = 'jpeg' | 'webp' | 'unknown'
  export type ImageDecodeAcceleratorCapability = {
    imageType: ImageType
    maxDimensions: Size
    minDimensions: Size
    subsamplings: SubsamplingFormat[]
  }
  export type GPUInfo = {
    devices: GPUDevice[]
    auxAttributes?: Record<string, unknown>
    featureStatus?: Record<string, unknown>
    driverBugWorkarounds: string[]
    videoDecoding: VideoDecodeAcceleratorCapability[]
    videoEncoding: VideoEncodeAcceleratorCapability[]
    imageDecoding: ImageDecodeAcceleratorCapability[]
  }
  export type ProcessInfo = { type: string; id: number; cpuTime: number }
  export interface GetInfoResult {
    gpu: GPUInfo
    modelName: string
    modelVersion: string
    commandLine: string
  }
  export interface GetFeatureStateResult {
    featureEnabled: boolean
  }
  export interface GetProcessInfoResult {
    processInfo: ProcessInfo[]
  }
}
export namespace Target {
  export type TargetID = string
  export type SessionID = string
  export type TargetInfo = {
    targetId: TargetID
    type: string
    title: string
    url: string
    attached: boolean
    openerId?: TargetID
    canAccessOpener: boolean
    openerFrameId?: Page.FrameId
    browserContextId?: Browser.BrowserContextID
    subtype?: string
  }
  export type FilterEntry = { exclude?: boolean; type?: string }
  export type TargetFilter = FilterEntry[]
  export type RemoteLocation = { host: string; port: number }
  export type WindowState = 'normal' | 'minimized' | 'maximized' | 'fullscreen'
  export interface AttachToTargetResult {
    sessionId: SessionID
  }
  export interface AttachToBrowserTargetResult {
    sessionId: SessionID
  }
  export interface CloseTargetResult {
    success: boolean
  }
  export interface CreateBrowserContextResult {
    browserContextId: Browser.BrowserContextID
  }
  export interface GetBrowserContextsResult {
    browserContextIds: Browser.BrowserContextID[]
  }
  export interface CreateTargetResult {
    targetId: TargetID
  }
  export interface GetTargetInfoResult {
    targetInfo: TargetInfo
  }
  export interface GetTargetsResult {
    targetInfos: TargetInfo[]
  }
  export interface AttachedToTargetEvent {
    sessionId: SessionID
    targetInfo: TargetInfo
    waitingForDebugger: boolean
  }
  export interface DetachedFromTargetEvent {
    sessionId: SessionID
    targetId: TargetID
  }
  export interface ReceivedMessageFromTargetEvent {
    sessionId: SessionID
    message: string
    targetId: TargetID
  }
  export interface TargetCreatedEvent {
    targetInfo: TargetInfo
  }
  export interface TargetDestroyedEvent {
    targetId: TargetID
  }
  export interface TargetCrashedEvent {
    targetId: TargetID
    status: string
    errorCode: number
  }
  export interface TargetInfoChangedEvent {
    targetInfo: TargetInfo
  }
  export interface EventMap {
    attachedToTarget: AttachedToTargetEvent
    detachedFromTarget: DetachedFromTargetEvent
    receivedMessageFromTarget: ReceivedMessageFromTargetEvent
    targetCreated: TargetCreatedEvent
    targetDestroyed: TargetDestroyedEvent
    targetCrashed: TargetCrashedEvent
    targetInfoChanged: TargetInfoChangedEvent
  }
}
export namespace Tethering {
  export interface AcceptedEvent {
    port: number
    connectionId: string
  }
  export interface EventMap {
    accepted: AcceptedEvent
  }
}
export namespace Tracing {
  export type MemoryDumpConfig = Record<string, unknown>
  export type TraceConfig = {
    recordMode?: string
    traceBufferSizeInKb?: number
    enableSampling?: boolean
    enableSystrace?: boolean
    enableArgumentFilter?: boolean
    includedCategories?: string[]
    excludedCategories?: string[]
    syntheticDelays?: string[]
    memoryDumpConfig?: MemoryDumpConfig
  }
  export type StreamFormat = 'json' | 'proto'
  export type StreamCompression = 'none' | 'gzip'
  export type MemoryDumpLevelOfDetail = 'background' | 'light' | 'detailed'
  export type TracingBackend = 'auto' | 'chrome' | 'system'
  export interface GetCategoriesResult {
    categories: string[]
  }
  export interface RequestMemoryDumpResult {
    dumpGuid: string
    success: boolean
  }
  export interface BufferUsageEvent {
    percentFull: number
    eventCount: number
    value: number
  }
  export interface DataCollectedEvent {
    value: Record<string, unknown>[]
  }
  export interface TracingCompleteEvent {
    dataLossOccurred: boolean
    stream: IO.StreamHandle
    traceFormat: StreamFormat
    streamCompression: StreamCompression
  }
  export interface EventMap {
    bufferUsage: BufferUsageEvent
    dataCollected: DataCollectedEvent
    tracingComplete: TracingCompleteEvent
  }
}
export namespace Fetch {
  export type RequestId = string
  export type RequestStage = 'Request' | 'Response'
  export type RequestPattern = {
    urlPattern?: string
    resourceType?: Network.ResourceType
    requestStage?: RequestStage
  }
  export type HeaderEntry = { name: string; value: string }
  export type AuthChallenge = {
    source?: string
    origin: string
    scheme: string
    realm: string
  }
  export type AuthChallengeResponse = {
    response: string
    username?: string
    password?: string
  }
  export interface GetResponseBodyResult {
    body: string
    base64Encoded: boolean
  }
  export interface TakeResponseBodyAsStreamResult {
    stream: IO.StreamHandle
  }
  export interface RequestPausedEvent {
    requestId: RequestId
    request: Network.Request
    frameId: Page.FrameId
    resourceType: Network.ResourceType
    responseErrorReason: Network.ErrorReason
    responseStatusCode: number
    responseStatusText: string
    responseHeaders: HeaderEntry[]
    networkId: Network.RequestId
    redirectedRequestId: RequestId
  }
  export interface AuthRequiredEvent {
    requestId: RequestId
    request: Network.Request
    frameId: Page.FrameId
    resourceType: Network.ResourceType
    authChallenge: AuthChallenge
  }
  export interface EventMap {
    requestPaused: RequestPausedEvent
    authRequired: AuthRequiredEvent
  }
}
export namespace WebAudio {
  export type GraphObjectId = string
  export type ContextType = 'realtime' | 'offline'
  export type ContextState = 'suspended' | 'running' | 'closed' | 'interrupted'
  export type NodeType = string
  export type ChannelCountMode = 'clamped-max' | 'explicit' | 'max'
  export type ChannelInterpretation = 'discrete' | 'speakers'
  export type ParamType = string
  export type AutomationRate = 'a-rate' | 'k-rate'
  export type ContextRealtimeData = {
    currentTime: number
    renderCapacity: number
    callbackIntervalMean: number
    callbackIntervalVariance: number
  }
  export type BaseAudioContext = {
    contextId: GraphObjectId
    contextType: ContextType
    contextState: ContextState
    realtimeData?: ContextRealtimeData
    callbackBufferSize: number
    maxOutputChannelCount: number
    sampleRate: number
  }
  export type AudioListener = {
    listenerId: GraphObjectId
    contextId: GraphObjectId
  }
  export type AudioNode = {
    nodeId: GraphObjectId
    contextId: GraphObjectId
    nodeType: NodeType
    numberOfInputs: number
    numberOfOutputs: number
    channelCount: number
    channelCountMode: ChannelCountMode
    channelInterpretation: ChannelInterpretation
  }
  export type AudioParam = {
    paramId: GraphObjectId
    nodeId: GraphObjectId
    contextId: GraphObjectId
    paramType: ParamType
    rate: AutomationRate
    defaultValue: number
    minValue: number
    maxValue: number
  }
  export interface GetRealtimeDataResult {
    realtimeData: ContextRealtimeData
  }
  export interface ContextCreatedEvent {
    context: BaseAudioContext
  }
  export interface ContextWillBeDestroyedEvent {
    contextId: GraphObjectId
  }
  export interface ContextChangedEvent {
    context: BaseAudioContext
  }
  export interface AudioListenerCreatedEvent {
    listener: AudioListener
  }
  export interface AudioListenerWillBeDestroyedEvent {
    contextId: GraphObjectId
    listenerId: GraphObjectId
  }
  export interface AudioNodeCreatedEvent {
    node: AudioNode
  }
  export interface AudioNodeWillBeDestroyedEvent {
    contextId: GraphObjectId
    nodeId: GraphObjectId
  }
  export interface AudioParamCreatedEvent {
    param: AudioParam
  }
  export interface AudioParamWillBeDestroyedEvent {
    contextId: GraphObjectId
    nodeId: GraphObjectId
    paramId: GraphObjectId
  }
  export interface NodesConnectedEvent {
    contextId: GraphObjectId
    sourceId: GraphObjectId
    destinationId: GraphObjectId
    sourceOutputIndex: number
    destinationInputIndex: number
  }
  export interface NodesDisconnectedEvent {
    contextId: GraphObjectId
    sourceId: GraphObjectId
    destinationId: GraphObjectId
    sourceOutputIndex: number
    destinationInputIndex: number
  }
  export interface NodeParamConnectedEvent {
    contextId: GraphObjectId
    sourceId: GraphObjectId
    destinationId: GraphObjectId
    sourceOutputIndex: number
  }
  export interface NodeParamDisconnectedEvent {
    contextId: GraphObjectId
    sourceId: GraphObjectId
    destinationId: GraphObjectId
    sourceOutputIndex: number
  }
  export interface EventMap {
    contextCreated: ContextCreatedEvent
    contextWillBeDestroyed: ContextWillBeDestroyedEvent
    contextChanged: ContextChangedEvent
    audioListenerCreated: AudioListenerCreatedEvent
    audioListenerWillBeDestroyed: AudioListenerWillBeDestroyedEvent
    audioNodeCreated: AudioNodeCreatedEvent
    audioNodeWillBeDestroyed: AudioNodeWillBeDestroyedEvent
    audioParamCreated: AudioParamCreatedEvent
    audioParamWillBeDestroyed: AudioParamWillBeDestroyedEvent
    nodesConnected: NodesConnectedEvent
    nodesDisconnected: NodesDisconnectedEvent
    nodeParamConnected: NodeParamConnectedEvent
    nodeParamDisconnected: NodeParamDisconnectedEvent
  }
}
export namespace WebAuthn {
  export type AuthenticatorId = string
  export type AuthenticatorProtocol = 'u2f' | 'ctap2'
  export type Ctap2Version = 'ctap2_0' | 'ctap2_1'
  export type AuthenticatorTransport =
    | 'usb'
    | 'nfc'
    | 'ble'
    | 'cable'
    | 'internal'
  export type VirtualAuthenticatorOptions = {
    protocol: AuthenticatorProtocol
    ctap2Version?: Ctap2Version
    transport: AuthenticatorTransport
    hasResidentKey?: boolean
    hasUserVerification?: boolean
    hasLargeBlob?: boolean
    hasCredBlob?: boolean
    hasMinPinLength?: boolean
    hasPrf?: boolean
    automaticPresenceSimulation?: boolean
    isUserVerified?: boolean
    defaultBackupEligibility?: boolean
    defaultBackupState?: boolean
  }
  export type Credential = {
    credentialId: string
    isResidentCredential: boolean
    rpId?: string
    privateKey: string
    userHandle?: string
    signCount: number
    largeBlob?: string
    backupEligibility?: boolean
    backupState?: boolean
    userName?: string
    userDisplayName?: string
  }
  export interface AddVirtualAuthenticatorResult {
    authenticatorId: AuthenticatorId
  }
  export interface GetCredentialResult {
    credential: Credential
  }
  export interface GetCredentialsResult {
    credentials: Credential[]
  }
  export interface CredentialAddedEvent {
    authenticatorId: AuthenticatorId
    credential: Credential
  }
  export interface CredentialDeletedEvent {
    authenticatorId: AuthenticatorId
    credentialId: string
  }
  export interface CredentialUpdatedEvent {
    authenticatorId: AuthenticatorId
    credential: Credential
  }
  export interface CredentialAssertedEvent {
    authenticatorId: AuthenticatorId
    credential: Credential
  }
  export interface EventMap {
    credentialAdded: CredentialAddedEvent
    credentialDeleted: CredentialDeletedEvent
    credentialUpdated: CredentialUpdatedEvent
    credentialAsserted: CredentialAssertedEvent
  }
}
export namespace Media {
  export type PlayerId = string
  export type Timestamp = number
  export type PlayerMessage = { level: string; message: string }
  export type PlayerProperty = { name: string; value: string }
  export type PlayerEvent = { timestamp: Timestamp; value: string }
  export type PlayerErrorSourceLocation = { file: string; line: number }
  export type PlayerError = {
    errorType: string
    code: number
    stack: PlayerErrorSourceLocation[]
    cause: PlayerError[]
    data: Record<string, unknown>
  }
  export interface PlayerPropertiesChangedEvent {
    playerId: PlayerId
    properties: PlayerProperty[]
  }
  export interface PlayerEventsAddedEvent {
    playerId: PlayerId
    events: PlayerEvent[]
  }
  export interface PlayerMessagesLoggedEvent {
    playerId: PlayerId
    messages: PlayerMessage[]
  }
  export interface PlayerErrorsRaisedEvent {
    playerId: PlayerId
    errors: PlayerError[]
  }
  export interface PlayersCreatedEvent {
    players: PlayerId[]
  }
  export interface EventMap {
    playerPropertiesChanged: PlayerPropertiesChangedEvent
    playerEventsAdded: PlayerEventsAddedEvent
    playerMessagesLogged: PlayerMessagesLoggedEvent
    playerErrorsRaised: PlayerErrorsRaisedEvent
    playersCreated: PlayersCreatedEvent
  }
}
export namespace DeviceAccess {
  export type RequestId = string
  export type DeviceId = string
  export type PromptDevice = { id: DeviceId; name: string }
  export interface DeviceRequestPromptedEvent {
    id: RequestId
    devices: PromptDevice[]
  }
  export interface EventMap {
    deviceRequestPrompted: DeviceRequestPromptedEvent
  }
}
export namespace Preload {
  export type RuleSetId = string
  export type RuleSet = {
    id: RuleSetId
    loaderId: Network.LoaderId
    sourceText: string
    backendNodeId?: DOM.BackendNodeId
    url?: string
    requestId?: Network.RequestId
    errorType?: RuleSetErrorType
    errorMessage?: string
  }
  export type RuleSetErrorType = 'SourceIsNotJsonObject' | 'InvalidRulesSkipped'
  export type SpeculationAction = 'Prefetch' | 'Prerender'
  export type SpeculationTargetHint = 'Blank' | 'Self'
  export type PreloadingAttemptKey = {
    loaderId: Network.LoaderId
    action: SpeculationAction
    url: string
    targetHint?: SpeculationTargetHint
  }
  export type PreloadingAttemptSource = {
    key: PreloadingAttemptKey
    ruleSetIds: RuleSetId[]
    nodeIds: DOM.BackendNodeId[]
  }
  export type PreloadPipelineId = string
  export type PrerenderFinalStatus =
    | 'Activated'
    | 'Destroyed'
    | 'LowEndDevice'
    | 'InvalidSchemeRedirect'
    | 'InvalidSchemeNavigation'
    | 'NavigationRequestBlockedByCsp'
    | 'MojoBinderPolicy'
    | 'RendererProcessCrashed'
    | 'RendererProcessKilled'
    | 'Download'
    | 'TriggerDestroyed'
    | 'NavigationNotCommitted'
    | 'NavigationBadHttpStatus'
    | 'ClientCertRequested'
    | 'NavigationRequestNetworkError'
    | 'CancelAllHostsForTesting'
    | 'DidFailLoad'
    | 'Stop'
    | 'SslCertificateError'
    | 'LoginAuthRequested'
    | 'UaChangeRequiresReload'
    | 'BlockedByClient'
    | 'AudioOutputDeviceRequested'
    | 'MixedContent'
    | 'TriggerBackgrounded'
    | 'MemoryLimitExceeded'
    | 'DataSaverEnabled'
    | 'TriggerUrlHasEffectiveUrl'
    | 'ActivatedBeforeStarted'
    | 'InactivePageRestriction'
    | 'StartFailed'
    | 'TimeoutBackgrounded'
    | 'CrossSiteRedirectInInitialNavigation'
    | 'CrossSiteNavigationInInitialNavigation'
    | 'SameSiteCrossOriginRedirectNotOptInInInitialNavigation'
    | 'SameSiteCrossOriginNavigationNotOptInInInitialNavigation'
    | 'ActivationNavigationParameterMismatch'
    | 'ActivatedInBackground'
    | 'EmbedderHostDisallowed'
    | 'ActivationNavigationDestroyedBeforeSuccess'
    | 'TabClosedByUserGesture'
    | 'TabClosedWithoutUserGesture'
    | 'PrimaryMainFrameRendererProcessCrashed'
    | 'PrimaryMainFrameRendererProcessKilled'
    | 'ActivationFramePolicyNotCompatible'
    | 'PreloadingDisabled'
    | 'BatterySaverEnabled'
    | 'ActivatedDuringMainFrameNavigation'
    | 'PreloadingUnsupportedByWebContents'
    | 'CrossSiteRedirectInMainFrameNavigation'
    | 'CrossSiteNavigationInMainFrameNavigation'
    | 'SameSiteCrossOriginRedirectNotOptInInMainFrameNavigation'
    | 'SameSiteCrossOriginNavigationNotOptInInMainFrameNavigation'
    | 'MemoryPressureOnTrigger'
    | 'MemoryPressureAfterTriggered'
    | 'PrerenderingDisabledByDevTools'
    | 'SpeculationRuleRemoved'
    | 'ActivatedWithAuxiliaryBrowsingContexts'
    | 'MaxNumOfRunningEagerPrerendersExceeded'
    | 'MaxNumOfRunningNonEagerPrerendersExceeded'
    | 'MaxNumOfRunningEmbedderPrerendersExceeded'
    | 'PrerenderingUrlHasEffectiveUrl'
    | 'RedirectedPrerenderingUrlHasEffectiveUrl'
    | 'ActivationUrlHasEffectiveUrl'
    | 'JavaScriptInterfaceAdded'
    | 'JavaScriptInterfaceRemoved'
    | 'AllPrerenderingCanceled'
    | 'WindowClosed'
    | 'SlowNetwork'
    | 'OtherPrerenderedPageActivated'
    | 'V8OptimizerDisabled'
    | 'PrerenderFailedDuringPrefetch'
    | 'BrowsingDataRemoved'
  export type PreloadingStatus =
    | 'Pending'
    | 'Running'
    | 'Ready'
    | 'Success'
    | 'Failure'
    | 'NotSupported'
  export type PrefetchStatus =
    | 'PrefetchAllowed'
    | 'PrefetchFailedIneligibleRedirect'
    | 'PrefetchFailedInvalidRedirect'
    | 'PrefetchFailedMIMENotSupported'
    | 'PrefetchFailedNetError'
    | 'PrefetchFailedNon2XX'
    | 'PrefetchEvictedAfterBrowsingDataRemoved'
    | 'PrefetchEvictedAfterCandidateRemoved'
    | 'PrefetchEvictedForNewerPrefetch'
    | 'PrefetchHeldback'
    | 'PrefetchIneligibleRetryAfter'
    | 'PrefetchIsPrivacyDecoy'
    | 'PrefetchIsStale'
    | 'PrefetchNotEligibleBrowserContextOffTheRecord'
    | 'PrefetchNotEligibleDataSaverEnabled'
    | 'PrefetchNotEligibleExistingProxy'
    | 'PrefetchNotEligibleHostIsNonUnique'
    | 'PrefetchNotEligibleNonDefaultStoragePartition'
    | 'PrefetchNotEligibleSameSiteCrossOriginPrefetchRequiredProxy'
    | 'PrefetchNotEligibleSchemeIsNotHttps'
    | 'PrefetchNotEligibleUserHasCookies'
    | 'PrefetchNotEligibleUserHasServiceWorker'
    | 'PrefetchNotEligibleUserHasServiceWorkerNoFetchHandler'
    | 'PrefetchNotEligibleRedirectFromServiceWorker'
    | 'PrefetchNotEligibleRedirectToServiceWorker'
    | 'PrefetchNotEligibleBatterySaverEnabled'
    | 'PrefetchNotEligiblePreloadingDisabled'
    | 'PrefetchNotFinishedInTime'
    | 'PrefetchNotStarted'
    | 'PrefetchNotUsedCookiesChanged'
    | 'PrefetchProxyNotAvailable'
    | 'PrefetchResponseUsed'
    | 'PrefetchSuccessfulButNotUsed'
    | 'PrefetchNotUsedProbeFailed'
  export type PrerenderMismatchedHeaders = {
    headerName: string
    initialValue?: string
    activationValue?: string
  }
  export interface RuleSetUpdatedEvent {
    ruleSet: RuleSet
  }
  export interface RuleSetRemovedEvent {
    id: RuleSetId
  }
  export interface PreloadEnabledStateUpdatedEvent {
    disabledByPreference: boolean
    disabledByDataSaver: boolean
    disabledByBatterySaver: boolean
    disabledByHoldbackPrefetchSpeculationRules: boolean
    disabledByHoldbackPrerenderSpeculationRules: boolean
  }
  export interface PrefetchStatusUpdatedEvent {
    key: PreloadingAttemptKey
    pipelineId: PreloadPipelineId
    initiatingFrameId: Page.FrameId
    prefetchUrl: string
    status: PreloadingStatus
    prefetchStatus: PrefetchStatus
    requestId: Network.RequestId
  }
  export interface PrerenderStatusUpdatedEvent {
    key: PreloadingAttemptKey
    pipelineId: PreloadPipelineId
    status: PreloadingStatus
    prerenderStatus: PrerenderFinalStatus
    disallowedMojoInterface: string
    mismatchedHeaders: PrerenderMismatchedHeaders[]
  }
  export interface PreloadingAttemptSourcesUpdatedEvent {
    loaderId: Network.LoaderId
    preloadingAttemptSources: PreloadingAttemptSource[]
  }
  export interface EventMap {
    ruleSetUpdated: RuleSetUpdatedEvent
    ruleSetRemoved: RuleSetRemovedEvent
    preloadEnabledStateUpdated: PreloadEnabledStateUpdatedEvent
    prefetchStatusUpdated: PrefetchStatusUpdatedEvent
    prerenderStatusUpdated: PrerenderStatusUpdatedEvent
    preloadingAttemptSourcesUpdated: PreloadingAttemptSourcesUpdatedEvent
  }
}
export namespace FedCm {
  export type LoginState = 'SignIn' | 'SignUp'
  export type DialogType =
    | 'AccountChooser'
    | 'AutoReauthn'
    | 'ConfirmIdpLogin'
    | 'Error'
  export type DialogButton =
    | 'ConfirmIdpLoginContinue'
    | 'ErrorGotIt'
    | 'ErrorMoreDetails'
  export type AccountUrlType = 'TermsOfService' | 'PrivacyPolicy'
  export type Account = {
    accountId: string
    email: string
    name: string
    givenName: string
    pictureUrl: string
    idpConfigUrl: string
    idpLoginUrl: string
    loginState: LoginState
    termsOfServiceUrl?: string
    privacyPolicyUrl?: string
  }
  export interface DialogShownEvent {
    dialogId: string
    dialogType: DialogType
    accounts: Account[]
    title: string
    subtitle: string
  }
  export interface DialogClosedEvent {
    dialogId: string
  }
  export interface EventMap {
    dialogShown: DialogShownEvent
    dialogClosed: DialogClosedEvent
  }
}
export namespace PWA {
  export type FileHandlerAccept = {
    mediaType: string
    fileExtensions: string[]
  }
  export type FileHandler = {
    action: string
    accepts: FileHandlerAccept[]
    displayName: string
  }
  export type DisplayMode = 'standalone' | 'browser'
  export interface GetOsAppStateResult {
    badgeCount: number
    fileHandlers: FileHandler[]
  }
  export interface LaunchResult {
    targetId: Target.TargetID
  }
  export interface LaunchFilesInAppResult {
    targetIds: Target.TargetID[]
  }
}
export namespace BluetoothEmulation {
  export type CentralState = 'absent' | 'powered-off' | 'powered-on'
  export type GATTOperationType = 'connection' | 'discovery'
  export type CharacteristicWriteType =
    | 'write-default-deprecated'
    | 'write-with-response'
    | 'write-without-response'
  export type CharacteristicOperationType =
    | 'read'
    | 'write'
    | 'subscribe-to-notifications'
    | 'unsubscribe-from-notifications'
  export type DescriptorOperationType = 'read' | 'write'
  export type ManufacturerData = { key: number; data: string }
  export type ScanRecord = {
    name?: string
    uuids?: string[]
    appearance?: number
    txPower?: number
    manufacturerData?: ManufacturerData[]
  }
  export type ScanEntry = {
    deviceAddress: string
    rssi: number
    scanRecord: ScanRecord
  }
  export type CharacteristicProperties = {
    broadcast?: boolean
    read?: boolean
    writeWithoutResponse?: boolean
    write?: boolean
    notify?: boolean
    indicate?: boolean
    authenticatedSignedWrites?: boolean
    extendedProperties?: boolean
  }
  export interface AddServiceResult {
    serviceId: string
  }
  export interface AddCharacteristicResult {
    characteristicId: string
  }
  export interface AddDescriptorResult {
    descriptorId: string
  }
  export interface GattOperationReceivedEvent {
    address: string
    type: GATTOperationType
  }
  export interface CharacteristicOperationReceivedEvent {
    characteristicId: string
    type: CharacteristicOperationType
    data: string
    writeType: CharacteristicWriteType
  }
  export interface DescriptorOperationReceivedEvent {
    descriptorId: string
    type: DescriptorOperationType
    data: string
  }
  export interface EventMap {
    gattOperationReceived: GattOperationReceivedEvent
    characteristicOperationReceived: CharacteristicOperationReceivedEvent
    descriptorOperationReceived: DescriptorOperationReceivedEvent
  }
}
export namespace Console {
  export type ConsoleMessage = {
    source: string
    level: string
    text: string
    url?: string
    line?: number
    column?: number
  }
  export interface MessageAddedEvent {
    message: ConsoleMessage
  }
  export interface EventMap {
    messageAdded: MessageAddedEvent
  }
}
export namespace Debugger {
  export type BreakpointId = string
  export type CallFrameId = string
  export type Location = {
    scriptId: Runtime.ScriptId
    lineNumber: number
    columnNumber?: number
  }
  export type ScriptPosition = { lineNumber: number; columnNumber: number }
  export type LocationRange = {
    scriptId: Runtime.ScriptId
    start: ScriptPosition
    end: ScriptPosition
  }
  export type CallFrame = {
    callFrameId: CallFrameId
    functionName: string
    functionLocation?: Location
    location: Location
    url: string
    scopeChain: Scope[]
    this: Runtime.RemoteObject
    returnValue?: Runtime.RemoteObject
    canBeRestarted?: boolean
  }
  export type Scope = {
    type: string
    object: Runtime.RemoteObject
    name?: string
    startLocation?: Location
    endLocation?: Location
  }
  export type SearchMatch = { lineNumber: number; lineContent: string }
  export type BreakLocation = {
    scriptId: Runtime.ScriptId
    lineNumber: number
    columnNumber?: number
    type?: string
  }
  export type WasmDisassemblyChunk = {
    lines: string[]
    bytecodeOffsets: number[]
  }
  export type ScriptLanguage = 'JavaScript' | 'WebAssembly'
  export type DebugSymbols = { type: string; externalURL?: string }
  export type ResolvedBreakpoint = {
    breakpointId: BreakpointId
    location: Location
  }
  export interface EnableResult {
    debuggerId: Runtime.UniqueDebuggerId
  }
  export interface EvaluateOnCallFrameResult {
    result: Runtime.RemoteObject
    exceptionDetails: Runtime.ExceptionDetails
  }
  export interface GetPossibleBreakpointsResult {
    locations: BreakLocation[]
  }
  export interface GetScriptSourceResult {
    scriptSource: string
    bytecode: string
  }
  export interface DisassembleWasmModuleResult {
    streamId: string
    totalNumberOfLines: number
    functionBodyOffsets: number[]
    chunk: WasmDisassemblyChunk
  }
  export interface NextWasmDisassemblyChunkResult {
    chunk: WasmDisassemblyChunk
  }
  export interface GetWasmBytecodeResult {
    bytecode: string
  }
  export interface GetStackTraceResult {
    stackTrace: Runtime.StackTrace
  }
  export interface RestartFrameResult {
    callFrames: CallFrame[]
    asyncStackTrace: Runtime.StackTrace
    asyncStackTraceId: Runtime.StackTraceId
  }
  export interface SearchInContentResult {
    result: SearchMatch[]
  }
  export interface SetBreakpointResult {
    breakpointId: BreakpointId
    actualLocation: Location
  }
  export interface SetInstrumentationBreakpointResult {
    breakpointId: BreakpointId
  }
  export interface SetBreakpointByUrlResult {
    breakpointId: BreakpointId
    locations: Location[]
  }
  export interface SetBreakpointOnFunctionCallResult {
    breakpointId: BreakpointId
  }
  export interface SetScriptSourceResult {
    callFrames: CallFrame[]
    stackChanged: boolean
    asyncStackTrace: Runtime.StackTrace
    asyncStackTraceId: Runtime.StackTraceId
    status: string
    exceptionDetails: Runtime.ExceptionDetails
  }
  export interface BreakpointResolvedEvent {
    breakpointId: BreakpointId
    location: Location
  }
  export interface PausedEvent {
    callFrames: CallFrame[]
    reason: string
    data: Record<string, unknown>
    hitBreakpoints: string[]
    asyncStackTrace: Runtime.StackTrace
    asyncStackTraceId: Runtime.StackTraceId
    asyncCallStackTraceId: Runtime.StackTraceId
  }
  export interface ResumedEvent {}
  export interface ScriptFailedToParseEvent {
    scriptId: Runtime.ScriptId
    url: string
    startLine: number
    startColumn: number
    endLine: number
    endColumn: number
    executionContextId: Runtime.ExecutionContextId
    hash: string
    buildId: string
    executionContextAuxData: Record<string, unknown>
    sourceMapURL: string
    hasSourceURL: boolean
    isModule: boolean
    length: number
    stackTrace: Runtime.StackTrace
    codeOffset: number
    scriptLanguage: Debugger.ScriptLanguage
    embedderName: string
  }
  export interface ScriptParsedEvent {
    scriptId: Runtime.ScriptId
    url: string
    startLine: number
    startColumn: number
    endLine: number
    endColumn: number
    executionContextId: Runtime.ExecutionContextId
    hash: string
    buildId: string
    executionContextAuxData: Record<string, unknown>
    isLiveEdit: boolean
    sourceMapURL: string
    hasSourceURL: boolean
    isModule: boolean
    length: number
    stackTrace: Runtime.StackTrace
    codeOffset: number
    scriptLanguage: Debugger.ScriptLanguage
    debugSymbols: Debugger.DebugSymbols[]
    embedderName: string
    resolvedBreakpoints: ResolvedBreakpoint[]
  }
  export interface EventMap {
    breakpointResolved: BreakpointResolvedEvent
    paused: PausedEvent
    resumed: ResumedEvent
    scriptFailedToParse: ScriptFailedToParseEvent
    scriptParsed: ScriptParsedEvent
  }
}
export namespace HeapProfiler {
  export type HeapSnapshotObjectId = string
  export type SamplingHeapProfileNode = {
    callFrame: Runtime.CallFrame
    selfSize: number
    id: number
    children: SamplingHeapProfileNode[]
  }
  export type SamplingHeapProfileSample = {
    size: number
    nodeId: number
    ordinal: number
  }
  export type SamplingHeapProfile = {
    head: SamplingHeapProfileNode
    samples: SamplingHeapProfileSample[]
  }
  export interface GetHeapObjectIdResult {
    heapSnapshotObjectId: HeapSnapshotObjectId
  }
  export interface GetObjectByHeapObjectIdResult {
    result: Runtime.RemoteObject
  }
  export interface GetSamplingProfileResult {
    profile: SamplingHeapProfile
  }
  export interface StopSamplingResult {
    profile: SamplingHeapProfile
  }
  export interface AddHeapSnapshotChunkEvent {
    chunk: string
  }
  export interface HeapStatsUpdateEvent {
    statsUpdate: number[]
  }
  export interface LastSeenObjectIdEvent {
    lastSeenObjectId: number
    timestamp: number
  }
  export interface ReportHeapSnapshotProgressEvent {
    done: number
    total: number
    finished: boolean
  }
  export interface ResetProfilesEvent {}
  export interface EventMap {
    addHeapSnapshotChunk: AddHeapSnapshotChunkEvent
    heapStatsUpdate: HeapStatsUpdateEvent
    lastSeenObjectId: LastSeenObjectIdEvent
    reportHeapSnapshotProgress: ReportHeapSnapshotProgressEvent
    resetProfiles: ResetProfilesEvent
  }
}
export namespace Profiler {
  export type ProfileNode = {
    id: number
    callFrame: Runtime.CallFrame
    hitCount?: number
    children?: number[]
    deoptReason?: string
    positionTicks?: PositionTickInfo[]
  }
  export type Profile = {
    nodes: ProfileNode[]
    startTime: number
    endTime: number
    samples?: number[]
    timeDeltas?: number[]
  }
  export type PositionTickInfo = { line: number; ticks: number }
  export type CoverageRange = {
    startOffset: number
    endOffset: number
    count: number
  }
  export type FunctionCoverage = {
    functionName: string
    ranges: CoverageRange[]
    isBlockCoverage: boolean
  }
  export type ScriptCoverage = {
    scriptId: Runtime.ScriptId
    url: string
    functions: FunctionCoverage[]
  }
  export interface GetBestEffortCoverageResult {
    result: ScriptCoverage[]
  }
  export interface StartPreciseCoverageResult {
    timestamp: number
  }
  export interface StopResult {
    profile: Profile
  }
  export interface TakePreciseCoverageResult {
    result: ScriptCoverage[]
    timestamp: number
  }
  export interface ConsoleProfileFinishedEvent {
    id: string
    location: Debugger.Location
    profile: Profile
    title: string
  }
  export interface ConsoleProfileStartedEvent {
    id: string
    location: Debugger.Location
    title: string
  }
  export interface PreciseCoverageDeltaUpdateEvent {
    timestamp: number
    occasion: string
    result: ScriptCoverage[]
  }
  export interface EventMap {
    consoleProfileFinished: ConsoleProfileFinishedEvent
    consoleProfileStarted: ConsoleProfileStartedEvent
    preciseCoverageDeltaUpdate: PreciseCoverageDeltaUpdateEvent
  }
}
export namespace Runtime {
  export type ScriptId = string
  export type SerializationOptions = {
    serialization: string
    maxDepth?: number
    additionalParameters?: Record<string, unknown>
  }
  export type DeepSerializedValue = {
    type: string
    value?: unknown
    objectId?: string
    weakLocalObjectReference?: number
  }
  export type RemoteObjectId = string
  export type UnserializableValue = string
  export type RemoteObject = {
    type: string
    subtype?: string
    className?: string
    value?: unknown
    unserializableValue?: UnserializableValue
    description?: string
    deepSerializedValue?: DeepSerializedValue
    objectId?: RemoteObjectId
    preview?: ObjectPreview
    customPreview?: CustomPreview
  }
  export type CustomPreview = { header: string; bodyGetterId?: RemoteObjectId }
  export type ObjectPreview = {
    type: string
    subtype?: string
    description?: string
    overflow: boolean
    properties: PropertyPreview[]
    entries?: EntryPreview[]
  }
  export type PropertyPreview = {
    name: string
    type: string
    value?: string
    valuePreview?: ObjectPreview
    subtype?: string
  }
  export type EntryPreview = { key?: ObjectPreview; value: ObjectPreview }
  export type PropertyDescriptor = {
    name: string
    value?: RemoteObject
    writable?: boolean
    get?: RemoteObject
    set?: RemoteObject
    configurable: boolean
    enumerable: boolean
    wasThrown?: boolean
    isOwn?: boolean
    symbol?: RemoteObject
  }
  export type InternalPropertyDescriptor = {
    name: string
    value?: RemoteObject
  }
  export type PrivatePropertyDescriptor = {
    name: string
    value?: RemoteObject
    get?: RemoteObject
    set?: RemoteObject
  }
  export type CallArgument = {
    value?: unknown
    unserializableValue?: UnserializableValue
    objectId?: RemoteObjectId
  }
  export type ExecutionContextId = number
  export type ExecutionContextDescription = {
    id: ExecutionContextId
    origin: string
    name: string
    uniqueId: string
    auxData?: Record<string, unknown>
  }
  export type ExceptionDetails = {
    exceptionId: number
    text: string
    lineNumber: number
    columnNumber: number
    scriptId?: ScriptId
    url?: string
    stackTrace?: StackTrace
    exception?: RemoteObject
    executionContextId?: ExecutionContextId
    exceptionMetaData?: Record<string, unknown>
  }
  export type Timestamp = number
  export type TimeDelta = number
  export type CallFrame = {
    functionName: string
    scriptId: ScriptId
    url: string
    lineNumber: number
    columnNumber: number
  }
  export type StackTrace = {
    description?: string
    callFrames: CallFrame[]
    parent?: StackTrace
    parentId?: StackTraceId
  }
  export type UniqueDebuggerId = string
  export type StackTraceId = { id: string; debuggerId?: UniqueDebuggerId }
  export interface AwaitPromiseResult {
    result: RemoteObject
    exceptionDetails: ExceptionDetails
  }
  export interface CallFunctionOnResult {
    result: RemoteObject
    exceptionDetails: ExceptionDetails
  }
  export interface CompileScriptResult {
    scriptId: ScriptId
    exceptionDetails: ExceptionDetails
  }
  export interface EvaluateResult {
    result: RemoteObject
    exceptionDetails: ExceptionDetails
  }
  export interface GetIsolateIdResult {
    id: string
  }
  export interface GetHeapUsageResult {
    usedSize: number
    totalSize: number
    embedderHeapUsedSize: number
    backingStorageSize: number
  }
  export interface GetPropertiesResult {
    result: PropertyDescriptor[]
    internalProperties: InternalPropertyDescriptor[]
    privateProperties: PrivatePropertyDescriptor[]
    exceptionDetails: ExceptionDetails
  }
  export interface GlobalLexicalScopeNamesResult {
    names: string[]
  }
  export interface QueryObjectsResult {
    objects: RemoteObject
  }
  export interface RunScriptResult {
    result: RemoteObject
    exceptionDetails: ExceptionDetails
  }
  export interface GetExceptionDetailsResult {
    exceptionDetails: ExceptionDetails
  }
  export interface BindingCalledEvent {
    name: string
    payload: string
    executionContextId: ExecutionContextId
  }
  export interface ConsoleAPICalledEvent {
    type: string
    args: RemoteObject[]
    executionContextId: ExecutionContextId
    timestamp: Timestamp
    stackTrace: StackTrace
    context: string
  }
  export interface ExceptionRevokedEvent {
    reason: string
    exceptionId: number
  }
  export interface ExceptionThrownEvent {
    timestamp: Timestamp
    exceptionDetails: ExceptionDetails
  }
  export interface ExecutionContextCreatedEvent {
    context: ExecutionContextDescription
  }
  export interface ExecutionContextDestroyedEvent {
    executionContextId: ExecutionContextId
    executionContextUniqueId: string
  }
  export interface ExecutionContextsClearedEvent {}
  export interface InspectRequestedEvent {
    object: RemoteObject
    hints: Record<string, unknown>
    executionContextId: ExecutionContextId
  }
  export interface EventMap {
    bindingCalled: BindingCalledEvent
    consoleAPICalled: ConsoleAPICalledEvent
    exceptionRevoked: ExceptionRevokedEvent
    exceptionThrown: ExceptionThrownEvent
    executionContextCreated: ExecutionContextCreatedEvent
    executionContextDestroyed: ExecutionContextDestroyedEvent
    executionContextsCleared: ExecutionContextsClearedEvent
    inspectRequested: InspectRequestedEvent
  }
}
export namespace Schema {
  export type Domain = { name: string; version: string }
  export interface GetDomainsResult {
    domains: Domain[]
  }
}
class AccessibilityClient {
  private transport: Transport
  private sessionId: Target.SessionID | undefined
  private listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  async disable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Accessibility.disable',
      params: {},
    })
  }
  async enable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Accessibility.enable',
      params: {},
    })
  }
  async getPartialAXTree(
    nodeId?: DOM.NodeId,
    backendNodeId?: DOM.BackendNodeId,
    objectId?: Runtime.RemoteObjectId,
    fetchRelatives?: boolean
  ): Promise<Accessibility.GetPartialAXTreeResult> {
    return this.transport.call<Accessibility.GetPartialAXTreeResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Accessibility.getPartialAXTree',
      params: {
        nodeId: nodeId,
        backendNodeId: backendNodeId,
        objectId: objectId,
        fetchRelatives: fetchRelatives,
      },
    })
  }
  async getFullAXTree(
    depth?: number,
    frameId?: Page.FrameId
  ): Promise<Accessibility.GetFullAXTreeResult> {
    return this.transport.call<Accessibility.GetFullAXTreeResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Accessibility.getFullAXTree',
      params: { depth: depth, frameId: frameId },
    })
  }
  async getRootAXNode(
    frameId?: Page.FrameId
  ): Promise<Accessibility.GetRootAXNodeResult> {
    return this.transport.call<Accessibility.GetRootAXNodeResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Accessibility.getRootAXNode',
      params: { frameId: frameId },
    })
  }
  async getAXNodeAndAncestors(
    nodeId?: DOM.NodeId,
    backendNodeId?: DOM.BackendNodeId,
    objectId?: Runtime.RemoteObjectId
  ): Promise<Accessibility.GetAXNodeAndAncestorsResult> {
    return this.transport.call<Accessibility.GetAXNodeAndAncestorsResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Accessibility.getAXNodeAndAncestors',
      params: {
        nodeId: nodeId,
        backendNodeId: backendNodeId,
        objectId: objectId,
      },
    })
  }
  async getChildAXNodes(
    id: Accessibility.AXNodeId,
    frameId?: Page.FrameId
  ): Promise<Accessibility.GetChildAXNodesResult> {
    return this.transport.call<Accessibility.GetChildAXNodesResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Accessibility.getChildAXNodes',
      params: { id: id, frameId: frameId },
    })
  }
  async queryAXTree(
    nodeId?: DOM.NodeId,
    backendNodeId?: DOM.BackendNodeId,
    objectId?: Runtime.RemoteObjectId,
    accessibleName?: string,
    role?: string
  ): Promise<Accessibility.QueryAXTreeResult> {
    return this.transport.call<Accessibility.QueryAXTreeResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Accessibility.queryAXTree',
      params: {
        nodeId: nodeId,
        backendNodeId: backendNodeId,
        objectId: objectId,
        accessibleName: accessibleName,
        role: role,
      },
    })
  }
  on<K extends keyof Accessibility.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Accessibility.EventMap[K]>) => void
  ): () => void {
    const filteredListener: typeof listener = (event) => {
      if (event.sessionId !== this.sessionId) {
        return
      }
      listener(event)
    }
    this.listeners.set(
      listener as ChromeEventListener,
      filteredListener as ChromeEventListener
    )
    return this.transport.on(name, filteredListener as ChromeEventListener)
  }
  off<K extends keyof Accessibility.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Accessibility.EventMap[K]>) => void
  ): void {
    const filteredListener = this.listeners.get(listener as ChromeEventListener)
    if (filteredListener === undefined) {
      return
    }
    this.listeners.delete(listener as ChromeEventListener)
    return this.transport.off(name, filteredListener)
  }
}
class AnimationClient {
  private transport: Transport
  private sessionId: Target.SessionID | undefined
  private listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  async disable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Animation.disable',
      params: {},
    })
  }
  async enable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Animation.enable',
      params: {},
    })
  }
  async getCurrentTime(id: string): Promise<Animation.GetCurrentTimeResult> {
    return this.transport.call<Animation.GetCurrentTimeResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Animation.getCurrentTime',
      params: { id: id },
    })
  }
  async getPlaybackRate(): Promise<Animation.GetPlaybackRateResult> {
    return this.transport.call<Animation.GetPlaybackRateResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Animation.getPlaybackRate',
      params: {},
    })
  }
  async releaseAnimations(animations: string[]): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Animation.releaseAnimations',
      params: { animations: animations },
    })
  }
  async resolveAnimation(
    animationId: string
  ): Promise<Animation.ResolveAnimationResult> {
    return this.transport.call<Animation.ResolveAnimationResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Animation.resolveAnimation',
      params: { animationId: animationId },
    })
  }
  async seekAnimations(
    animations: string[],
    currentTime: number
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Animation.seekAnimations',
      params: { animations: animations, currentTime: currentTime },
    })
  }
  async setPaused(animations: string[], paused: boolean): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Animation.setPaused',
      params: { animations: animations, paused: paused },
    })
  }
  async setPlaybackRate(playbackRate: number): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Animation.setPlaybackRate',
      params: { playbackRate: playbackRate },
    })
  }
  async setTiming(
    animationId: string,
    duration: number,
    delay: number
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Animation.setTiming',
      params: { animationId: animationId, duration: duration, delay: delay },
    })
  }
  on<K extends keyof Animation.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Animation.EventMap[K]>) => void
  ): () => void {
    const filteredListener: typeof listener = (event) => {
      if (event.sessionId !== this.sessionId) {
        return
      }
      listener(event)
    }
    this.listeners.set(
      listener as ChromeEventListener,
      filteredListener as ChromeEventListener
    )
    return this.transport.on(name, filteredListener as ChromeEventListener)
  }
  off<K extends keyof Animation.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Animation.EventMap[K]>) => void
  ): void {
    const filteredListener = this.listeners.get(listener as ChromeEventListener)
    if (filteredListener === undefined) {
      return
    }
    this.listeners.delete(listener as ChromeEventListener)
    return this.transport.off(name, filteredListener)
  }
}
class AuditsClient {
  private transport: Transport
  private sessionId: Target.SessionID | undefined
  private listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  async getEncodedResponse(
    requestId: Network.RequestId,
    encoding: string,
    quality?: number,
    sizeOnly?: boolean
  ): Promise<Audits.GetEncodedResponseResult> {
    return this.transport.call<Audits.GetEncodedResponseResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Audits.getEncodedResponse',
      params: {
        requestId: requestId,
        encoding: encoding,
        quality: quality,
        sizeOnly: sizeOnly,
      },
    })
  }
  async disable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Audits.disable',
      params: {},
    })
  }
  async enable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Audits.enable',
      params: {},
    })
  }
  async checkContrast(reportAAA?: boolean): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Audits.checkContrast',
      params: { reportAAA: reportAAA },
    })
  }
  async checkFormsIssues(): Promise<Audits.CheckFormsIssuesResult> {
    return this.transport.call<Audits.CheckFormsIssuesResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Audits.checkFormsIssues',
      params: {},
    })
  }
  on<K extends keyof Audits.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Audits.EventMap[K]>) => void
  ): () => void {
    const filteredListener: typeof listener = (event) => {
      if (event.sessionId !== this.sessionId) {
        return
      }
      listener(event)
    }
    this.listeners.set(
      listener as ChromeEventListener,
      filteredListener as ChromeEventListener
    )
    return this.transport.on(name, filteredListener as ChromeEventListener)
  }
  off<K extends keyof Audits.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Audits.EventMap[K]>) => void
  ): void {
    const filteredListener = this.listeners.get(listener as ChromeEventListener)
    if (filteredListener === undefined) {
      return
    }
    this.listeners.delete(listener as ChromeEventListener)
    return this.transport.off(name, filteredListener)
  }
}
class ExtensionsClient {
  private transport: Transport
  private sessionId: Target.SessionID | undefined
  private listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  async loadUnpacked(path: string): Promise<Extensions.LoadUnpackedResult> {
    return this.transport.call<Extensions.LoadUnpackedResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Extensions.loadUnpacked',
      params: { path: path },
    })
  }
  async uninstall(id: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Extensions.uninstall',
      params: { id: id },
    })
  }
  async getStorageItems(
    id: string,
    storageArea: Extensions.StorageArea,
    keys?: string[]
  ): Promise<Extensions.GetStorageItemsResult> {
    return this.transport.call<Extensions.GetStorageItemsResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Extensions.getStorageItems',
      params: { id: id, storageArea: storageArea, keys: keys },
    })
  }
  async removeStorageItems(
    id: string,
    storageArea: Extensions.StorageArea,
    keys: string[]
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Extensions.removeStorageItems',
      params: { id: id, storageArea: storageArea, keys: keys },
    })
  }
  async clearStorageItems(
    id: string,
    storageArea: Extensions.StorageArea
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Extensions.clearStorageItems',
      params: { id: id, storageArea: storageArea },
    })
  }
  async setStorageItems(
    id: string,
    storageArea: Extensions.StorageArea,
    values: Record<string, unknown>
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Extensions.setStorageItems',
      params: { id: id, storageArea: storageArea, values: values },
    })
  }
}
class AutofillClient {
  private transport: Transport
  private sessionId: Target.SessionID | undefined
  private listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  async trigger(
    fieldId: DOM.BackendNodeId,
    card: Autofill.CreditCard,
    frameId?: Page.FrameId
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Autofill.trigger',
      params: { fieldId: fieldId, frameId: frameId, card: card },
    })
  }
  async setAddresses(addresses: Autofill.Address[]): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Autofill.setAddresses',
      params: { addresses: addresses },
    })
  }
  async disable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Autofill.disable',
      params: {},
    })
  }
  async enable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Autofill.enable',
      params: {},
    })
  }
  on<K extends keyof Autofill.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Autofill.EventMap[K]>) => void
  ): () => void {
    const filteredListener: typeof listener = (event) => {
      if (event.sessionId !== this.sessionId) {
        return
      }
      listener(event)
    }
    this.listeners.set(
      listener as ChromeEventListener,
      filteredListener as ChromeEventListener
    )
    return this.transport.on(name, filteredListener as ChromeEventListener)
  }
  off<K extends keyof Autofill.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Autofill.EventMap[K]>) => void
  ): void {
    const filteredListener = this.listeners.get(listener as ChromeEventListener)
    if (filteredListener === undefined) {
      return
    }
    this.listeners.delete(listener as ChromeEventListener)
    return this.transport.off(name, filteredListener)
  }
}
class BackgroundServiceClient {
  private transport: Transport
  private sessionId: Target.SessionID | undefined
  private listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  async startObserving(service: BackgroundService.ServiceName): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'BackgroundService.startObserving',
      params: { service: service },
    })
  }
  async stopObserving(service: BackgroundService.ServiceName): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'BackgroundService.stopObserving',
      params: { service: service },
    })
  }
  async setRecording(
    shouldRecord: boolean,
    service: BackgroundService.ServiceName
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'BackgroundService.setRecording',
      params: { shouldRecord: shouldRecord, service: service },
    })
  }
  async clearEvents(service: BackgroundService.ServiceName): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'BackgroundService.clearEvents',
      params: { service: service },
    })
  }
  on<K extends keyof BackgroundService.EventMap>(
    name: K,
    listener: (event: ChromeEvent<BackgroundService.EventMap[K]>) => void
  ): () => void {
    const filteredListener: typeof listener = (event) => {
      if (event.sessionId !== this.sessionId) {
        return
      }
      listener(event)
    }
    this.listeners.set(
      listener as ChromeEventListener,
      filteredListener as ChromeEventListener
    )
    return this.transport.on(name, filteredListener as ChromeEventListener)
  }
  off<K extends keyof BackgroundService.EventMap>(
    name: K,
    listener: (event: ChromeEvent<BackgroundService.EventMap[K]>) => void
  ): void {
    const filteredListener = this.listeners.get(listener as ChromeEventListener)
    if (filteredListener === undefined) {
      return
    }
    this.listeners.delete(listener as ChromeEventListener)
    return this.transport.off(name, filteredListener)
  }
}
class BrowserClient {
  private transport: Transport
  private sessionId: Target.SessionID | undefined
  private listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  async setPermission(
    permission: Browser.PermissionDescriptor,
    setting: Browser.PermissionSetting,
    origin?: string,
    browserContextId?: Browser.BrowserContextID
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Browser.setPermission',
      params: {
        permission: permission,
        setting: setting,
        origin: origin,
        browserContextId: browserContextId,
      },
    })
  }
  async grantPermissions(
    permissions: Browser.PermissionType[],
    origin?: string,
    browserContextId?: Browser.BrowserContextID
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Browser.grantPermissions',
      params: {
        permissions: permissions,
        origin: origin,
        browserContextId: browserContextId,
      },
    })
  }
  async resetPermissions(
    browserContextId?: Browser.BrowserContextID
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Browser.resetPermissions',
      params: { browserContextId: browserContextId },
    })
  }
  async setDownloadBehavior(
    behavior: string,
    browserContextId?: Browser.BrowserContextID,
    downloadPath?: string,
    eventsEnabled?: boolean
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Browser.setDownloadBehavior',
      params: {
        behavior: behavior,
        browserContextId: browserContextId,
        downloadPath: downloadPath,
        eventsEnabled: eventsEnabled,
      },
    })
  }
  async cancelDownload(
    guid: string,
    browserContextId?: Browser.BrowserContextID
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Browser.cancelDownload',
      params: { guid: guid, browserContextId: browserContextId },
    })
  }
  async close(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Browser.close',
      params: {},
    })
  }
  async crash(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Browser.crash',
      params: {},
    })
  }
  async crashGpuProcess(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Browser.crashGpuProcess',
      params: {},
    })
  }
  async getVersion(): Promise<Browser.GetVersionResult> {
    return this.transport.call<Browser.GetVersionResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Browser.getVersion',
      params: {},
    })
  }
  async getBrowserCommandLine(): Promise<Browser.GetBrowserCommandLineResult> {
    return this.transport.call<Browser.GetBrowserCommandLineResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Browser.getBrowserCommandLine',
      params: {},
    })
  }
  async getHistograms(
    query?: string,
    delta?: boolean
  ): Promise<Browser.GetHistogramsResult> {
    return this.transport.call<Browser.GetHistogramsResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Browser.getHistograms',
      params: { query: query, delta: delta },
    })
  }
  async getHistogram(
    name: string,
    delta?: boolean
  ): Promise<Browser.GetHistogramResult> {
    return this.transport.call<Browser.GetHistogramResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Browser.getHistogram',
      params: { name: name, delta: delta },
    })
  }
  async getWindowBounds(
    windowId: Browser.WindowID
  ): Promise<Browser.GetWindowBoundsResult> {
    return this.transport.call<Browser.GetWindowBoundsResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Browser.getWindowBounds',
      params: { windowId: windowId },
    })
  }
  async getWindowForTarget(
    targetId?: Target.TargetID
  ): Promise<Browser.GetWindowForTargetResult> {
    return this.transport.call<Browser.GetWindowForTargetResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Browser.getWindowForTarget',
      params: { targetId: targetId },
    })
  }
  async setWindowBounds(
    windowId: Browser.WindowID,
    bounds: Browser.Bounds
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Browser.setWindowBounds',
      params: { windowId: windowId, bounds: bounds },
    })
  }
  async setDockTile(badgeLabel?: string, image?: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Browser.setDockTile',
      params: { badgeLabel: badgeLabel, image: image },
    })
  }
  async executeBrowserCommand(
    commandId: Browser.BrowserCommandId
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Browser.executeBrowserCommand',
      params: { commandId: commandId },
    })
  }
  async addPrivacySandboxEnrollmentOverride(url: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Browser.addPrivacySandboxEnrollmentOverride',
      params: { url: url },
    })
  }
  async addPrivacySandboxCoordinatorKeyConfig(
    api: Browser.PrivacySandboxAPI,
    coordinatorOrigin: string,
    keyConfig: string,
    browserContextId?: Browser.BrowserContextID
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Browser.addPrivacySandboxCoordinatorKeyConfig',
      params: {
        api: api,
        coordinatorOrigin: coordinatorOrigin,
        keyConfig: keyConfig,
        browserContextId: browserContextId,
      },
    })
  }
  on<K extends keyof Browser.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Browser.EventMap[K]>) => void
  ): () => void {
    const filteredListener: typeof listener = (event) => {
      if (event.sessionId !== this.sessionId) {
        return
      }
      listener(event)
    }
    this.listeners.set(
      listener as ChromeEventListener,
      filteredListener as ChromeEventListener
    )
    return this.transport.on(name, filteredListener as ChromeEventListener)
  }
  off<K extends keyof Browser.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Browser.EventMap[K]>) => void
  ): void {
    const filteredListener = this.listeners.get(listener as ChromeEventListener)
    if (filteredListener === undefined) {
      return
    }
    this.listeners.delete(listener as ChromeEventListener)
    return this.transport.off(name, filteredListener)
  }
}
class CSSClient {
  private transport: Transport
  private sessionId: Target.SessionID | undefined
  private listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  async addRule(
    styleSheetId: CSS.StyleSheetId,
    ruleText: string,
    location: CSS.SourceRange,
    nodeForPropertySyntaxValidation?: DOM.NodeId
  ): Promise<CSS.AddRuleResult> {
    return this.transport.call<CSS.AddRuleResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'CSS.addRule',
      params: {
        styleSheetId: styleSheetId,
        ruleText: ruleText,
        location: location,
        nodeForPropertySyntaxValidation: nodeForPropertySyntaxValidation,
      },
    })
  }
  async collectClassNames(
    styleSheetId: CSS.StyleSheetId
  ): Promise<CSS.CollectClassNamesResult> {
    return this.transport.call<CSS.CollectClassNamesResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'CSS.collectClassNames',
      params: { styleSheetId: styleSheetId },
    })
  }
  async createStyleSheet(
    frameId: Page.FrameId,
    force?: boolean
  ): Promise<CSS.CreateStyleSheetResult> {
    return this.transport.call<CSS.CreateStyleSheetResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'CSS.createStyleSheet',
      params: { frameId: frameId, force: force },
    })
  }
  async disable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'CSS.disable',
      params: {},
    })
  }
  async enable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'CSS.enable',
      params: {},
    })
  }
  async forcePseudoState(
    nodeId: DOM.NodeId,
    forcedPseudoClasses: string[]
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'CSS.forcePseudoState',
      params: { nodeId: nodeId, forcedPseudoClasses: forcedPseudoClasses },
    })
  }
  async forceStartingStyle(nodeId: DOM.NodeId, forced: boolean): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'CSS.forceStartingStyle',
      params: { nodeId: nodeId, forced: forced },
    })
  }
  async getBackgroundColors(
    nodeId: DOM.NodeId
  ): Promise<CSS.GetBackgroundColorsResult> {
    return this.transport.call<CSS.GetBackgroundColorsResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'CSS.getBackgroundColors',
      params: { nodeId: nodeId },
    })
  }
  async getComputedStyleForNode(
    nodeId: DOM.NodeId
  ): Promise<CSS.GetComputedStyleForNodeResult> {
    return this.transport.call<CSS.GetComputedStyleForNodeResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'CSS.getComputedStyleForNode',
      params: { nodeId: nodeId },
    })
  }
  async resolveValues(
    values: string[],
    nodeId: DOM.NodeId,
    propertyName?: string,
    pseudoType?: DOM.PseudoType,
    pseudoIdentifier?: string
  ): Promise<CSS.ResolveValuesResult> {
    return this.transport.call<CSS.ResolveValuesResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'CSS.resolveValues',
      params: {
        values: values,
        nodeId: nodeId,
        propertyName: propertyName,
        pseudoType: pseudoType,
        pseudoIdentifier: pseudoIdentifier,
      },
    })
  }
  async getLonghandProperties(
    shorthandName: string,
    value: string
  ): Promise<CSS.GetLonghandPropertiesResult> {
    return this.transport.call<CSS.GetLonghandPropertiesResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'CSS.getLonghandProperties',
      params: { shorthandName: shorthandName, value: value },
    })
  }
  async getInlineStylesForNode(
    nodeId: DOM.NodeId
  ): Promise<CSS.GetInlineStylesForNodeResult> {
    return this.transport.call<CSS.GetInlineStylesForNodeResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'CSS.getInlineStylesForNode',
      params: { nodeId: nodeId },
    })
  }
  async getAnimatedStylesForNode(
    nodeId: DOM.NodeId
  ): Promise<CSS.GetAnimatedStylesForNodeResult> {
    return this.transport.call<CSS.GetAnimatedStylesForNodeResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'CSS.getAnimatedStylesForNode',
      params: { nodeId: nodeId },
    })
  }
  async getMatchedStylesForNode(
    nodeId: DOM.NodeId
  ): Promise<CSS.GetMatchedStylesForNodeResult> {
    return this.transport.call<CSS.GetMatchedStylesForNodeResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'CSS.getMatchedStylesForNode',
      params: { nodeId: nodeId },
    })
  }
  async getMediaQueries(): Promise<CSS.GetMediaQueriesResult> {
    return this.transport.call<CSS.GetMediaQueriesResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'CSS.getMediaQueries',
      params: {},
    })
  }
  async getPlatformFontsForNode(
    nodeId: DOM.NodeId
  ): Promise<CSS.GetPlatformFontsForNodeResult> {
    return this.transport.call<CSS.GetPlatformFontsForNodeResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'CSS.getPlatformFontsForNode',
      params: { nodeId: nodeId },
    })
  }
  async getStyleSheetText(
    styleSheetId: CSS.StyleSheetId
  ): Promise<CSS.GetStyleSheetTextResult> {
    return this.transport.call<CSS.GetStyleSheetTextResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'CSS.getStyleSheetText',
      params: { styleSheetId: styleSheetId },
    })
  }
  async getLayersForNode(
    nodeId: DOM.NodeId
  ): Promise<CSS.GetLayersForNodeResult> {
    return this.transport.call<CSS.GetLayersForNodeResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'CSS.getLayersForNode',
      params: { nodeId: nodeId },
    })
  }
  async getLocationForSelector(
    styleSheetId: CSS.StyleSheetId,
    selectorText: string
  ): Promise<CSS.GetLocationForSelectorResult> {
    return this.transport.call<CSS.GetLocationForSelectorResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'CSS.getLocationForSelector',
      params: { styleSheetId: styleSheetId, selectorText: selectorText },
    })
  }
  async trackComputedStyleUpdatesForNode(nodeId?: DOM.NodeId): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'CSS.trackComputedStyleUpdatesForNode',
      params: { nodeId: nodeId },
    })
  }
  async trackComputedStyleUpdates(
    propertiesToTrack: CSS.CSSComputedStyleProperty[]
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'CSS.trackComputedStyleUpdates',
      params: { propertiesToTrack: propertiesToTrack },
    })
  }
  async takeComputedStyleUpdates(): Promise<CSS.TakeComputedStyleUpdatesResult> {
    return this.transport.call<CSS.TakeComputedStyleUpdatesResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'CSS.takeComputedStyleUpdates',
      params: {},
    })
  }
  async setEffectivePropertyValueForNode(
    nodeId: DOM.NodeId,
    propertyName: string,
    value: string
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'CSS.setEffectivePropertyValueForNode',
      params: { nodeId: nodeId, propertyName: propertyName, value: value },
    })
  }
  async setPropertyRulePropertyName(
    styleSheetId: CSS.StyleSheetId,
    range: CSS.SourceRange,
    propertyName: string
  ): Promise<CSS.SetPropertyRulePropertyNameResult> {
    return this.transport.call<CSS.SetPropertyRulePropertyNameResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'CSS.setPropertyRulePropertyName',
      params: {
        styleSheetId: styleSheetId,
        range: range,
        propertyName: propertyName,
      },
    })
  }
  async setKeyframeKey(
    styleSheetId: CSS.StyleSheetId,
    range: CSS.SourceRange,
    keyText: string
  ): Promise<CSS.SetKeyframeKeyResult> {
    return this.transport.call<CSS.SetKeyframeKeyResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'CSS.setKeyframeKey',
      params: { styleSheetId: styleSheetId, range: range, keyText: keyText },
    })
  }
  async setMediaText(
    styleSheetId: CSS.StyleSheetId,
    range: CSS.SourceRange,
    text: string
  ): Promise<CSS.SetMediaTextResult> {
    return this.transport.call<CSS.SetMediaTextResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'CSS.setMediaText',
      params: { styleSheetId: styleSheetId, range: range, text: text },
    })
  }
  async setContainerQueryText(
    styleSheetId: CSS.StyleSheetId,
    range: CSS.SourceRange,
    text: string
  ): Promise<CSS.SetContainerQueryTextResult> {
    return this.transport.call<CSS.SetContainerQueryTextResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'CSS.setContainerQueryText',
      params: { styleSheetId: styleSheetId, range: range, text: text },
    })
  }
  async setSupportsText(
    styleSheetId: CSS.StyleSheetId,
    range: CSS.SourceRange,
    text: string
  ): Promise<CSS.SetSupportsTextResult> {
    return this.transport.call<CSS.SetSupportsTextResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'CSS.setSupportsText',
      params: { styleSheetId: styleSheetId, range: range, text: text },
    })
  }
  async setScopeText(
    styleSheetId: CSS.StyleSheetId,
    range: CSS.SourceRange,
    text: string
  ): Promise<CSS.SetScopeTextResult> {
    return this.transport.call<CSS.SetScopeTextResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'CSS.setScopeText',
      params: { styleSheetId: styleSheetId, range: range, text: text },
    })
  }
  async setRuleSelector(
    styleSheetId: CSS.StyleSheetId,
    range: CSS.SourceRange,
    selector: string
  ): Promise<CSS.SetRuleSelectorResult> {
    return this.transport.call<CSS.SetRuleSelectorResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'CSS.setRuleSelector',
      params: { styleSheetId: styleSheetId, range: range, selector: selector },
    })
  }
  async setStyleSheetText(
    styleSheetId: CSS.StyleSheetId,
    text: string
  ): Promise<CSS.SetStyleSheetTextResult> {
    return this.transport.call<CSS.SetStyleSheetTextResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'CSS.setStyleSheetText',
      params: { styleSheetId: styleSheetId, text: text },
    })
  }
  async setStyleTexts(
    edits: CSS.StyleDeclarationEdit[],
    nodeForPropertySyntaxValidation?: DOM.NodeId
  ): Promise<CSS.SetStyleTextsResult> {
    return this.transport.call<CSS.SetStyleTextsResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'CSS.setStyleTexts',
      params: {
        edits: edits,
        nodeForPropertySyntaxValidation: nodeForPropertySyntaxValidation,
      },
    })
  }
  async startRuleUsageTracking(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'CSS.startRuleUsageTracking',
      params: {},
    })
  }
  async stopRuleUsageTracking(): Promise<CSS.StopRuleUsageTrackingResult> {
    return this.transport.call<CSS.StopRuleUsageTrackingResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'CSS.stopRuleUsageTracking',
      params: {},
    })
  }
  async takeCoverageDelta(): Promise<CSS.TakeCoverageDeltaResult> {
    return this.transport.call<CSS.TakeCoverageDeltaResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'CSS.takeCoverageDelta',
      params: {},
    })
  }
  async setLocalFontsEnabled(enabled: boolean): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'CSS.setLocalFontsEnabled',
      params: { enabled: enabled },
    })
  }
  on<K extends keyof CSS.EventMap>(
    name: K,
    listener: (event: ChromeEvent<CSS.EventMap[K]>) => void
  ): () => void {
    const filteredListener: typeof listener = (event) => {
      if (event.sessionId !== this.sessionId) {
        return
      }
      listener(event)
    }
    this.listeners.set(
      listener as ChromeEventListener,
      filteredListener as ChromeEventListener
    )
    return this.transport.on(name, filteredListener as ChromeEventListener)
  }
  off<K extends keyof CSS.EventMap>(
    name: K,
    listener: (event: ChromeEvent<CSS.EventMap[K]>) => void
  ): void {
    const filteredListener = this.listeners.get(listener as ChromeEventListener)
    if (filteredListener === undefined) {
      return
    }
    this.listeners.delete(listener as ChromeEventListener)
    return this.transport.off(name, filteredListener)
  }
}
class CacheStorageClient {
  private transport: Transport
  private sessionId: Target.SessionID | undefined
  private listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  async deleteCache(cacheId: CacheStorage.CacheId): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'CacheStorage.deleteCache',
      params: { cacheId: cacheId },
    })
  }
  async deleteEntry(
    cacheId: CacheStorage.CacheId,
    request: string
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'CacheStorage.deleteEntry',
      params: { cacheId: cacheId, request: request },
    })
  }
  async requestCacheNames(
    securityOrigin?: string,
    storageKey?: string,
    storageBucket?: Storage.StorageBucket
  ): Promise<CacheStorage.RequestCacheNamesResult> {
    return this.transport.call<CacheStorage.RequestCacheNamesResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'CacheStorage.requestCacheNames',
      params: {
        securityOrigin: securityOrigin,
        storageKey: storageKey,
        storageBucket: storageBucket,
      },
    })
  }
  async requestCachedResponse(
    cacheId: CacheStorage.CacheId,
    requestURL: string,
    requestHeaders: CacheStorage.Header[]
  ): Promise<CacheStorage.RequestCachedResponseResult> {
    return this.transport.call<CacheStorage.RequestCachedResponseResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'CacheStorage.requestCachedResponse',
      params: {
        cacheId: cacheId,
        requestURL: requestURL,
        requestHeaders: requestHeaders,
      },
    })
  }
  async requestEntries(
    cacheId: CacheStorage.CacheId,
    skipCount?: number,
    pageSize?: number,
    pathFilter?: string
  ): Promise<CacheStorage.RequestEntriesResult> {
    return this.transport.call<CacheStorage.RequestEntriesResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'CacheStorage.requestEntries',
      params: {
        cacheId: cacheId,
        skipCount: skipCount,
        pageSize: pageSize,
        pathFilter: pathFilter,
      },
    })
  }
}
class CastClient {
  private transport: Transport
  private sessionId: Target.SessionID | undefined
  private listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  async enable(presentationUrl?: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Cast.enable',
      params: { presentationUrl: presentationUrl },
    })
  }
  async disable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Cast.disable',
      params: {},
    })
  }
  async setSinkToUse(sinkName: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Cast.setSinkToUse',
      params: { sinkName: sinkName },
    })
  }
  async startDesktopMirroring(sinkName: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Cast.startDesktopMirroring',
      params: { sinkName: sinkName },
    })
  }
  async startTabMirroring(sinkName: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Cast.startTabMirroring',
      params: { sinkName: sinkName },
    })
  }
  async stopCasting(sinkName: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Cast.stopCasting',
      params: { sinkName: sinkName },
    })
  }
  on<K extends keyof Cast.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Cast.EventMap[K]>) => void
  ): () => void {
    const filteredListener: typeof listener = (event) => {
      if (event.sessionId !== this.sessionId) {
        return
      }
      listener(event)
    }
    this.listeners.set(
      listener as ChromeEventListener,
      filteredListener as ChromeEventListener
    )
    return this.transport.on(name, filteredListener as ChromeEventListener)
  }
  off<K extends keyof Cast.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Cast.EventMap[K]>) => void
  ): void {
    const filteredListener = this.listeners.get(listener as ChromeEventListener)
    if (filteredListener === undefined) {
      return
    }
    this.listeners.delete(listener as ChromeEventListener)
    return this.transport.off(name, filteredListener)
  }
}
class DOMClient {
  private transport: Transport
  private sessionId: Target.SessionID | undefined
  private listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  async collectClassNamesFromSubtree(
    nodeId: DOM.NodeId
  ): Promise<DOM.CollectClassNamesFromSubtreeResult> {
    return this.transport.call<DOM.CollectClassNamesFromSubtreeResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.collectClassNamesFromSubtree',
      params: { nodeId: nodeId },
    })
  }
  async copyTo(
    nodeId: DOM.NodeId,
    targetNodeId: DOM.NodeId,
    insertBeforeNodeId?: DOM.NodeId
  ): Promise<DOM.CopyToResult> {
    return this.transport.call<DOM.CopyToResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.copyTo',
      params: {
        nodeId: nodeId,
        targetNodeId: targetNodeId,
        insertBeforeNodeId: insertBeforeNodeId,
      },
    })
  }
  async describeNode(
    nodeId?: DOM.NodeId,
    backendNodeId?: DOM.BackendNodeId,
    objectId?: Runtime.RemoteObjectId,
    depth?: number,
    pierce?: boolean
  ): Promise<DOM.DescribeNodeResult> {
    return this.transport.call<DOM.DescribeNodeResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.describeNode',
      params: {
        nodeId: nodeId,
        backendNodeId: backendNodeId,
        objectId: objectId,
        depth: depth,
        pierce: pierce,
      },
    })
  }
  async scrollIntoViewIfNeeded(
    nodeId?: DOM.NodeId,
    backendNodeId?: DOM.BackendNodeId,
    objectId?: Runtime.RemoteObjectId,
    rect?: DOM.Rect
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.scrollIntoViewIfNeeded',
      params: {
        nodeId: nodeId,
        backendNodeId: backendNodeId,
        objectId: objectId,
        rect: rect,
      },
    })
  }
  async disable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.disable',
      params: {},
    })
  }
  async discardSearchResults(searchId: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.discardSearchResults',
      params: { searchId: searchId },
    })
  }
  async enable(includeWhitespace?: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.enable',
      params: { includeWhitespace: includeWhitespace },
    })
  }
  async focus(
    nodeId?: DOM.NodeId,
    backendNodeId?: DOM.BackendNodeId,
    objectId?: Runtime.RemoteObjectId
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.focus',
      params: {
        nodeId: nodeId,
        backendNodeId: backendNodeId,
        objectId: objectId,
      },
    })
  }
  async getAttributes(nodeId: DOM.NodeId): Promise<DOM.GetAttributesResult> {
    return this.transport.call<DOM.GetAttributesResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.getAttributes',
      params: { nodeId: nodeId },
    })
  }
  async getBoxModel(
    nodeId?: DOM.NodeId,
    backendNodeId?: DOM.BackendNodeId,
    objectId?: Runtime.RemoteObjectId
  ): Promise<DOM.GetBoxModelResult> {
    return this.transport.call<DOM.GetBoxModelResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.getBoxModel',
      params: {
        nodeId: nodeId,
        backendNodeId: backendNodeId,
        objectId: objectId,
      },
    })
  }
  async getContentQuads(
    nodeId?: DOM.NodeId,
    backendNodeId?: DOM.BackendNodeId,
    objectId?: Runtime.RemoteObjectId
  ): Promise<DOM.GetContentQuadsResult> {
    return this.transport.call<DOM.GetContentQuadsResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.getContentQuads',
      params: {
        nodeId: nodeId,
        backendNodeId: backendNodeId,
        objectId: objectId,
      },
    })
  }
  async getDocument(
    depth?: number,
    pierce?: boolean
  ): Promise<DOM.GetDocumentResult> {
    return this.transport.call<DOM.GetDocumentResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.getDocument',
      params: { depth: depth, pierce: pierce },
    })
  }
  async getFlattenedDocument(
    depth?: number,
    pierce?: boolean
  ): Promise<DOM.GetFlattenedDocumentResult> {
    return this.transport.call<DOM.GetFlattenedDocumentResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.getFlattenedDocument',
      params: { depth: depth, pierce: pierce },
    })
  }
  async getNodesForSubtreeByStyle(
    nodeId: DOM.NodeId,
    computedStyles: DOM.CSSComputedStyleProperty[],
    pierce?: boolean
  ): Promise<DOM.GetNodesForSubtreeByStyleResult> {
    return this.transport.call<DOM.GetNodesForSubtreeByStyleResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.getNodesForSubtreeByStyle',
      params: {
        nodeId: nodeId,
        computedStyles: computedStyles,
        pierce: pierce,
      },
    })
  }
  async getNodeForLocation(
    x: number,
    y: number,
    includeUserAgentShadowDOM?: boolean,
    ignorePointerEventsNone?: boolean
  ): Promise<DOM.GetNodeForLocationResult> {
    return this.transport.call<DOM.GetNodeForLocationResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.getNodeForLocation',
      params: {
        x: x,
        y: y,
        includeUserAgentShadowDOM: includeUserAgentShadowDOM,
        ignorePointerEventsNone: ignorePointerEventsNone,
      },
    })
  }
  async getOuterHTML(
    nodeId?: DOM.NodeId,
    backendNodeId?: DOM.BackendNodeId,
    objectId?: Runtime.RemoteObjectId
  ): Promise<DOM.GetOuterHTMLResult> {
    return this.transport.call<DOM.GetOuterHTMLResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.getOuterHTML',
      params: {
        nodeId: nodeId,
        backendNodeId: backendNodeId,
        objectId: objectId,
      },
    })
  }
  async getRelayoutBoundary(
    nodeId: DOM.NodeId
  ): Promise<DOM.GetRelayoutBoundaryResult> {
    return this.transport.call<DOM.GetRelayoutBoundaryResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.getRelayoutBoundary',
      params: { nodeId: nodeId },
    })
  }
  async getSearchResults(
    searchId: string,
    fromIndex: number,
    toIndex: number
  ): Promise<DOM.GetSearchResultsResult> {
    return this.transport.call<DOM.GetSearchResultsResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.getSearchResults',
      params: { searchId: searchId, fromIndex: fromIndex, toIndex: toIndex },
    })
  }
  async hideHighlight(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.hideHighlight',
      params: {},
    })
  }
  async highlightNode(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.highlightNode',
      params: {},
    })
  }
  async highlightRect(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.highlightRect',
      params: {},
    })
  }
  async markUndoableState(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.markUndoableState',
      params: {},
    })
  }
  async moveTo(
    nodeId: DOM.NodeId,
    targetNodeId: DOM.NodeId,
    insertBeforeNodeId?: DOM.NodeId
  ): Promise<DOM.MoveToResult> {
    return this.transport.call<DOM.MoveToResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.moveTo',
      params: {
        nodeId: nodeId,
        targetNodeId: targetNodeId,
        insertBeforeNodeId: insertBeforeNodeId,
      },
    })
  }
  async performSearch(
    query: string,
    includeUserAgentShadowDOM?: boolean
  ): Promise<DOM.PerformSearchResult> {
    return this.transport.call<DOM.PerformSearchResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.performSearch',
      params: {
        query: query,
        includeUserAgentShadowDOM: includeUserAgentShadowDOM,
      },
    })
  }
  async pushNodeByPathToFrontend(
    path: string
  ): Promise<DOM.PushNodeByPathToFrontendResult> {
    return this.transport.call<DOM.PushNodeByPathToFrontendResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.pushNodeByPathToFrontend',
      params: { path: path },
    })
  }
  async pushNodesByBackendIdsToFrontend(
    backendNodeIds: DOM.BackendNodeId[]
  ): Promise<DOM.PushNodesByBackendIdsToFrontendResult> {
    return this.transport.call<DOM.PushNodesByBackendIdsToFrontendResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.pushNodesByBackendIdsToFrontend',
      params: { backendNodeIds: backendNodeIds },
    })
  }
  async querySelector(
    nodeId: DOM.NodeId,
    selector: string
  ): Promise<DOM.QuerySelectorResult> {
    return this.transport.call<DOM.QuerySelectorResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.querySelector',
      params: { nodeId: nodeId, selector: selector },
    })
  }
  async querySelectorAll(
    nodeId: DOM.NodeId,
    selector: string
  ): Promise<DOM.QuerySelectorAllResult> {
    return this.transport.call<DOM.QuerySelectorAllResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.querySelectorAll',
      params: { nodeId: nodeId, selector: selector },
    })
  }
  async getTopLayerElements(): Promise<DOM.GetTopLayerElementsResult> {
    return this.transport.call<DOM.GetTopLayerElementsResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.getTopLayerElements',
      params: {},
    })
  }
  async getElementByRelation(
    nodeId: DOM.NodeId,
    relation: string
  ): Promise<DOM.GetElementByRelationResult> {
    return this.transport.call<DOM.GetElementByRelationResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.getElementByRelation',
      params: { nodeId: nodeId, relation: relation },
    })
  }
  async redo(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.redo',
      params: {},
    })
  }
  async removeAttribute(nodeId: DOM.NodeId, name: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.removeAttribute',
      params: { nodeId: nodeId, name: name },
    })
  }
  async removeNode(nodeId: DOM.NodeId): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.removeNode',
      params: { nodeId: nodeId },
    })
  }
  async requestChildNodes(
    nodeId: DOM.NodeId,
    depth?: number,
    pierce?: boolean
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.requestChildNodes',
      params: { nodeId: nodeId, depth: depth, pierce: pierce },
    })
  }
  async requestNode(
    objectId: Runtime.RemoteObjectId
  ): Promise<DOM.RequestNodeResult> {
    return this.transport.call<DOM.RequestNodeResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.requestNode',
      params: { objectId: objectId },
    })
  }
  async resolveNode(
    nodeId?: DOM.NodeId,
    backendNodeId?: DOM.BackendNodeId,
    objectGroup?: string,
    executionContextId?: Runtime.ExecutionContextId
  ): Promise<DOM.ResolveNodeResult> {
    return this.transport.call<DOM.ResolveNodeResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.resolveNode',
      params: {
        nodeId: nodeId,
        backendNodeId: backendNodeId,
        objectGroup: objectGroup,
        executionContextId: executionContextId,
      },
    })
  }
  async setAttributeValue(
    nodeId: DOM.NodeId,
    name: string,
    value: string
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.setAttributeValue',
      params: { nodeId: nodeId, name: name, value: value },
    })
  }
  async setAttributesAsText(
    nodeId: DOM.NodeId,
    text: string,
    name?: string
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.setAttributesAsText',
      params: { nodeId: nodeId, text: text, name: name },
    })
  }
  async setFileInputFiles(
    files: string[],
    nodeId?: DOM.NodeId,
    backendNodeId?: DOM.BackendNodeId,
    objectId?: Runtime.RemoteObjectId
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.setFileInputFiles',
      params: {
        files: files,
        nodeId: nodeId,
        backendNodeId: backendNodeId,
        objectId: objectId,
      },
    })
  }
  async setNodeStackTracesEnabled(enable: boolean): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.setNodeStackTracesEnabled',
      params: { enable: enable },
    })
  }
  async getNodeStackTraces(
    nodeId: DOM.NodeId
  ): Promise<DOM.GetNodeStackTracesResult> {
    return this.transport.call<DOM.GetNodeStackTracesResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.getNodeStackTraces',
      params: { nodeId: nodeId },
    })
  }
  async getFileInfo(
    objectId: Runtime.RemoteObjectId
  ): Promise<DOM.GetFileInfoResult> {
    return this.transport.call<DOM.GetFileInfoResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.getFileInfo',
      params: { objectId: objectId },
    })
  }
  async getDetachedDomNodes(): Promise<DOM.GetDetachedDomNodesResult> {
    return this.transport.call<DOM.GetDetachedDomNodesResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.getDetachedDomNodes',
      params: {},
    })
  }
  async setInspectedNode(nodeId: DOM.NodeId): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.setInspectedNode',
      params: { nodeId: nodeId },
    })
  }
  async setNodeName(
    nodeId: DOM.NodeId,
    name: string
  ): Promise<DOM.SetNodeNameResult> {
    return this.transport.call<DOM.SetNodeNameResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.setNodeName',
      params: { nodeId: nodeId, name: name },
    })
  }
  async setNodeValue(nodeId: DOM.NodeId, value: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.setNodeValue',
      params: { nodeId: nodeId, value: value },
    })
  }
  async setOuterHTML(nodeId: DOM.NodeId, outerHTML: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.setOuterHTML',
      params: { nodeId: nodeId, outerHTML: outerHTML },
    })
  }
  async undo(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.undo',
      params: {},
    })
  }
  async getFrameOwner(frameId: Page.FrameId): Promise<DOM.GetFrameOwnerResult> {
    return this.transport.call<DOM.GetFrameOwnerResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.getFrameOwner',
      params: { frameId: frameId },
    })
  }
  async getContainerForNode(
    nodeId: DOM.NodeId,
    containerName?: string,
    physicalAxes?: DOM.PhysicalAxes,
    logicalAxes?: DOM.LogicalAxes,
    queriesScrollState?: boolean
  ): Promise<DOM.GetContainerForNodeResult> {
    return this.transport.call<DOM.GetContainerForNodeResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.getContainerForNode',
      params: {
        nodeId: nodeId,
        containerName: containerName,
        physicalAxes: physicalAxes,
        logicalAxes: logicalAxes,
        queriesScrollState: queriesScrollState,
      },
    })
  }
  async getQueryingDescendantsForContainer(
    nodeId: DOM.NodeId
  ): Promise<DOM.GetQueryingDescendantsForContainerResult> {
    return this.transport.call<DOM.GetQueryingDescendantsForContainerResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.getQueryingDescendantsForContainer',
      params: { nodeId: nodeId },
    })
  }
  async getAnchorElement(
    nodeId: DOM.NodeId,
    anchorSpecifier?: string
  ): Promise<DOM.GetAnchorElementResult> {
    return this.transport.call<DOM.GetAnchorElementResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOM.getAnchorElement',
      params: { nodeId: nodeId, anchorSpecifier: anchorSpecifier },
    })
  }
  on<K extends keyof DOM.EventMap>(
    name: K,
    listener: (event: ChromeEvent<DOM.EventMap[K]>) => void
  ): () => void {
    const filteredListener: typeof listener = (event) => {
      if (event.sessionId !== this.sessionId) {
        return
      }
      listener(event)
    }
    this.listeners.set(
      listener as ChromeEventListener,
      filteredListener as ChromeEventListener
    )
    return this.transport.on(name, filteredListener as ChromeEventListener)
  }
  off<K extends keyof DOM.EventMap>(
    name: K,
    listener: (event: ChromeEvent<DOM.EventMap[K]>) => void
  ): void {
    const filteredListener = this.listeners.get(listener as ChromeEventListener)
    if (filteredListener === undefined) {
      return
    }
    this.listeners.delete(listener as ChromeEventListener)
    return this.transport.off(name, filteredListener)
  }
}
class DOMDebuggerClient {
  private transport: Transport
  private sessionId: Target.SessionID | undefined
  private listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  async getEventListeners(
    objectId: Runtime.RemoteObjectId,
    depth?: number,
    pierce?: boolean
  ): Promise<DOMDebugger.GetEventListenersResult> {
    return this.transport.call<DOMDebugger.GetEventListenersResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOMDebugger.getEventListeners',
      params: { objectId: objectId, depth: depth, pierce: pierce },
    })
  }
  async removeDOMBreakpoint(
    nodeId: DOM.NodeId,
    type: DOMDebugger.DOMBreakpointType
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOMDebugger.removeDOMBreakpoint',
      params: { nodeId: nodeId, type: type },
    })
  }
  async removeEventListenerBreakpoint(
    eventName: string,
    targetName?: string
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOMDebugger.removeEventListenerBreakpoint',
      params: { eventName: eventName, targetName: targetName },
    })
  }
  async removeInstrumentationBreakpoint(eventName: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOMDebugger.removeInstrumentationBreakpoint',
      params: { eventName: eventName },
    })
  }
  async removeXHRBreakpoint(url: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOMDebugger.removeXHRBreakpoint',
      params: { url: url },
    })
  }
  async setBreakOnCSPViolation(
    violationTypes: DOMDebugger.CSPViolationType[]
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOMDebugger.setBreakOnCSPViolation',
      params: { violationTypes: violationTypes },
    })
  }
  async setDOMBreakpoint(
    nodeId: DOM.NodeId,
    type: DOMDebugger.DOMBreakpointType
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOMDebugger.setDOMBreakpoint',
      params: { nodeId: nodeId, type: type },
    })
  }
  async setEventListenerBreakpoint(
    eventName: string,
    targetName?: string
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOMDebugger.setEventListenerBreakpoint',
      params: { eventName: eventName, targetName: targetName },
    })
  }
  async setInstrumentationBreakpoint(eventName: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOMDebugger.setInstrumentationBreakpoint',
      params: { eventName: eventName },
    })
  }
  async setXHRBreakpoint(url: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOMDebugger.setXHRBreakpoint',
      params: { url: url },
    })
  }
}
class EventBreakpointsClient {
  private transport: Transport
  private sessionId: Target.SessionID | undefined
  private listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  async setInstrumentationBreakpoint(eventName: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'EventBreakpoints.setInstrumentationBreakpoint',
      params: { eventName: eventName },
    })
  }
  async removeInstrumentationBreakpoint(eventName: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'EventBreakpoints.removeInstrumentationBreakpoint',
      params: { eventName: eventName },
    })
  }
  async disable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'EventBreakpoints.disable',
      params: {},
    })
  }
}
class DOMSnapshotClient {
  private transport: Transport
  private sessionId: Target.SessionID | undefined
  private listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  async disable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOMSnapshot.disable',
      params: {},
    })
  }
  async enable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOMSnapshot.enable',
      params: {},
    })
  }
  async getSnapshot(
    computedStyleWhitelist: string[],
    includeEventListeners?: boolean,
    includePaintOrder?: boolean,
    includeUserAgentShadowTree?: boolean
  ): Promise<DOMSnapshot.GetSnapshotResult> {
    return this.transport.call<DOMSnapshot.GetSnapshotResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOMSnapshot.getSnapshot',
      params: {
        computedStyleWhitelist: computedStyleWhitelist,
        includeEventListeners: includeEventListeners,
        includePaintOrder: includePaintOrder,
        includeUserAgentShadowTree: includeUserAgentShadowTree,
      },
    })
  }
  async captureSnapshot(
    computedStyles: string[],
    includePaintOrder?: boolean,
    includeDOMRects?: boolean,
    includeBlendedBackgroundColors?: boolean,
    includeTextColorOpacities?: boolean
  ): Promise<DOMSnapshot.CaptureSnapshotResult> {
    return this.transport.call<DOMSnapshot.CaptureSnapshotResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOMSnapshot.captureSnapshot',
      params: {
        computedStyles: computedStyles,
        includePaintOrder: includePaintOrder,
        includeDOMRects: includeDOMRects,
        includeBlendedBackgroundColors: includeBlendedBackgroundColors,
        includeTextColorOpacities: includeTextColorOpacities,
      },
    })
  }
}
class DOMStorageClient {
  private transport: Transport
  private sessionId: Target.SessionID | undefined
  private listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  async clear(storageId: DOMStorage.StorageId): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOMStorage.clear',
      params: { storageId: storageId },
    })
  }
  async disable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOMStorage.disable',
      params: {},
    })
  }
  async enable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOMStorage.enable',
      params: {},
    })
  }
  async getDOMStorageItems(
    storageId: DOMStorage.StorageId
  ): Promise<DOMStorage.GetDOMStorageItemsResult> {
    return this.transport.call<DOMStorage.GetDOMStorageItemsResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOMStorage.getDOMStorageItems',
      params: { storageId: storageId },
    })
  }
  async removeDOMStorageItem(
    storageId: DOMStorage.StorageId,
    key: string
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOMStorage.removeDOMStorageItem',
      params: { storageId: storageId, key: key },
    })
  }
  async setDOMStorageItem(
    storageId: DOMStorage.StorageId,
    key: string,
    value: string
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DOMStorage.setDOMStorageItem',
      params: { storageId: storageId, key: key, value: value },
    })
  }
  on<K extends keyof DOMStorage.EventMap>(
    name: K,
    listener: (event: ChromeEvent<DOMStorage.EventMap[K]>) => void
  ): () => void {
    const filteredListener: typeof listener = (event) => {
      if (event.sessionId !== this.sessionId) {
        return
      }
      listener(event)
    }
    this.listeners.set(
      listener as ChromeEventListener,
      filteredListener as ChromeEventListener
    )
    return this.transport.on(name, filteredListener as ChromeEventListener)
  }
  off<K extends keyof DOMStorage.EventMap>(
    name: K,
    listener: (event: ChromeEvent<DOMStorage.EventMap[K]>) => void
  ): void {
    const filteredListener = this.listeners.get(listener as ChromeEventListener)
    if (filteredListener === undefined) {
      return
    }
    this.listeners.delete(listener as ChromeEventListener)
    return this.transport.off(name, filteredListener)
  }
}
class DeviceOrientationClient {
  private transport: Transport
  private sessionId: Target.SessionID | undefined
  private listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  async clearDeviceOrientationOverride(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DeviceOrientation.clearDeviceOrientationOverride',
      params: {},
    })
  }
  async setDeviceOrientationOverride(
    alpha: number,
    beta: number,
    gamma: number
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DeviceOrientation.setDeviceOrientationOverride',
      params: { alpha: alpha, beta: beta, gamma: gamma },
    })
  }
}
class EmulationClient {
  private transport: Transport
  private sessionId: Target.SessionID | undefined
  private listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  async canEmulate(): Promise<Emulation.CanEmulateResult> {
    return this.transport.call<Emulation.CanEmulateResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Emulation.canEmulate',
      params: {},
    })
  }
  async clearDeviceMetricsOverride(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Emulation.clearDeviceMetricsOverride',
      params: {},
    })
  }
  async clearGeolocationOverride(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Emulation.clearGeolocationOverride',
      params: {},
    })
  }
  async resetPageScaleFactor(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Emulation.resetPageScaleFactor',
      params: {},
    })
  }
  async setFocusEmulationEnabled(enabled: boolean): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Emulation.setFocusEmulationEnabled',
      params: { enabled: enabled },
    })
  }
  async setAutoDarkModeOverride(enabled?: boolean): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Emulation.setAutoDarkModeOverride',
      params: { enabled: enabled },
    })
  }
  async setCPUThrottlingRate(rate: number): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Emulation.setCPUThrottlingRate',
      params: { rate: rate },
    })
  }
  async setDefaultBackgroundColorOverride(color?: DOM.RGBA): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Emulation.setDefaultBackgroundColorOverride',
      params: { color: color },
    })
  }
  async setSafeAreaInsetsOverride(
    insets: Emulation.SafeAreaInsets
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Emulation.setSafeAreaInsetsOverride',
      params: { insets: insets },
    })
  }
  async setDeviceMetricsOverride(
    width: number,
    height: number,
    deviceScaleFactor: number,
    mobile: boolean,
    scale?: number,
    screenWidth?: number,
    screenHeight?: number,
    positionX?: number,
    positionY?: number,
    dontSetVisibleSize?: boolean,
    screenOrientation?: Emulation.ScreenOrientation,
    viewport?: Page.Viewport,
    displayFeature?: Emulation.DisplayFeature,
    devicePosture?: Emulation.DevicePosture
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Emulation.setDeviceMetricsOverride',
      params: {
        width: width,
        height: height,
        deviceScaleFactor: deviceScaleFactor,
        mobile: mobile,
        scale: scale,
        screenWidth: screenWidth,
        screenHeight: screenHeight,
        positionX: positionX,
        positionY: positionY,
        dontSetVisibleSize: dontSetVisibleSize,
        screenOrientation: screenOrientation,
        viewport: viewport,
        displayFeature: displayFeature,
        devicePosture: devicePosture,
      },
    })
  }
  async setDevicePostureOverride(
    posture: Emulation.DevicePosture
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Emulation.setDevicePostureOverride',
      params: { posture: posture },
    })
  }
  async clearDevicePostureOverride(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Emulation.clearDevicePostureOverride',
      params: {},
    })
  }
  async setDisplayFeaturesOverride(
    features: Emulation.DisplayFeature[]
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Emulation.setDisplayFeaturesOverride',
      params: { features: features },
    })
  }
  async clearDisplayFeaturesOverride(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Emulation.clearDisplayFeaturesOverride',
      params: {},
    })
  }
  async setScrollbarsHidden(hidden: boolean): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Emulation.setScrollbarsHidden',
      params: { hidden: hidden },
    })
  }
  async setDocumentCookieDisabled(disabled: boolean): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Emulation.setDocumentCookieDisabled',
      params: { disabled: disabled },
    })
  }
  async setEmitTouchEventsForMouse(
    enabled: boolean,
    configuration?: string
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Emulation.setEmitTouchEventsForMouse',
      params: { enabled: enabled, configuration: configuration },
    })
  }
  async setEmulatedMedia(
    media?: string,
    features?: Emulation.MediaFeature[]
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Emulation.setEmulatedMedia',
      params: { media: media, features: features },
    })
  }
  async setEmulatedVisionDeficiency(type: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Emulation.setEmulatedVisionDeficiency',
      params: { type: type },
    })
  }
  async setGeolocationOverride(
    latitude?: number,
    longitude?: number,
    accuracy?: number,
    altitude?: number,
    altitudeAccuracy?: number,
    heading?: number,
    speed?: number
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Emulation.setGeolocationOverride',
      params: {
        latitude: latitude,
        longitude: longitude,
        accuracy: accuracy,
        altitude: altitude,
        altitudeAccuracy: altitudeAccuracy,
        heading: heading,
        speed: speed,
      },
    })
  }
  async getOverriddenSensorInformation(
    type: Emulation.SensorType
  ): Promise<Emulation.GetOverriddenSensorInformationResult> {
    return this.transport.call<Emulation.GetOverriddenSensorInformationResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Emulation.getOverriddenSensorInformation',
      params: { type: type },
    })
  }
  async setSensorOverrideEnabled(
    enabled: boolean,
    type: Emulation.SensorType,
    metadata?: Emulation.SensorMetadata
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Emulation.setSensorOverrideEnabled',
      params: { enabled: enabled, type: type, metadata: metadata },
    })
  }
  async setSensorOverrideReadings(
    type: Emulation.SensorType,
    reading: Emulation.SensorReading
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Emulation.setSensorOverrideReadings',
      params: { type: type, reading: reading },
    })
  }
  async setPressureSourceOverrideEnabled(
    enabled: boolean,
    source: Emulation.PressureSource,
    metadata?: Emulation.PressureMetadata
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Emulation.setPressureSourceOverrideEnabled',
      params: { enabled: enabled, source: source, metadata: metadata },
    })
  }
  async setPressureStateOverride(
    source: Emulation.PressureSource,
    state: Emulation.PressureState
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Emulation.setPressureStateOverride',
      params: { source: source, state: state },
    })
  }
  async setPressureDataOverride(
    source: Emulation.PressureSource,
    state: Emulation.PressureState,
    ownContributionEstimate?: number
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Emulation.setPressureDataOverride',
      params: {
        source: source,
        state: state,
        ownContributionEstimate: ownContributionEstimate,
      },
    })
  }
  async setIdleOverride(
    isUserActive: boolean,
    isScreenUnlocked: boolean
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Emulation.setIdleOverride',
      params: {
        isUserActive: isUserActive,
        isScreenUnlocked: isScreenUnlocked,
      },
    })
  }
  async clearIdleOverride(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Emulation.clearIdleOverride',
      params: {},
    })
  }
  async setNavigatorOverrides(platform: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Emulation.setNavigatorOverrides',
      params: { platform: platform },
    })
  }
  async setPageScaleFactor(pageScaleFactor: number): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Emulation.setPageScaleFactor',
      params: { pageScaleFactor: pageScaleFactor },
    })
  }
  async setScriptExecutionDisabled(value: boolean): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Emulation.setScriptExecutionDisabled',
      params: { value: value },
    })
  }
  async setTouchEmulationEnabled(
    enabled: boolean,
    maxTouchPoints?: number
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Emulation.setTouchEmulationEnabled',
      params: { enabled: enabled, maxTouchPoints: maxTouchPoints },
    })
  }
  async setVirtualTimePolicy(
    policy: Emulation.VirtualTimePolicy,
    budget?: number,
    maxVirtualTimeTaskStarvationCount?: number,
    initialVirtualTime?: Network.TimeSinceEpoch
  ): Promise<Emulation.SetVirtualTimePolicyResult> {
    return this.transport.call<Emulation.SetVirtualTimePolicyResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Emulation.setVirtualTimePolicy',
      params: {
        policy: policy,
        budget: budget,
        maxVirtualTimeTaskStarvationCount: maxVirtualTimeTaskStarvationCount,
        initialVirtualTime: initialVirtualTime,
      },
    })
  }
  async setLocaleOverride(locale?: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Emulation.setLocaleOverride',
      params: { locale: locale },
    })
  }
  async setTimezoneOverride(timezoneId: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Emulation.setTimezoneOverride',
      params: { timezoneId: timezoneId },
    })
  }
  async setVisibleSize(width: number, height: number): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Emulation.setVisibleSize',
      params: { width: width, height: height },
    })
  }
  async setDisabledImageTypes(
    imageTypes: Emulation.DisabledImageType[]
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Emulation.setDisabledImageTypes',
      params: { imageTypes: imageTypes },
    })
  }
  async setHardwareConcurrencyOverride(
    hardwareConcurrency: number
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Emulation.setHardwareConcurrencyOverride',
      params: { hardwareConcurrency: hardwareConcurrency },
    })
  }
  async setUserAgentOverride(
    userAgent: string,
    acceptLanguage?: string,
    platform?: string,
    userAgentMetadata?: Emulation.UserAgentMetadata
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Emulation.setUserAgentOverride',
      params: {
        userAgent: userAgent,
        acceptLanguage: acceptLanguage,
        platform: platform,
        userAgentMetadata: userAgentMetadata,
      },
    })
  }
  async setAutomationOverride(enabled: boolean): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Emulation.setAutomationOverride',
      params: { enabled: enabled },
    })
  }
  async setSmallViewportHeightDifferenceOverride(
    difference: number
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Emulation.setSmallViewportHeightDifferenceOverride',
      params: { difference: difference },
    })
  }
  on<K extends keyof Emulation.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Emulation.EventMap[K]>) => void
  ): () => void {
    const filteredListener: typeof listener = (event) => {
      if (event.sessionId !== this.sessionId) {
        return
      }
      listener(event)
    }
    this.listeners.set(
      listener as ChromeEventListener,
      filteredListener as ChromeEventListener
    )
    return this.transport.on(name, filteredListener as ChromeEventListener)
  }
  off<K extends keyof Emulation.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Emulation.EventMap[K]>) => void
  ): void {
    const filteredListener = this.listeners.get(listener as ChromeEventListener)
    if (filteredListener === undefined) {
      return
    }
    this.listeners.delete(listener as ChromeEventListener)
    return this.transport.off(name, filteredListener)
  }
}
class HeadlessExperimentalClient {
  private transport: Transport
  private sessionId: Target.SessionID | undefined
  private listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  async beginFrame(
    frameTimeTicks?: number,
    interval?: number,
    noDisplayUpdates?: boolean,
    screenshot?: HeadlessExperimental.ScreenshotParams
  ): Promise<HeadlessExperimental.BeginFrameResult> {
    return this.transport.call<HeadlessExperimental.BeginFrameResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'HeadlessExperimental.beginFrame',
      params: {
        frameTimeTicks: frameTimeTicks,
        interval: interval,
        noDisplayUpdates: noDisplayUpdates,
        screenshot: screenshot,
      },
    })
  }
  async disable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'HeadlessExperimental.disable',
      params: {},
    })
  }
  async enable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'HeadlessExperimental.enable',
      params: {},
    })
  }
}
class IOClient {
  private transport: Transport
  private sessionId: Target.SessionID | undefined
  private listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  async close(handle: IO.StreamHandle): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'IO.close',
      params: { handle: handle },
    })
  }
  async read(
    handle: IO.StreamHandle,
    offset?: number,
    size?: number
  ): Promise<IO.ReadResult> {
    return this.transport.call<IO.ReadResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'IO.read',
      params: { handle: handle, offset: offset, size: size },
    })
  }
  async resolveBlob(
    objectId: Runtime.RemoteObjectId
  ): Promise<IO.ResolveBlobResult> {
    return this.transport.call<IO.ResolveBlobResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'IO.resolveBlob',
      params: { objectId: objectId },
    })
  }
}
class FileSystemClient {
  private transport: Transport
  private sessionId: Target.SessionID | undefined
  private listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  async getDirectory(
    bucketFileSystemLocator: FileSystem.BucketFileSystemLocator
  ): Promise<FileSystem.GetDirectoryResult> {
    return this.transport.call<FileSystem.GetDirectoryResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'FileSystem.getDirectory',
      params: { bucketFileSystemLocator: bucketFileSystemLocator },
    })
  }
}
class IndexedDBClient {
  private transport: Transport
  private sessionId: Target.SessionID | undefined
  private listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  async clearObjectStore(
    databaseName: string,
    objectStoreName: string,
    securityOrigin?: string,
    storageKey?: string,
    storageBucket?: Storage.StorageBucket
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'IndexedDB.clearObjectStore',
      params: {
        securityOrigin: securityOrigin,
        storageKey: storageKey,
        storageBucket: storageBucket,
        databaseName: databaseName,
        objectStoreName: objectStoreName,
      },
    })
  }
  async deleteDatabase(
    databaseName: string,
    securityOrigin?: string,
    storageKey?: string,
    storageBucket?: Storage.StorageBucket
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'IndexedDB.deleteDatabase',
      params: {
        securityOrigin: securityOrigin,
        storageKey: storageKey,
        storageBucket: storageBucket,
        databaseName: databaseName,
      },
    })
  }
  async deleteObjectStoreEntries(
    databaseName: string,
    objectStoreName: string,
    keyRange: IndexedDB.KeyRange,
    securityOrigin?: string,
    storageKey?: string,
    storageBucket?: Storage.StorageBucket
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'IndexedDB.deleteObjectStoreEntries',
      params: {
        securityOrigin: securityOrigin,
        storageKey: storageKey,
        storageBucket: storageBucket,
        databaseName: databaseName,
        objectStoreName: objectStoreName,
        keyRange: keyRange,
      },
    })
  }
  async disable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'IndexedDB.disable',
      params: {},
    })
  }
  async enable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'IndexedDB.enable',
      params: {},
    })
  }
  async requestData(
    databaseName: string,
    objectStoreName: string,
    indexName: string,
    skipCount: number,
    pageSize: number,
    securityOrigin?: string,
    storageKey?: string,
    storageBucket?: Storage.StorageBucket,
    keyRange?: IndexedDB.KeyRange
  ): Promise<IndexedDB.RequestDataResult> {
    return this.transport.call<IndexedDB.RequestDataResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'IndexedDB.requestData',
      params: {
        securityOrigin: securityOrigin,
        storageKey: storageKey,
        storageBucket: storageBucket,
        databaseName: databaseName,
        objectStoreName: objectStoreName,
        indexName: indexName,
        skipCount: skipCount,
        pageSize: pageSize,
        keyRange: keyRange,
      },
    })
  }
  async getMetadata(
    databaseName: string,
    objectStoreName: string,
    securityOrigin?: string,
    storageKey?: string,
    storageBucket?: Storage.StorageBucket
  ): Promise<IndexedDB.GetMetadataResult> {
    return this.transport.call<IndexedDB.GetMetadataResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'IndexedDB.getMetadata',
      params: {
        securityOrigin: securityOrigin,
        storageKey: storageKey,
        storageBucket: storageBucket,
        databaseName: databaseName,
        objectStoreName: objectStoreName,
      },
    })
  }
  async requestDatabase(
    databaseName: string,
    securityOrigin?: string,
    storageKey?: string,
    storageBucket?: Storage.StorageBucket
  ): Promise<IndexedDB.RequestDatabaseResult> {
    return this.transport.call<IndexedDB.RequestDatabaseResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'IndexedDB.requestDatabase',
      params: {
        securityOrigin: securityOrigin,
        storageKey: storageKey,
        storageBucket: storageBucket,
        databaseName: databaseName,
      },
    })
  }
  async requestDatabaseNames(
    securityOrigin?: string,
    storageKey?: string,
    storageBucket?: Storage.StorageBucket
  ): Promise<IndexedDB.RequestDatabaseNamesResult> {
    return this.transport.call<IndexedDB.RequestDatabaseNamesResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'IndexedDB.requestDatabaseNames',
      params: {
        securityOrigin: securityOrigin,
        storageKey: storageKey,
        storageBucket: storageBucket,
      },
    })
  }
}
class InputClient {
  private transport: Transport
  private sessionId: Target.SessionID | undefined
  private listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  async dispatchDragEvent(
    type: string,
    x: number,
    y: number,
    data: Input.DragData,
    modifiers?: number
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Input.dispatchDragEvent',
      params: { type: type, x: x, y: y, data: data, modifiers: modifiers },
    })
  }
  async dispatchKeyEvent(
    type: string,
    modifiers?: number,
    timestamp?: Input.TimeSinceEpoch,
    text?: string,
    unmodifiedText?: string,
    keyIdentifier?: string,
    code?: string,
    key?: string,
    windowsVirtualKeyCode?: number,
    nativeVirtualKeyCode?: number,
    autoRepeat?: boolean,
    isKeypad?: boolean,
    isSystemKey?: boolean,
    location?: number,
    commands?: string[]
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Input.dispatchKeyEvent',
      params: {
        type: type,
        modifiers: modifiers,
        timestamp: timestamp,
        text: text,
        unmodifiedText: unmodifiedText,
        keyIdentifier: keyIdentifier,
        code: code,
        key: key,
        windowsVirtualKeyCode: windowsVirtualKeyCode,
        nativeVirtualKeyCode: nativeVirtualKeyCode,
        autoRepeat: autoRepeat,
        isKeypad: isKeypad,
        isSystemKey: isSystemKey,
        location: location,
        commands: commands,
      },
    })
  }
  async insertText(text: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Input.insertText',
      params: { text: text },
    })
  }
  async imeSetComposition(
    text: string,
    selectionStart: number,
    selectionEnd: number,
    replacementStart?: number,
    replacementEnd?: number
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Input.imeSetComposition',
      params: {
        text: text,
        selectionStart: selectionStart,
        selectionEnd: selectionEnd,
        replacementStart: replacementStart,
        replacementEnd: replacementEnd,
      },
    })
  }
  async dispatchMouseEvent(
    type: string,
    x: number,
    y: number,
    modifiers?: number,
    timestamp?: Input.TimeSinceEpoch,
    button?: Input.MouseButton,
    buttons?: number,
    clickCount?: number,
    force?: number,
    tangentialPressure?: number,
    tiltX?: number,
    tiltY?: number,
    twist?: number,
    deltaX?: number,
    deltaY?: number,
    pointerType?: string
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Input.dispatchMouseEvent',
      params: {
        type: type,
        x: x,
        y: y,
        modifiers: modifiers,
        timestamp: timestamp,
        button: button,
        buttons: buttons,
        clickCount: clickCount,
        force: force,
        tangentialPressure: tangentialPressure,
        tiltX: tiltX,
        tiltY: tiltY,
        twist: twist,
        deltaX: deltaX,
        deltaY: deltaY,
        pointerType: pointerType,
      },
    })
  }
  async dispatchTouchEvent(
    type: string,
    touchPoints: Input.TouchPoint[],
    modifiers?: number,
    timestamp?: Input.TimeSinceEpoch
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Input.dispatchTouchEvent',
      params: {
        type: type,
        touchPoints: touchPoints,
        modifiers: modifiers,
        timestamp: timestamp,
      },
    })
  }
  async cancelDragging(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Input.cancelDragging',
      params: {},
    })
  }
  async emulateTouchFromMouseEvent(
    type: string,
    x: number,
    y: number,
    button: Input.MouseButton,
    timestamp?: Input.TimeSinceEpoch,
    deltaX?: number,
    deltaY?: number,
    modifiers?: number,
    clickCount?: number
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Input.emulateTouchFromMouseEvent',
      params: {
        type: type,
        x: x,
        y: y,
        button: button,
        timestamp: timestamp,
        deltaX: deltaX,
        deltaY: deltaY,
        modifiers: modifiers,
        clickCount: clickCount,
      },
    })
  }
  async setIgnoreInputEvents(ignore: boolean): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Input.setIgnoreInputEvents',
      params: { ignore: ignore },
    })
  }
  async setInterceptDrags(enabled: boolean): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Input.setInterceptDrags',
      params: { enabled: enabled },
    })
  }
  async synthesizePinchGesture(
    x: number,
    y: number,
    scaleFactor: number,
    relativeSpeed?: number,
    gestureSourceType?: Input.GestureSourceType
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Input.synthesizePinchGesture',
      params: {
        x: x,
        y: y,
        scaleFactor: scaleFactor,
        relativeSpeed: relativeSpeed,
        gestureSourceType: gestureSourceType,
      },
    })
  }
  async synthesizeScrollGesture(
    x: number,
    y: number,
    xDistance?: number,
    yDistance?: number,
    xOverscroll?: number,
    yOverscroll?: number,
    preventFling?: boolean,
    speed?: number,
    gestureSourceType?: Input.GestureSourceType,
    repeatCount?: number,
    repeatDelayMs?: number,
    interactionMarkerName?: string
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Input.synthesizeScrollGesture',
      params: {
        x: x,
        y: y,
        xDistance: xDistance,
        yDistance: yDistance,
        xOverscroll: xOverscroll,
        yOverscroll: yOverscroll,
        preventFling: preventFling,
        speed: speed,
        gestureSourceType: gestureSourceType,
        repeatCount: repeatCount,
        repeatDelayMs: repeatDelayMs,
        interactionMarkerName: interactionMarkerName,
      },
    })
  }
  async synthesizeTapGesture(
    x: number,
    y: number,
    duration?: number,
    tapCount?: number,
    gestureSourceType?: Input.GestureSourceType
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Input.synthesizeTapGesture',
      params: {
        x: x,
        y: y,
        duration: duration,
        tapCount: tapCount,
        gestureSourceType: gestureSourceType,
      },
    })
  }
  on<K extends keyof Input.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Input.EventMap[K]>) => void
  ): () => void {
    const filteredListener: typeof listener = (event) => {
      if (event.sessionId !== this.sessionId) {
        return
      }
      listener(event)
    }
    this.listeners.set(
      listener as ChromeEventListener,
      filteredListener as ChromeEventListener
    )
    return this.transport.on(name, filteredListener as ChromeEventListener)
  }
  off<K extends keyof Input.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Input.EventMap[K]>) => void
  ): void {
    const filteredListener = this.listeners.get(listener as ChromeEventListener)
    if (filteredListener === undefined) {
      return
    }
    this.listeners.delete(listener as ChromeEventListener)
    return this.transport.off(name, filteredListener)
  }
}
class InspectorClient {
  private transport: Transport
  private sessionId: Target.SessionID | undefined
  private listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  async disable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Inspector.disable',
      params: {},
    })
  }
  async enable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Inspector.enable',
      params: {},
    })
  }
  on<K extends keyof Inspector.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Inspector.EventMap[K]>) => void
  ): () => void {
    const filteredListener: typeof listener = (event) => {
      if (event.sessionId !== this.sessionId) {
        return
      }
      listener(event)
    }
    this.listeners.set(
      listener as ChromeEventListener,
      filteredListener as ChromeEventListener
    )
    return this.transport.on(name, filteredListener as ChromeEventListener)
  }
  off<K extends keyof Inspector.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Inspector.EventMap[K]>) => void
  ): void {
    const filteredListener = this.listeners.get(listener as ChromeEventListener)
    if (filteredListener === undefined) {
      return
    }
    this.listeners.delete(listener as ChromeEventListener)
    return this.transport.off(name, filteredListener)
  }
}
class LayerTreeClient {
  private transport: Transport
  private sessionId: Target.SessionID | undefined
  private listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  async compositingReasons(
    layerId: LayerTree.LayerId
  ): Promise<LayerTree.CompositingReasonsResult> {
    return this.transport.call<LayerTree.CompositingReasonsResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'LayerTree.compositingReasons',
      params: { layerId: layerId },
    })
  }
  async disable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'LayerTree.disable',
      params: {},
    })
  }
  async enable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'LayerTree.enable',
      params: {},
    })
  }
  async loadSnapshot(
    tiles: LayerTree.PictureTile[]
  ): Promise<LayerTree.LoadSnapshotResult> {
    return this.transport.call<LayerTree.LoadSnapshotResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'LayerTree.loadSnapshot',
      params: { tiles: tiles },
    })
  }
  async makeSnapshot(
    layerId: LayerTree.LayerId
  ): Promise<LayerTree.MakeSnapshotResult> {
    return this.transport.call<LayerTree.MakeSnapshotResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'LayerTree.makeSnapshot',
      params: { layerId: layerId },
    })
  }
  async profileSnapshot(
    snapshotId: LayerTree.SnapshotId,
    minRepeatCount?: number,
    minDuration?: number,
    clipRect?: DOM.Rect
  ): Promise<LayerTree.ProfileSnapshotResult> {
    return this.transport.call<LayerTree.ProfileSnapshotResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'LayerTree.profileSnapshot',
      params: {
        snapshotId: snapshotId,
        minRepeatCount: minRepeatCount,
        minDuration: minDuration,
        clipRect: clipRect,
      },
    })
  }
  async releaseSnapshot(snapshotId: LayerTree.SnapshotId): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'LayerTree.releaseSnapshot',
      params: { snapshotId: snapshotId },
    })
  }
  async replaySnapshot(
    snapshotId: LayerTree.SnapshotId,
    fromStep?: number,
    toStep?: number,
    scale?: number
  ): Promise<LayerTree.ReplaySnapshotResult> {
    return this.transport.call<LayerTree.ReplaySnapshotResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'LayerTree.replaySnapshot',
      params: {
        snapshotId: snapshotId,
        fromStep: fromStep,
        toStep: toStep,
        scale: scale,
      },
    })
  }
  async snapshotCommandLog(
    snapshotId: LayerTree.SnapshotId
  ): Promise<LayerTree.SnapshotCommandLogResult> {
    return this.transport.call<LayerTree.SnapshotCommandLogResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'LayerTree.snapshotCommandLog',
      params: { snapshotId: snapshotId },
    })
  }
  on<K extends keyof LayerTree.EventMap>(
    name: K,
    listener: (event: ChromeEvent<LayerTree.EventMap[K]>) => void
  ): () => void {
    const filteredListener: typeof listener = (event) => {
      if (event.sessionId !== this.sessionId) {
        return
      }
      listener(event)
    }
    this.listeners.set(
      listener as ChromeEventListener,
      filteredListener as ChromeEventListener
    )
    return this.transport.on(name, filteredListener as ChromeEventListener)
  }
  off<K extends keyof LayerTree.EventMap>(
    name: K,
    listener: (event: ChromeEvent<LayerTree.EventMap[K]>) => void
  ): void {
    const filteredListener = this.listeners.get(listener as ChromeEventListener)
    if (filteredListener === undefined) {
      return
    }
    this.listeners.delete(listener as ChromeEventListener)
    return this.transport.off(name, filteredListener)
  }
}
class LogClient {
  private transport: Transport
  private sessionId: Target.SessionID | undefined
  private listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  async clear(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Log.clear',
      params: {},
    })
  }
  async disable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Log.disable',
      params: {},
    })
  }
  async enable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Log.enable',
      params: {},
    })
  }
  async startViolationsReport(config: Log.ViolationSetting[]): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Log.startViolationsReport',
      params: { config: config },
    })
  }
  async stopViolationsReport(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Log.stopViolationsReport',
      params: {},
    })
  }
  on<K extends keyof Log.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Log.EventMap[K]>) => void
  ): () => void {
    const filteredListener: typeof listener = (event) => {
      if (event.sessionId !== this.sessionId) {
        return
      }
      listener(event)
    }
    this.listeners.set(
      listener as ChromeEventListener,
      filteredListener as ChromeEventListener
    )
    return this.transport.on(name, filteredListener as ChromeEventListener)
  }
  off<K extends keyof Log.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Log.EventMap[K]>) => void
  ): void {
    const filteredListener = this.listeners.get(listener as ChromeEventListener)
    if (filteredListener === undefined) {
      return
    }
    this.listeners.delete(listener as ChromeEventListener)
    return this.transport.off(name, filteredListener)
  }
}
class MemoryClient {
  private transport: Transport
  private sessionId: Target.SessionID | undefined
  private listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  async getDOMCounters(): Promise<Memory.GetDOMCountersResult> {
    return this.transport.call<Memory.GetDOMCountersResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Memory.getDOMCounters',
      params: {},
    })
  }
  async getDOMCountersForLeakDetection(): Promise<Memory.GetDOMCountersForLeakDetectionResult> {
    return this.transport.call<Memory.GetDOMCountersForLeakDetectionResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Memory.getDOMCountersForLeakDetection',
      params: {},
    })
  }
  async prepareForLeakDetection(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Memory.prepareForLeakDetection',
      params: {},
    })
  }
  async forciblyPurgeJavaScriptMemory(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Memory.forciblyPurgeJavaScriptMemory',
      params: {},
    })
  }
  async setPressureNotificationsSuppressed(suppressed: boolean): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Memory.setPressureNotificationsSuppressed',
      params: { suppressed: suppressed },
    })
  }
  async simulatePressureNotification(
    level: Memory.PressureLevel
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Memory.simulatePressureNotification',
      params: { level: level },
    })
  }
  async startSampling(
    samplingInterval?: number,
    suppressRandomness?: boolean
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Memory.startSampling',
      params: {
        samplingInterval: samplingInterval,
        suppressRandomness: suppressRandomness,
      },
    })
  }
  async stopSampling(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Memory.stopSampling',
      params: {},
    })
  }
  async getAllTimeSamplingProfile(): Promise<Memory.GetAllTimeSamplingProfileResult> {
    return this.transport.call<Memory.GetAllTimeSamplingProfileResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Memory.getAllTimeSamplingProfile',
      params: {},
    })
  }
  async getBrowserSamplingProfile(): Promise<Memory.GetBrowserSamplingProfileResult> {
    return this.transport.call<Memory.GetBrowserSamplingProfileResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Memory.getBrowserSamplingProfile',
      params: {},
    })
  }
  async getSamplingProfile(): Promise<Memory.GetSamplingProfileResult> {
    return this.transport.call<Memory.GetSamplingProfileResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Memory.getSamplingProfile',
      params: {},
    })
  }
}
class NetworkClient {
  private transport: Transport
  private sessionId: Target.SessionID | undefined
  private listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  async setAcceptedEncodings(
    encodings: Network.ContentEncoding[]
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Network.setAcceptedEncodings',
      params: { encodings: encodings },
    })
  }
  async clearAcceptedEncodingsOverride(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Network.clearAcceptedEncodingsOverride',
      params: {},
    })
  }
  async canClearBrowserCache(): Promise<Network.CanClearBrowserCacheResult> {
    return this.transport.call<Network.CanClearBrowserCacheResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Network.canClearBrowserCache',
      params: {},
    })
  }
  async canClearBrowserCookies(): Promise<Network.CanClearBrowserCookiesResult> {
    return this.transport.call<Network.CanClearBrowserCookiesResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Network.canClearBrowserCookies',
      params: {},
    })
  }
  async canEmulateNetworkConditions(): Promise<Network.CanEmulateNetworkConditionsResult> {
    return this.transport.call<Network.CanEmulateNetworkConditionsResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Network.canEmulateNetworkConditions',
      params: {},
    })
  }
  async clearBrowserCache(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Network.clearBrowserCache',
      params: {},
    })
  }
  async clearBrowserCookies(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Network.clearBrowserCookies',
      params: {},
    })
  }
  async continueInterceptedRequest(
    interceptionId: Network.InterceptionId,
    errorReason?: Network.ErrorReason,
    rawResponse?: string,
    url?: string,
    method?: string,
    postData?: string,
    headers?: Network.Headers,
    authChallengeResponse?: Network.AuthChallengeResponse
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Network.continueInterceptedRequest',
      params: {
        interceptionId: interceptionId,
        errorReason: errorReason,
        rawResponse: rawResponse,
        url: url,
        method: method,
        postData: postData,
        headers: headers,
        authChallengeResponse: authChallengeResponse,
      },
    })
  }
  async deleteCookies(
    name: string,
    url?: string,
    domain?: string,
    path?: string,
    partitionKey?: Network.CookiePartitionKey
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Network.deleteCookies',
      params: {
        name: name,
        url: url,
        domain: domain,
        path: path,
        partitionKey: partitionKey,
      },
    })
  }
  async disable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Network.disable',
      params: {},
    })
  }
  async emulateNetworkConditions(
    offline: boolean,
    latency: number,
    downloadThroughput: number,
    uploadThroughput: number,
    connectionType?: Network.ConnectionType,
    packetLoss?: number,
    packetQueueLength?: number,
    packetReordering?: boolean
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Network.emulateNetworkConditions',
      params: {
        offline: offline,
        latency: latency,
        downloadThroughput: downloadThroughput,
        uploadThroughput: uploadThroughput,
        connectionType: connectionType,
        packetLoss: packetLoss,
        packetQueueLength: packetQueueLength,
        packetReordering: packetReordering,
      },
    })
  }
  async enable(
    maxTotalBufferSize?: number,
    maxResourceBufferSize?: number,
    maxPostDataSize?: number,
    reportDirectSocketTraffic?: boolean
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Network.enable',
      params: {
        maxTotalBufferSize: maxTotalBufferSize,
        maxResourceBufferSize: maxResourceBufferSize,
        maxPostDataSize: maxPostDataSize,
        reportDirectSocketTraffic: reportDirectSocketTraffic,
      },
    })
  }
  async getAllCookies(): Promise<Network.GetAllCookiesResult> {
    return this.transport.call<Network.GetAllCookiesResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Network.getAllCookies',
      params: {},
    })
  }
  async getCertificate(origin: string): Promise<Network.GetCertificateResult> {
    return this.transport.call<Network.GetCertificateResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Network.getCertificate',
      params: { origin: origin },
    })
  }
  async getCookies(urls?: string[]): Promise<Network.GetCookiesResult> {
    return this.transport.call<Network.GetCookiesResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Network.getCookies',
      params: { urls: urls },
    })
  }
  async getResponseBody(
    requestId: Network.RequestId
  ): Promise<Network.GetResponseBodyResult> {
    return this.transport.call<Network.GetResponseBodyResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Network.getResponseBody',
      params: { requestId: requestId },
    })
  }
  async getRequestPostData(
    requestId: Network.RequestId
  ): Promise<Network.GetRequestPostDataResult> {
    return this.transport.call<Network.GetRequestPostDataResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Network.getRequestPostData',
      params: { requestId: requestId },
    })
  }
  async getResponseBodyForInterception(
    interceptionId: Network.InterceptionId
  ): Promise<Network.GetResponseBodyForInterceptionResult> {
    return this.transport.call<Network.GetResponseBodyForInterceptionResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Network.getResponseBodyForInterception',
      params: { interceptionId: interceptionId },
    })
  }
  async takeResponseBodyForInterceptionAsStream(
    interceptionId: Network.InterceptionId
  ): Promise<Network.TakeResponseBodyForInterceptionAsStreamResult> {
    return this.transport.call<Network.TakeResponseBodyForInterceptionAsStreamResult>(
      {
        id: generateId(),
        sessionId: this.sessionId,
        method: 'Network.takeResponseBodyForInterceptionAsStream',
        params: { interceptionId: interceptionId },
      }
    )
  }
  async replayXHR(requestId: Network.RequestId): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Network.replayXHR',
      params: { requestId: requestId },
    })
  }
  async searchInResponseBody(
    requestId: Network.RequestId,
    query: string,
    caseSensitive?: boolean,
    isRegex?: boolean
  ): Promise<Network.SearchInResponseBodyResult> {
    return this.transport.call<Network.SearchInResponseBodyResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Network.searchInResponseBody',
      params: {
        requestId: requestId,
        query: query,
        caseSensitive: caseSensitive,
        isRegex: isRegex,
      },
    })
  }
  async setBlockedURLs(urls: string[]): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Network.setBlockedURLs',
      params: { urls: urls },
    })
  }
  async setBypassServiceWorker(bypass: boolean): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Network.setBypassServiceWorker',
      params: { bypass: bypass },
    })
  }
  async setCacheDisabled(cacheDisabled: boolean): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Network.setCacheDisabled',
      params: { cacheDisabled: cacheDisabled },
    })
  }
  async setCookie(
    name: string,
    value: string,
    url?: string,
    domain?: string,
    path?: string,
    secure?: boolean,
    httpOnly?: boolean,
    sameSite?: Network.CookieSameSite,
    expires?: Network.TimeSinceEpoch,
    priority?: Network.CookiePriority,
    sameParty?: boolean,
    sourceScheme?: Network.CookieSourceScheme,
    sourcePort?: number,
    partitionKey?: Network.CookiePartitionKey
  ): Promise<Network.SetCookieResult> {
    return this.transport.call<Network.SetCookieResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Network.setCookie',
      params: {
        name: name,
        value: value,
        url: url,
        domain: domain,
        path: path,
        secure: secure,
        httpOnly: httpOnly,
        sameSite: sameSite,
        expires: expires,
        priority: priority,
        sameParty: sameParty,
        sourceScheme: sourceScheme,
        sourcePort: sourcePort,
        partitionKey: partitionKey,
      },
    })
  }
  async setCookies(cookies: Network.CookieParam[]): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Network.setCookies',
      params: { cookies: cookies },
    })
  }
  async setExtraHTTPHeaders(headers: Network.Headers): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Network.setExtraHTTPHeaders',
      params: { headers: headers },
    })
  }
  async setAttachDebugStack(enabled: boolean): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Network.setAttachDebugStack',
      params: { enabled: enabled },
    })
  }
  async setRequestInterception(
    patterns: Network.RequestPattern[]
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Network.setRequestInterception',
      params: { patterns: patterns },
    })
  }
  async setUserAgentOverride(
    userAgent: string,
    acceptLanguage?: string,
    platform?: string,
    userAgentMetadata?: Emulation.UserAgentMetadata
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Network.setUserAgentOverride',
      params: {
        userAgent: userAgent,
        acceptLanguage: acceptLanguage,
        platform: platform,
        userAgentMetadata: userAgentMetadata,
      },
    })
  }
  async streamResourceContent(
    requestId: Network.RequestId
  ): Promise<Network.StreamResourceContentResult> {
    return this.transport.call<Network.StreamResourceContentResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Network.streamResourceContent',
      params: { requestId: requestId },
    })
  }
  async getSecurityIsolationStatus(
    frameId?: Page.FrameId
  ): Promise<Network.GetSecurityIsolationStatusResult> {
    return this.transport.call<Network.GetSecurityIsolationStatusResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Network.getSecurityIsolationStatus',
      params: { frameId: frameId },
    })
  }
  async enableReportingApi(enable: boolean): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Network.enableReportingApi',
      params: { enable: enable },
    })
  }
  async loadNetworkResource(
    url: string,
    options: Network.LoadNetworkResourceOptions,
    frameId?: Page.FrameId
  ): Promise<Network.LoadNetworkResourceResult> {
    return this.transport.call<Network.LoadNetworkResourceResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Network.loadNetworkResource',
      params: { frameId: frameId, url: url, options: options },
    })
  }
  async setCookieControls(
    enableThirdPartyCookieRestriction: boolean,
    disableThirdPartyCookieMetadata: boolean,
    disableThirdPartyCookieHeuristics: boolean
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Network.setCookieControls',
      params: {
        enableThirdPartyCookieRestriction: enableThirdPartyCookieRestriction,
        disableThirdPartyCookieMetadata: disableThirdPartyCookieMetadata,
        disableThirdPartyCookieHeuristics: disableThirdPartyCookieHeuristics,
      },
    })
  }
  on<K extends keyof Network.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Network.EventMap[K]>) => void
  ): () => void {
    const filteredListener: typeof listener = (event) => {
      if (event.sessionId !== this.sessionId) {
        return
      }
      listener(event)
    }
    this.listeners.set(
      listener as ChromeEventListener,
      filteredListener as ChromeEventListener
    )
    return this.transport.on(name, filteredListener as ChromeEventListener)
  }
  off<K extends keyof Network.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Network.EventMap[K]>) => void
  ): void {
    const filteredListener = this.listeners.get(listener as ChromeEventListener)
    if (filteredListener === undefined) {
      return
    }
    this.listeners.delete(listener as ChromeEventListener)
    return this.transport.off(name, filteredListener)
  }
}
class OverlayClient {
  private transport: Transport
  private sessionId: Target.SessionID | undefined
  private listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  async disable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Overlay.disable',
      params: {},
    })
  }
  async enable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Overlay.enable',
      params: {},
    })
  }
  async getHighlightObjectForTest(
    nodeId: DOM.NodeId,
    includeDistance?: boolean,
    includeStyle?: boolean,
    colorFormat?: Overlay.ColorFormat,
    showAccessibilityInfo?: boolean
  ): Promise<Overlay.GetHighlightObjectForTestResult> {
    return this.transport.call<Overlay.GetHighlightObjectForTestResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Overlay.getHighlightObjectForTest',
      params: {
        nodeId: nodeId,
        includeDistance: includeDistance,
        includeStyle: includeStyle,
        colorFormat: colorFormat,
        showAccessibilityInfo: showAccessibilityInfo,
      },
    })
  }
  async getGridHighlightObjectsForTest(
    nodeIds: DOM.NodeId[]
  ): Promise<Overlay.GetGridHighlightObjectsForTestResult> {
    return this.transport.call<Overlay.GetGridHighlightObjectsForTestResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Overlay.getGridHighlightObjectsForTest',
      params: { nodeIds: nodeIds },
    })
  }
  async getSourceOrderHighlightObjectForTest(
    nodeId: DOM.NodeId
  ): Promise<Overlay.GetSourceOrderHighlightObjectForTestResult> {
    return this.transport.call<Overlay.GetSourceOrderHighlightObjectForTestResult>(
      {
        id: generateId(),
        sessionId: this.sessionId,
        method: 'Overlay.getSourceOrderHighlightObjectForTest',
        params: { nodeId: nodeId },
      }
    )
  }
  async hideHighlight(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Overlay.hideHighlight',
      params: {},
    })
  }
  async highlightFrame(
    frameId: Page.FrameId,
    contentColor?: DOM.RGBA,
    contentOutlineColor?: DOM.RGBA
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Overlay.highlightFrame',
      params: {
        frameId: frameId,
        contentColor: contentColor,
        contentOutlineColor: contentOutlineColor,
      },
    })
  }
  async highlightNode(
    highlightConfig: Overlay.HighlightConfig,
    nodeId?: DOM.NodeId,
    backendNodeId?: DOM.BackendNodeId,
    objectId?: Runtime.RemoteObjectId,
    selector?: string
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Overlay.highlightNode',
      params: {
        highlightConfig: highlightConfig,
        nodeId: nodeId,
        backendNodeId: backendNodeId,
        objectId: objectId,
        selector: selector,
      },
    })
  }
  async highlightQuad(
    quad: DOM.Quad,
    color?: DOM.RGBA,
    outlineColor?: DOM.RGBA
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Overlay.highlightQuad',
      params: { quad: quad, color: color, outlineColor: outlineColor },
    })
  }
  async highlightRect(
    x: number,
    y: number,
    width: number,
    height: number,
    color?: DOM.RGBA,
    outlineColor?: DOM.RGBA
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Overlay.highlightRect',
      params: {
        x: x,
        y: y,
        width: width,
        height: height,
        color: color,
        outlineColor: outlineColor,
      },
    })
  }
  async highlightSourceOrder(
    sourceOrderConfig: Overlay.SourceOrderConfig,
    nodeId?: DOM.NodeId,
    backendNodeId?: DOM.BackendNodeId,
    objectId?: Runtime.RemoteObjectId
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Overlay.highlightSourceOrder',
      params: {
        sourceOrderConfig: sourceOrderConfig,
        nodeId: nodeId,
        backendNodeId: backendNodeId,
        objectId: objectId,
      },
    })
  }
  async setInspectMode(
    mode: Overlay.InspectMode,
    highlightConfig?: Overlay.HighlightConfig
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Overlay.setInspectMode',
      params: { mode: mode, highlightConfig: highlightConfig },
    })
  }
  async setShowAdHighlights(show: boolean): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Overlay.setShowAdHighlights',
      params: { show: show },
    })
  }
  async setPausedInDebuggerMessage(message?: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Overlay.setPausedInDebuggerMessage',
      params: { message: message },
    })
  }
  async setShowDebugBorders(show: boolean): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Overlay.setShowDebugBorders',
      params: { show: show },
    })
  }
  async setShowFPSCounter(show: boolean): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Overlay.setShowFPSCounter',
      params: { show: show },
    })
  }
  async setShowGridOverlays(
    gridNodeHighlightConfigs: Overlay.GridNodeHighlightConfig[]
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Overlay.setShowGridOverlays',
      params: { gridNodeHighlightConfigs: gridNodeHighlightConfigs },
    })
  }
  async setShowFlexOverlays(
    flexNodeHighlightConfigs: Overlay.FlexNodeHighlightConfig[]
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Overlay.setShowFlexOverlays',
      params: { flexNodeHighlightConfigs: flexNodeHighlightConfigs },
    })
  }
  async setShowScrollSnapOverlays(
    scrollSnapHighlightConfigs: Overlay.ScrollSnapHighlightConfig[]
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Overlay.setShowScrollSnapOverlays',
      params: { scrollSnapHighlightConfigs: scrollSnapHighlightConfigs },
    })
  }
  async setShowContainerQueryOverlays(
    containerQueryHighlightConfigs: Overlay.ContainerQueryHighlightConfig[]
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Overlay.setShowContainerQueryOverlays',
      params: {
        containerQueryHighlightConfigs: containerQueryHighlightConfigs,
      },
    })
  }
  async setShowPaintRects(result: boolean): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Overlay.setShowPaintRects',
      params: { result: result },
    })
  }
  async setShowLayoutShiftRegions(result: boolean): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Overlay.setShowLayoutShiftRegions',
      params: { result: result },
    })
  }
  async setShowScrollBottleneckRects(show: boolean): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Overlay.setShowScrollBottleneckRects',
      params: { show: show },
    })
  }
  async setShowHitTestBorders(show: boolean): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Overlay.setShowHitTestBorders',
      params: { show: show },
    })
  }
  async setShowWebVitals(show: boolean): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Overlay.setShowWebVitals',
      params: { show: show },
    })
  }
  async setShowViewportSizeOnResize(show: boolean): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Overlay.setShowViewportSizeOnResize',
      params: { show: show },
    })
  }
  async setShowHinge(hingeConfig?: Overlay.HingeConfig): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Overlay.setShowHinge',
      params: { hingeConfig: hingeConfig },
    })
  }
  async setShowIsolatedElements(
    isolatedElementHighlightConfigs: Overlay.IsolatedElementHighlightConfig[]
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Overlay.setShowIsolatedElements',
      params: {
        isolatedElementHighlightConfigs: isolatedElementHighlightConfigs,
      },
    })
  }
  async setShowWindowControlsOverlay(
    windowControlsOverlayConfig?: Overlay.WindowControlsOverlayConfig
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Overlay.setShowWindowControlsOverlay',
      params: { windowControlsOverlayConfig: windowControlsOverlayConfig },
    })
  }
  on<K extends keyof Overlay.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Overlay.EventMap[K]>) => void
  ): () => void {
    const filteredListener: typeof listener = (event) => {
      if (event.sessionId !== this.sessionId) {
        return
      }
      listener(event)
    }
    this.listeners.set(
      listener as ChromeEventListener,
      filteredListener as ChromeEventListener
    )
    return this.transport.on(name, filteredListener as ChromeEventListener)
  }
  off<K extends keyof Overlay.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Overlay.EventMap[K]>) => void
  ): void {
    const filteredListener = this.listeners.get(listener as ChromeEventListener)
    if (filteredListener === undefined) {
      return
    }
    this.listeners.delete(listener as ChromeEventListener)
    return this.transport.off(name, filteredListener)
  }
}
class PageClient {
  private transport: Transport
  private sessionId: Target.SessionID | undefined
  private listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  async addScriptToEvaluateOnLoad(
    scriptSource: string
  ): Promise<Page.AddScriptToEvaluateOnLoadResult> {
    return this.transport.call<Page.AddScriptToEvaluateOnLoadResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.addScriptToEvaluateOnLoad',
      params: { scriptSource: scriptSource },
    })
  }
  async addScriptToEvaluateOnNewDocument(
    source: string,
    worldName?: string,
    includeCommandLineAPI?: boolean,
    runImmediately?: boolean
  ): Promise<Page.AddScriptToEvaluateOnNewDocumentResult> {
    return this.transport.call<Page.AddScriptToEvaluateOnNewDocumentResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.addScriptToEvaluateOnNewDocument',
      params: {
        source: source,
        worldName: worldName,
        includeCommandLineAPI: includeCommandLineAPI,
        runImmediately: runImmediately,
      },
    })
  }
  async bringToFront(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.bringToFront',
      params: {},
    })
  }
  async captureScreenshot(
    format?: string,
    quality?: number,
    clip?: Page.Viewport,
    fromSurface?: boolean,
    captureBeyondViewport?: boolean,
    optimizeForSpeed?: boolean
  ): Promise<Page.CaptureScreenshotResult> {
    return this.transport.call<Page.CaptureScreenshotResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.captureScreenshot',
      params: {
        format: format,
        quality: quality,
        clip: clip,
        fromSurface: fromSurface,
        captureBeyondViewport: captureBeyondViewport,
        optimizeForSpeed: optimizeForSpeed,
      },
    })
  }
  async captureSnapshot(format?: string): Promise<Page.CaptureSnapshotResult> {
    return this.transport.call<Page.CaptureSnapshotResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.captureSnapshot',
      params: { format: format },
    })
  }
  async clearDeviceMetricsOverride(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.clearDeviceMetricsOverride',
      params: {},
    })
  }
  async clearDeviceOrientationOverride(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.clearDeviceOrientationOverride',
      params: {},
    })
  }
  async clearGeolocationOverride(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.clearGeolocationOverride',
      params: {},
    })
  }
  async createIsolatedWorld(
    frameId: Page.FrameId,
    worldName?: string,
    grantUniveralAccess?: boolean
  ): Promise<Page.CreateIsolatedWorldResult> {
    return this.transport.call<Page.CreateIsolatedWorldResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.createIsolatedWorld',
      params: {
        frameId: frameId,
        worldName: worldName,
        grantUniveralAccess: grantUniveralAccess,
      },
    })
  }
  async deleteCookie(cookieName: string, url: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.deleteCookie',
      params: { cookieName: cookieName, url: url },
    })
  }
  async disable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.disable',
      params: {},
    })
  }
  async enable(enableFileChooserOpenedEvent?: boolean): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.enable',
      params: { enableFileChooserOpenedEvent: enableFileChooserOpenedEvent },
    })
  }
  async getAppManifest(
    manifestId?: string
  ): Promise<Page.GetAppManifestResult> {
    return this.transport.call<Page.GetAppManifestResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.getAppManifest',
      params: { manifestId: manifestId },
    })
  }
  async getInstallabilityErrors(): Promise<Page.GetInstallabilityErrorsResult> {
    return this.transport.call<Page.GetInstallabilityErrorsResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.getInstallabilityErrors',
      params: {},
    })
  }
  async getManifestIcons(): Promise<Page.GetManifestIconsResult> {
    return this.transport.call<Page.GetManifestIconsResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.getManifestIcons',
      params: {},
    })
  }
  async getAppId(): Promise<Page.GetAppIdResult> {
    return this.transport.call<Page.GetAppIdResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.getAppId',
      params: {},
    })
  }
  async getAdScriptAncestry(
    frameId: Page.FrameId
  ): Promise<Page.GetAdScriptAncestryResult> {
    return this.transport.call<Page.GetAdScriptAncestryResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.getAdScriptAncestry',
      params: { frameId: frameId },
    })
  }
  async getFrameTree(): Promise<Page.GetFrameTreeResult> {
    return this.transport.call<Page.GetFrameTreeResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.getFrameTree',
      params: {},
    })
  }
  async getLayoutMetrics(): Promise<Page.GetLayoutMetricsResult> {
    return this.transport.call<Page.GetLayoutMetricsResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.getLayoutMetrics',
      params: {},
    })
  }
  async getNavigationHistory(): Promise<Page.GetNavigationHistoryResult> {
    return this.transport.call<Page.GetNavigationHistoryResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.getNavigationHistory',
      params: {},
    })
  }
  async resetNavigationHistory(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.resetNavigationHistory',
      params: {},
    })
  }
  async getResourceContent(
    frameId: Page.FrameId,
    url: string
  ): Promise<Page.GetResourceContentResult> {
    return this.transport.call<Page.GetResourceContentResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.getResourceContent',
      params: { frameId: frameId, url: url },
    })
  }
  async getResourceTree(): Promise<Page.GetResourceTreeResult> {
    return this.transport.call<Page.GetResourceTreeResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.getResourceTree',
      params: {},
    })
  }
  async handleJavaScriptDialog(
    accept: boolean,
    promptText?: string
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.handleJavaScriptDialog',
      params: { accept: accept, promptText: promptText },
    })
  }
  async navigate(
    url: string,
    referrer?: string,
    transitionType?: Page.TransitionType,
    frameId?: Page.FrameId,
    referrerPolicy?: Page.ReferrerPolicy
  ): Promise<Page.NavigateResult> {
    return this.transport.call<Page.NavigateResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.navigate',
      params: {
        url: url,
        referrer: referrer,
        transitionType: transitionType,
        frameId: frameId,
        referrerPolicy: referrerPolicy,
      },
    })
  }
  async navigateToHistoryEntry(entryId: number): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.navigateToHistoryEntry',
      params: { entryId: entryId },
    })
  }
  async printToPDF(
    landscape?: boolean,
    displayHeaderFooter?: boolean,
    printBackground?: boolean,
    scale?: number,
    paperWidth?: number,
    paperHeight?: number,
    marginTop?: number,
    marginBottom?: number,
    marginLeft?: number,
    marginRight?: number,
    pageRanges?: string,
    headerTemplate?: string,
    footerTemplate?: string,
    preferCSSPageSize?: boolean,
    transferMode?: string,
    generateTaggedPDF?: boolean,
    generateDocumentOutline?: boolean
  ): Promise<Page.PrintToPDFResult> {
    return this.transport.call<Page.PrintToPDFResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.printToPDF',
      params: {
        landscape: landscape,
        displayHeaderFooter: displayHeaderFooter,
        printBackground: printBackground,
        scale: scale,
        paperWidth: paperWidth,
        paperHeight: paperHeight,
        marginTop: marginTop,
        marginBottom: marginBottom,
        marginLeft: marginLeft,
        marginRight: marginRight,
        pageRanges: pageRanges,
        headerTemplate: headerTemplate,
        footerTemplate: footerTemplate,
        preferCSSPageSize: preferCSSPageSize,
        transferMode: transferMode,
        generateTaggedPDF: generateTaggedPDF,
        generateDocumentOutline: generateDocumentOutline,
      },
    })
  }
  async reload(
    ignoreCache?: boolean,
    scriptToEvaluateOnLoad?: string,
    loaderId?: Network.LoaderId
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.reload',
      params: {
        ignoreCache: ignoreCache,
        scriptToEvaluateOnLoad: scriptToEvaluateOnLoad,
        loaderId: loaderId,
      },
    })
  }
  async removeScriptToEvaluateOnLoad(
    identifier: Page.ScriptIdentifier
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.removeScriptToEvaluateOnLoad',
      params: { identifier: identifier },
    })
  }
  async removeScriptToEvaluateOnNewDocument(
    identifier: Page.ScriptIdentifier
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.removeScriptToEvaluateOnNewDocument',
      params: { identifier: identifier },
    })
  }
  async screencastFrameAck(sessionId: number): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.screencastFrameAck',
      params: { sessionId: sessionId },
    })
  }
  async searchInResource(
    frameId: Page.FrameId,
    url: string,
    query: string,
    caseSensitive?: boolean,
    isRegex?: boolean
  ): Promise<Page.SearchInResourceResult> {
    return this.transport.call<Page.SearchInResourceResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.searchInResource',
      params: {
        frameId: frameId,
        url: url,
        query: query,
        caseSensitive: caseSensitive,
        isRegex: isRegex,
      },
    })
  }
  async setAdBlockingEnabled(enabled: boolean): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.setAdBlockingEnabled',
      params: { enabled: enabled },
    })
  }
  async setBypassCSP(enabled: boolean): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.setBypassCSP',
      params: { enabled: enabled },
    })
  }
  async getPermissionsPolicyState(
    frameId: Page.FrameId
  ): Promise<Page.GetPermissionsPolicyStateResult> {
    return this.transport.call<Page.GetPermissionsPolicyStateResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.getPermissionsPolicyState',
      params: { frameId: frameId },
    })
  }
  async getOriginTrials(
    frameId: Page.FrameId
  ): Promise<Page.GetOriginTrialsResult> {
    return this.transport.call<Page.GetOriginTrialsResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.getOriginTrials',
      params: { frameId: frameId },
    })
  }
  async setDeviceMetricsOverride(
    width: number,
    height: number,
    deviceScaleFactor: number,
    mobile: boolean,
    scale?: number,
    screenWidth?: number,
    screenHeight?: number,
    positionX?: number,
    positionY?: number,
    dontSetVisibleSize?: boolean,
    screenOrientation?: Emulation.ScreenOrientation,
    viewport?: Page.Viewport
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.setDeviceMetricsOverride',
      params: {
        width: width,
        height: height,
        deviceScaleFactor: deviceScaleFactor,
        mobile: mobile,
        scale: scale,
        screenWidth: screenWidth,
        screenHeight: screenHeight,
        positionX: positionX,
        positionY: positionY,
        dontSetVisibleSize: dontSetVisibleSize,
        screenOrientation: screenOrientation,
        viewport: viewport,
      },
    })
  }
  async setDeviceOrientationOverride(
    alpha: number,
    beta: number,
    gamma: number
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.setDeviceOrientationOverride',
      params: { alpha: alpha, beta: beta, gamma: gamma },
    })
  }
  async setFontFamilies(
    fontFamilies: Page.FontFamilies,
    forScripts?: Page.ScriptFontFamilies[]
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.setFontFamilies',
      params: { fontFamilies: fontFamilies, forScripts: forScripts },
    })
  }
  async setFontSizes(fontSizes: Page.FontSizes): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.setFontSizes',
      params: { fontSizes: fontSizes },
    })
  }
  async setDocumentContent(frameId: Page.FrameId, html: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.setDocumentContent',
      params: { frameId: frameId, html: html },
    })
  }
  async setDownloadBehavior(
    behavior: string,
    downloadPath?: string
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.setDownloadBehavior',
      params: { behavior: behavior, downloadPath: downloadPath },
    })
  }
  async setGeolocationOverride(
    latitude?: number,
    longitude?: number,
    accuracy?: number
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.setGeolocationOverride',
      params: { latitude: latitude, longitude: longitude, accuracy: accuracy },
    })
  }
  async setLifecycleEventsEnabled(enabled: boolean): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.setLifecycleEventsEnabled',
      params: { enabled: enabled },
    })
  }
  async setTouchEmulationEnabled(
    enabled: boolean,
    configuration?: string
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.setTouchEmulationEnabled',
      params: { enabled: enabled, configuration: configuration },
    })
  }
  async startScreencast(
    format?: string,
    quality?: number,
    maxWidth?: number,
    maxHeight?: number,
    everyNthFrame?: number
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.startScreencast',
      params: {
        format: format,
        quality: quality,
        maxWidth: maxWidth,
        maxHeight: maxHeight,
        everyNthFrame: everyNthFrame,
      },
    })
  }
  async stopLoading(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.stopLoading',
      params: {},
    })
  }
  async crash(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.crash',
      params: {},
    })
  }
  async close(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.close',
      params: {},
    })
  }
  async setWebLifecycleState(state: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.setWebLifecycleState',
      params: { state: state },
    })
  }
  async stopScreencast(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.stopScreencast',
      params: {},
    })
  }
  async produceCompilationCache(
    scripts: Page.CompilationCacheParams[]
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.produceCompilationCache',
      params: { scripts: scripts },
    })
  }
  async addCompilationCache(url: string, data: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.addCompilationCache',
      params: { url: url, data: data },
    })
  }
  async clearCompilationCache(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.clearCompilationCache',
      params: {},
    })
  }
  async setSPCTransactionMode(mode: Page.AutoResponseMode): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.setSPCTransactionMode',
      params: { mode: mode },
    })
  }
  async setRPHRegistrationMode(mode: Page.AutoResponseMode): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.setRPHRegistrationMode',
      params: { mode: mode },
    })
  }
  async generateTestReport(message: string, group?: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.generateTestReport',
      params: { message: message, group: group },
    })
  }
  async waitForDebugger(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.waitForDebugger',
      params: {},
    })
  }
  async setInterceptFileChooserDialog(
    enabled: boolean,
    cancel?: boolean
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.setInterceptFileChooserDialog',
      params: { enabled: enabled, cancel: cancel },
    })
  }
  async setPrerenderingAllowed(isAllowed: boolean): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Page.setPrerenderingAllowed',
      params: { isAllowed: isAllowed },
    })
  }
  on<K extends keyof Page.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Page.EventMap[K]>) => void
  ): () => void {
    const filteredListener: typeof listener = (event) => {
      if (event.sessionId !== this.sessionId) {
        return
      }
      listener(event)
    }
    this.listeners.set(
      listener as ChromeEventListener,
      filteredListener as ChromeEventListener
    )
    return this.transport.on(name, filteredListener as ChromeEventListener)
  }
  off<K extends keyof Page.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Page.EventMap[K]>) => void
  ): void {
    const filteredListener = this.listeners.get(listener as ChromeEventListener)
    if (filteredListener === undefined) {
      return
    }
    this.listeners.delete(listener as ChromeEventListener)
    return this.transport.off(name, filteredListener)
  }
}
class PerformanceClient {
  private transport: Transport
  private sessionId: Target.SessionID | undefined
  private listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  async disable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Performance.disable',
      params: {},
    })
  }
  async enable(timeDomain?: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Performance.enable',
      params: { timeDomain: timeDomain },
    })
  }
  async setTimeDomain(timeDomain: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Performance.setTimeDomain',
      params: { timeDomain: timeDomain },
    })
  }
  async getMetrics(): Promise<Performance.GetMetricsResult> {
    return this.transport.call<Performance.GetMetricsResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Performance.getMetrics',
      params: {},
    })
  }
  on<K extends keyof Performance.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Performance.EventMap[K]>) => void
  ): () => void {
    const filteredListener: typeof listener = (event) => {
      if (event.sessionId !== this.sessionId) {
        return
      }
      listener(event)
    }
    this.listeners.set(
      listener as ChromeEventListener,
      filteredListener as ChromeEventListener
    )
    return this.transport.on(name, filteredListener as ChromeEventListener)
  }
  off<K extends keyof Performance.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Performance.EventMap[K]>) => void
  ): void {
    const filteredListener = this.listeners.get(listener as ChromeEventListener)
    if (filteredListener === undefined) {
      return
    }
    this.listeners.delete(listener as ChromeEventListener)
    return this.transport.off(name, filteredListener)
  }
}
class PerformanceTimelineClient {
  private transport: Transport
  private sessionId: Target.SessionID | undefined
  private listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  async enable(eventTypes: string[]): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'PerformanceTimeline.enable',
      params: { eventTypes: eventTypes },
    })
  }
  on<K extends keyof PerformanceTimeline.EventMap>(
    name: K,
    listener: (event: ChromeEvent<PerformanceTimeline.EventMap[K]>) => void
  ): () => void {
    const filteredListener: typeof listener = (event) => {
      if (event.sessionId !== this.sessionId) {
        return
      }
      listener(event)
    }
    this.listeners.set(
      listener as ChromeEventListener,
      filteredListener as ChromeEventListener
    )
    return this.transport.on(name, filteredListener as ChromeEventListener)
  }
  off<K extends keyof PerformanceTimeline.EventMap>(
    name: K,
    listener: (event: ChromeEvent<PerformanceTimeline.EventMap[K]>) => void
  ): void {
    const filteredListener = this.listeners.get(listener as ChromeEventListener)
    if (filteredListener === undefined) {
      return
    }
    this.listeners.delete(listener as ChromeEventListener)
    return this.transport.off(name, filteredListener)
  }
}
class SecurityClient {
  private transport: Transport
  private sessionId: Target.SessionID | undefined
  private listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  async disable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Security.disable',
      params: {},
    })
  }
  async enable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Security.enable',
      params: {},
    })
  }
  async setIgnoreCertificateErrors(ignore: boolean): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Security.setIgnoreCertificateErrors',
      params: { ignore: ignore },
    })
  }
  async handleCertificateError(
    eventId: number,
    action: Security.CertificateErrorAction
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Security.handleCertificateError',
      params: { eventId: eventId, action: action },
    })
  }
  async setOverrideCertificateErrors(override: boolean): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Security.setOverrideCertificateErrors',
      params: { override: override },
    })
  }
  on<K extends keyof Security.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Security.EventMap[K]>) => void
  ): () => void {
    const filteredListener: typeof listener = (event) => {
      if (event.sessionId !== this.sessionId) {
        return
      }
      listener(event)
    }
    this.listeners.set(
      listener as ChromeEventListener,
      filteredListener as ChromeEventListener
    )
    return this.transport.on(name, filteredListener as ChromeEventListener)
  }
  off<K extends keyof Security.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Security.EventMap[K]>) => void
  ): void {
    const filteredListener = this.listeners.get(listener as ChromeEventListener)
    if (filteredListener === undefined) {
      return
    }
    this.listeners.delete(listener as ChromeEventListener)
    return this.transport.off(name, filteredListener)
  }
}
class ServiceWorkerClient {
  private transport: Transport
  private sessionId: Target.SessionID | undefined
  private listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  async deliverPushMessage(
    origin: string,
    registrationId: ServiceWorker.RegistrationID,
    data: string
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'ServiceWorker.deliverPushMessage',
      params: { origin: origin, registrationId: registrationId, data: data },
    })
  }
  async disable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'ServiceWorker.disable',
      params: {},
    })
  }
  async dispatchSyncEvent(
    origin: string,
    registrationId: ServiceWorker.RegistrationID,
    tag: string,
    lastChance: boolean
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'ServiceWorker.dispatchSyncEvent',
      params: {
        origin: origin,
        registrationId: registrationId,
        tag: tag,
        lastChance: lastChance,
      },
    })
  }
  async dispatchPeriodicSyncEvent(
    origin: string,
    registrationId: ServiceWorker.RegistrationID,
    tag: string
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'ServiceWorker.dispatchPeriodicSyncEvent',
      params: { origin: origin, registrationId: registrationId, tag: tag },
    })
  }
  async enable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'ServiceWorker.enable',
      params: {},
    })
  }
  async inspectWorker(versionId: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'ServiceWorker.inspectWorker',
      params: { versionId: versionId },
    })
  }
  async setForceUpdateOnPageLoad(
    forceUpdateOnPageLoad: boolean
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'ServiceWorker.setForceUpdateOnPageLoad',
      params: { forceUpdateOnPageLoad: forceUpdateOnPageLoad },
    })
  }
  async skipWaiting(scopeURL: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'ServiceWorker.skipWaiting',
      params: { scopeURL: scopeURL },
    })
  }
  async startWorker(scopeURL: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'ServiceWorker.startWorker',
      params: { scopeURL: scopeURL },
    })
  }
  async stopAllWorkers(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'ServiceWorker.stopAllWorkers',
      params: {},
    })
  }
  async stopWorker(versionId: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'ServiceWorker.stopWorker',
      params: { versionId: versionId },
    })
  }
  async unregister(scopeURL: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'ServiceWorker.unregister',
      params: { scopeURL: scopeURL },
    })
  }
  async updateRegistration(scopeURL: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'ServiceWorker.updateRegistration',
      params: { scopeURL: scopeURL },
    })
  }
  on<K extends keyof ServiceWorker.EventMap>(
    name: K,
    listener: (event: ChromeEvent<ServiceWorker.EventMap[K]>) => void
  ): () => void {
    const filteredListener: typeof listener = (event) => {
      if (event.sessionId !== this.sessionId) {
        return
      }
      listener(event)
    }
    this.listeners.set(
      listener as ChromeEventListener,
      filteredListener as ChromeEventListener
    )
    return this.transport.on(name, filteredListener as ChromeEventListener)
  }
  off<K extends keyof ServiceWorker.EventMap>(
    name: K,
    listener: (event: ChromeEvent<ServiceWorker.EventMap[K]>) => void
  ): void {
    const filteredListener = this.listeners.get(listener as ChromeEventListener)
    if (filteredListener === undefined) {
      return
    }
    this.listeners.delete(listener as ChromeEventListener)
    return this.transport.off(name, filteredListener)
  }
}
class StorageClient {
  private transport: Transport
  private sessionId: Target.SessionID | undefined
  private listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  async getStorageKeyForFrame(
    frameId: Page.FrameId
  ): Promise<Storage.GetStorageKeyForFrameResult> {
    return this.transport.call<Storage.GetStorageKeyForFrameResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Storage.getStorageKeyForFrame',
      params: { frameId: frameId },
    })
  }
  async clearDataForOrigin(
    origin: string,
    storageTypes: string
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Storage.clearDataForOrigin',
      params: { origin: origin, storageTypes: storageTypes },
    })
  }
  async clearDataForStorageKey(
    storageKey: string,
    storageTypes: string
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Storage.clearDataForStorageKey',
      params: { storageKey: storageKey, storageTypes: storageTypes },
    })
  }
  async getCookies(
    browserContextId?: Browser.BrowserContextID
  ): Promise<Storage.GetCookiesResult> {
    return this.transport.call<Storage.GetCookiesResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Storage.getCookies',
      params: { browserContextId: browserContextId },
    })
  }
  async setCookies(
    cookies: Network.CookieParam[],
    browserContextId?: Browser.BrowserContextID
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Storage.setCookies',
      params: { cookies: cookies, browserContextId: browserContextId },
    })
  }
  async clearCookies(
    browserContextId?: Browser.BrowserContextID
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Storage.clearCookies',
      params: { browserContextId: browserContextId },
    })
  }
  async getUsageAndQuota(
    origin: string
  ): Promise<Storage.GetUsageAndQuotaResult> {
    return this.transport.call<Storage.GetUsageAndQuotaResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Storage.getUsageAndQuota',
      params: { origin: origin },
    })
  }
  async overrideQuotaForOrigin(
    origin: string,
    quotaSize?: number
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Storage.overrideQuotaForOrigin',
      params: { origin: origin, quotaSize: quotaSize },
    })
  }
  async trackCacheStorageForOrigin(origin: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Storage.trackCacheStorageForOrigin',
      params: { origin: origin },
    })
  }
  async trackCacheStorageForStorageKey(storageKey: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Storage.trackCacheStorageForStorageKey',
      params: { storageKey: storageKey },
    })
  }
  async trackIndexedDBForOrigin(origin: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Storage.trackIndexedDBForOrigin',
      params: { origin: origin },
    })
  }
  async trackIndexedDBForStorageKey(storageKey: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Storage.trackIndexedDBForStorageKey',
      params: { storageKey: storageKey },
    })
  }
  async untrackCacheStorageForOrigin(origin: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Storage.untrackCacheStorageForOrigin',
      params: { origin: origin },
    })
  }
  async untrackCacheStorageForStorageKey(storageKey: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Storage.untrackCacheStorageForStorageKey',
      params: { storageKey: storageKey },
    })
  }
  async untrackIndexedDBForOrigin(origin: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Storage.untrackIndexedDBForOrigin',
      params: { origin: origin },
    })
  }
  async untrackIndexedDBForStorageKey(storageKey: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Storage.untrackIndexedDBForStorageKey',
      params: { storageKey: storageKey },
    })
  }
  async getTrustTokens(): Promise<Storage.GetTrustTokensResult> {
    return this.transport.call<Storage.GetTrustTokensResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Storage.getTrustTokens',
      params: {},
    })
  }
  async clearTrustTokens(
    issuerOrigin: string
  ): Promise<Storage.ClearTrustTokensResult> {
    return this.transport.call<Storage.ClearTrustTokensResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Storage.clearTrustTokens',
      params: { issuerOrigin: issuerOrigin },
    })
  }
  async getInterestGroupDetails(
    ownerOrigin: string,
    name: string
  ): Promise<Storage.GetInterestGroupDetailsResult> {
    return this.transport.call<Storage.GetInterestGroupDetailsResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Storage.getInterestGroupDetails',
      params: { ownerOrigin: ownerOrigin, name: name },
    })
  }
  async setInterestGroupTracking(enable: boolean): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Storage.setInterestGroupTracking',
      params: { enable: enable },
    })
  }
  async setInterestGroupAuctionTracking(enable: boolean): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Storage.setInterestGroupAuctionTracking',
      params: { enable: enable },
    })
  }
  async getSharedStorageMetadata(
    ownerOrigin: string
  ): Promise<Storage.GetSharedStorageMetadataResult> {
    return this.transport.call<Storage.GetSharedStorageMetadataResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Storage.getSharedStorageMetadata',
      params: { ownerOrigin: ownerOrigin },
    })
  }
  async getSharedStorageEntries(
    ownerOrigin: string
  ): Promise<Storage.GetSharedStorageEntriesResult> {
    return this.transport.call<Storage.GetSharedStorageEntriesResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Storage.getSharedStorageEntries',
      params: { ownerOrigin: ownerOrigin },
    })
  }
  async setSharedStorageEntry(
    ownerOrigin: string,
    key: string,
    value: string,
    ignoreIfPresent?: boolean
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Storage.setSharedStorageEntry',
      params: {
        ownerOrigin: ownerOrigin,
        key: key,
        value: value,
        ignoreIfPresent: ignoreIfPresent,
      },
    })
  }
  async deleteSharedStorageEntry(
    ownerOrigin: string,
    key: string
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Storage.deleteSharedStorageEntry',
      params: { ownerOrigin: ownerOrigin, key: key },
    })
  }
  async clearSharedStorageEntries(ownerOrigin: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Storage.clearSharedStorageEntries',
      params: { ownerOrigin: ownerOrigin },
    })
  }
  async resetSharedStorageBudget(ownerOrigin: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Storage.resetSharedStorageBudget',
      params: { ownerOrigin: ownerOrigin },
    })
  }
  async setSharedStorageTracking(enable: boolean): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Storage.setSharedStorageTracking',
      params: { enable: enable },
    })
  }
  async setStorageBucketTracking(
    storageKey: string,
    enable: boolean
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Storage.setStorageBucketTracking',
      params: { storageKey: storageKey, enable: enable },
    })
  }
  async deleteStorageBucket(bucket: Storage.StorageBucket): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Storage.deleteStorageBucket',
      params: { bucket: bucket },
    })
  }
  async runBounceTrackingMitigations(): Promise<Storage.RunBounceTrackingMitigationsResult> {
    return this.transport.call<Storage.RunBounceTrackingMitigationsResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Storage.runBounceTrackingMitigations',
      params: {},
    })
  }
  async setAttributionReportingLocalTestingMode(
    enabled: boolean
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Storage.setAttributionReportingLocalTestingMode',
      params: { enabled: enabled },
    })
  }
  async setAttributionReportingTracking(enable: boolean): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Storage.setAttributionReportingTracking',
      params: { enable: enable },
    })
  }
  async sendPendingAttributionReports(): Promise<Storage.SendPendingAttributionReportsResult> {
    return this.transport.call<Storage.SendPendingAttributionReportsResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Storage.sendPendingAttributionReports',
      params: {},
    })
  }
  async getRelatedWebsiteSets(): Promise<Storage.GetRelatedWebsiteSetsResult> {
    return this.transport.call<Storage.GetRelatedWebsiteSetsResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Storage.getRelatedWebsiteSets',
      params: {},
    })
  }
  async getAffectedUrlsForThirdPartyCookieMetadata(
    firstPartyUrl: string,
    thirdPartyUrls: string[]
  ): Promise<Storage.GetAffectedUrlsForThirdPartyCookieMetadataResult> {
    return this.transport.call<Storage.GetAffectedUrlsForThirdPartyCookieMetadataResult>(
      {
        id: generateId(),
        sessionId: this.sessionId,
        method: 'Storage.getAffectedUrlsForThirdPartyCookieMetadata',
        params: {
          firstPartyUrl: firstPartyUrl,
          thirdPartyUrls: thirdPartyUrls,
        },
      }
    )
  }
  async setProtectedAudienceKAnonymity(
    owner: string,
    name: string,
    hashes: string[]
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Storage.setProtectedAudienceKAnonymity',
      params: { owner: owner, name: name, hashes: hashes },
    })
  }
  on<K extends keyof Storage.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Storage.EventMap[K]>) => void
  ): () => void {
    const filteredListener: typeof listener = (event) => {
      if (event.sessionId !== this.sessionId) {
        return
      }
      listener(event)
    }
    this.listeners.set(
      listener as ChromeEventListener,
      filteredListener as ChromeEventListener
    )
    return this.transport.on(name, filteredListener as ChromeEventListener)
  }
  off<K extends keyof Storage.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Storage.EventMap[K]>) => void
  ): void {
    const filteredListener = this.listeners.get(listener as ChromeEventListener)
    if (filteredListener === undefined) {
      return
    }
    this.listeners.delete(listener as ChromeEventListener)
    return this.transport.off(name, filteredListener)
  }
}
class SystemInfoClient {
  private transport: Transport
  private sessionId: Target.SessionID | undefined
  private listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  async getInfo(): Promise<SystemInfo.GetInfoResult> {
    return this.transport.call<SystemInfo.GetInfoResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'SystemInfo.getInfo',
      params: {},
    })
  }
  async getFeatureState(
    featureState: string
  ): Promise<SystemInfo.GetFeatureStateResult> {
    return this.transport.call<SystemInfo.GetFeatureStateResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'SystemInfo.getFeatureState',
      params: { featureState: featureState },
    })
  }
  async getProcessInfo(): Promise<SystemInfo.GetProcessInfoResult> {
    return this.transport.call<SystemInfo.GetProcessInfoResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'SystemInfo.getProcessInfo',
      params: {},
    })
  }
}
class TargetClient {
  private transport: Transport
  private sessionId: Target.SessionID | undefined
  private listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  async activateTarget(targetId: Target.TargetID): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Target.activateTarget',
      params: { targetId: targetId },
    })
  }
  async attachToTarget(
    targetId: Target.TargetID,
    flatten?: boolean
  ): Promise<Target.AttachToTargetResult> {
    return this.transport.call<Target.AttachToTargetResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Target.attachToTarget',
      params: { targetId: targetId, flatten: flatten },
    })
  }
  async attachToBrowserTarget(): Promise<Target.AttachToBrowserTargetResult> {
    return this.transport.call<Target.AttachToBrowserTargetResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Target.attachToBrowserTarget',
      params: {},
    })
  }
  async closeTarget(
    targetId: Target.TargetID
  ): Promise<Target.CloseTargetResult> {
    return this.transport.call<Target.CloseTargetResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Target.closeTarget',
      params: { targetId: targetId },
    })
  }
  async exposeDevToolsProtocol(
    targetId: Target.TargetID,
    bindingName?: string,
    inheritPermissions?: boolean
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Target.exposeDevToolsProtocol',
      params: {
        targetId: targetId,
        bindingName: bindingName,
        inheritPermissions: inheritPermissions,
      },
    })
  }
  async createBrowserContext(
    disposeOnDetach?: boolean,
    proxyServer?: string,
    proxyBypassList?: string,
    originsWithUniversalNetworkAccess?: string[]
  ): Promise<Target.CreateBrowserContextResult> {
    return this.transport.call<Target.CreateBrowserContextResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Target.createBrowserContext',
      params: {
        disposeOnDetach: disposeOnDetach,
        proxyServer: proxyServer,
        proxyBypassList: proxyBypassList,
        originsWithUniversalNetworkAccess: originsWithUniversalNetworkAccess,
      },
    })
  }
  async getBrowserContexts(): Promise<Target.GetBrowserContextsResult> {
    return this.transport.call<Target.GetBrowserContextsResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Target.getBrowserContexts',
      params: {},
    })
  }
  async createTarget(
    url: string,
    left?: number,
    top?: number,
    width?: number,
    height?: number,
    windowState?: Target.WindowState,
    browserContextId?: Browser.BrowserContextID,
    enableBeginFrameControl?: boolean,
    newWindow?: boolean,
    background?: boolean,
    forTab?: boolean,
    hidden?: boolean
  ): Promise<Target.CreateTargetResult> {
    return this.transport.call<Target.CreateTargetResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Target.createTarget',
      params: {
        url: url,
        left: left,
        top: top,
        width: width,
        height: height,
        windowState: windowState,
        browserContextId: browserContextId,
        enableBeginFrameControl: enableBeginFrameControl,
        newWindow: newWindow,
        background: background,
        forTab: forTab,
        hidden: hidden,
      },
    })
  }
  async detachFromTarget(
    sessionId?: Target.SessionID,
    targetId?: Target.TargetID
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Target.detachFromTarget',
      params: { sessionId: sessionId, targetId: targetId },
    })
  }
  async disposeBrowserContext(
    browserContextId: Browser.BrowserContextID
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Target.disposeBrowserContext',
      params: { browserContextId: browserContextId },
    })
  }
  async getTargetInfo(
    targetId?: Target.TargetID
  ): Promise<Target.GetTargetInfoResult> {
    return this.transport.call<Target.GetTargetInfoResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Target.getTargetInfo',
      params: { targetId: targetId },
    })
  }
  async getTargets(
    filter?: Target.TargetFilter
  ): Promise<Target.GetTargetsResult> {
    return this.transport.call<Target.GetTargetsResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Target.getTargets',
      params: { filter: filter },
    })
  }
  async sendMessageToTarget(
    message: string,
    sessionId?: Target.SessionID,
    targetId?: Target.TargetID
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Target.sendMessageToTarget',
      params: { message: message, sessionId: sessionId, targetId: targetId },
    })
  }
  async setAutoAttach(
    autoAttach: boolean,
    waitForDebuggerOnStart: boolean,
    flatten?: boolean,
    filter?: Target.TargetFilter
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Target.setAutoAttach',
      params: {
        autoAttach: autoAttach,
        waitForDebuggerOnStart: waitForDebuggerOnStart,
        flatten: flatten,
        filter: filter,
      },
    })
  }
  async autoAttachRelated(
    targetId: Target.TargetID,
    waitForDebuggerOnStart: boolean,
    filter?: Target.TargetFilter
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Target.autoAttachRelated',
      params: {
        targetId: targetId,
        waitForDebuggerOnStart: waitForDebuggerOnStart,
        filter: filter,
      },
    })
  }
  async setDiscoverTargets(
    discover: boolean,
    filter?: Target.TargetFilter
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Target.setDiscoverTargets',
      params: { discover: discover, filter: filter },
    })
  }
  async setRemoteLocations(locations: Target.RemoteLocation[]): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Target.setRemoteLocations',
      params: { locations: locations },
    })
  }
  on<K extends keyof Target.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Target.EventMap[K]>) => void
  ): () => void {
    const filteredListener: typeof listener = (event) => {
      if (event.sessionId !== this.sessionId) {
        return
      }
      listener(event)
    }
    this.listeners.set(
      listener as ChromeEventListener,
      filteredListener as ChromeEventListener
    )
    return this.transport.on(name, filteredListener as ChromeEventListener)
  }
  off<K extends keyof Target.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Target.EventMap[K]>) => void
  ): void {
    const filteredListener = this.listeners.get(listener as ChromeEventListener)
    if (filteredListener === undefined) {
      return
    }
    this.listeners.delete(listener as ChromeEventListener)
    return this.transport.off(name, filteredListener)
  }
}
class TetheringClient {
  private transport: Transport
  private sessionId: Target.SessionID | undefined
  private listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  async bind(port: number): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Tethering.bind',
      params: { port: port },
    })
  }
  async unbind(port: number): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Tethering.unbind',
      params: { port: port },
    })
  }
  on<K extends keyof Tethering.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Tethering.EventMap[K]>) => void
  ): () => void {
    const filteredListener: typeof listener = (event) => {
      if (event.sessionId !== this.sessionId) {
        return
      }
      listener(event)
    }
    this.listeners.set(
      listener as ChromeEventListener,
      filteredListener as ChromeEventListener
    )
    return this.transport.on(name, filteredListener as ChromeEventListener)
  }
  off<K extends keyof Tethering.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Tethering.EventMap[K]>) => void
  ): void {
    const filteredListener = this.listeners.get(listener as ChromeEventListener)
    if (filteredListener === undefined) {
      return
    }
    this.listeners.delete(listener as ChromeEventListener)
    return this.transport.off(name, filteredListener)
  }
}
class TracingClient {
  private transport: Transport
  private sessionId: Target.SessionID | undefined
  private listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  async end(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Tracing.end',
      params: {},
    })
  }
  async getCategories(): Promise<Tracing.GetCategoriesResult> {
    return this.transport.call<Tracing.GetCategoriesResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Tracing.getCategories',
      params: {},
    })
  }
  async recordClockSyncMarker(syncId: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Tracing.recordClockSyncMarker',
      params: { syncId: syncId },
    })
  }
  async requestMemoryDump(
    deterministic?: boolean,
    levelOfDetail?: Tracing.MemoryDumpLevelOfDetail
  ): Promise<Tracing.RequestMemoryDumpResult> {
    return this.transport.call<Tracing.RequestMemoryDumpResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Tracing.requestMemoryDump',
      params: { deterministic: deterministic, levelOfDetail: levelOfDetail },
    })
  }
  async start(
    categories?: string,
    options?: string,
    bufferUsageReportingInterval?: number,
    transferMode?: string,
    streamFormat?: Tracing.StreamFormat,
    streamCompression?: Tracing.StreamCompression,
    traceConfig?: Tracing.TraceConfig,
    perfettoConfig?: string,
    tracingBackend?: Tracing.TracingBackend
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Tracing.start',
      params: {
        categories: categories,
        options: options,
        bufferUsageReportingInterval: bufferUsageReportingInterval,
        transferMode: transferMode,
        streamFormat: streamFormat,
        streamCompression: streamCompression,
        traceConfig: traceConfig,
        perfettoConfig: perfettoConfig,
        tracingBackend: tracingBackend,
      },
    })
  }
  on<K extends keyof Tracing.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Tracing.EventMap[K]>) => void
  ): () => void {
    const filteredListener: typeof listener = (event) => {
      if (event.sessionId !== this.sessionId) {
        return
      }
      listener(event)
    }
    this.listeners.set(
      listener as ChromeEventListener,
      filteredListener as ChromeEventListener
    )
    return this.transport.on(name, filteredListener as ChromeEventListener)
  }
  off<K extends keyof Tracing.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Tracing.EventMap[K]>) => void
  ): void {
    const filteredListener = this.listeners.get(listener as ChromeEventListener)
    if (filteredListener === undefined) {
      return
    }
    this.listeners.delete(listener as ChromeEventListener)
    return this.transport.off(name, filteredListener)
  }
}
class FetchClient {
  private transport: Transport
  private sessionId: Target.SessionID | undefined
  private listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  async disable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Fetch.disable',
      params: {},
    })
  }
  async enable(
    patterns?: Fetch.RequestPattern[],
    handleAuthRequests?: boolean
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Fetch.enable',
      params: { patterns: patterns, handleAuthRequests: handleAuthRequests },
    })
  }
  async failRequest(
    requestId: Fetch.RequestId,
    errorReason: Network.ErrorReason
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Fetch.failRequest',
      params: { requestId: requestId, errorReason: errorReason },
    })
  }
  async fulfillRequest(
    requestId: Fetch.RequestId,
    responseCode: number,
    responseHeaders?: Fetch.HeaderEntry[],
    binaryResponseHeaders?: string,
    body?: string,
    responsePhrase?: string
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Fetch.fulfillRequest',
      params: {
        requestId: requestId,
        responseCode: responseCode,
        responseHeaders: responseHeaders,
        binaryResponseHeaders: binaryResponseHeaders,
        body: body,
        responsePhrase: responsePhrase,
      },
    })
  }
  async continueRequest(
    requestId: Fetch.RequestId,
    url?: string,
    method?: string,
    postData?: string,
    headers?: Fetch.HeaderEntry[],
    interceptResponse?: boolean
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Fetch.continueRequest',
      params: {
        requestId: requestId,
        url: url,
        method: method,
        postData: postData,
        headers: headers,
        interceptResponse: interceptResponse,
      },
    })
  }
  async continueWithAuth(
    requestId: Fetch.RequestId,
    authChallengeResponse: Fetch.AuthChallengeResponse
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Fetch.continueWithAuth',
      params: {
        requestId: requestId,
        authChallengeResponse: authChallengeResponse,
      },
    })
  }
  async continueResponse(
    requestId: Fetch.RequestId,
    responseCode?: number,
    responsePhrase?: string,
    responseHeaders?: Fetch.HeaderEntry[],
    binaryResponseHeaders?: string
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Fetch.continueResponse',
      params: {
        requestId: requestId,
        responseCode: responseCode,
        responsePhrase: responsePhrase,
        responseHeaders: responseHeaders,
        binaryResponseHeaders: binaryResponseHeaders,
      },
    })
  }
  async getResponseBody(
    requestId: Fetch.RequestId
  ): Promise<Fetch.GetResponseBodyResult> {
    return this.transport.call<Fetch.GetResponseBodyResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Fetch.getResponseBody',
      params: { requestId: requestId },
    })
  }
  async takeResponseBodyAsStream(
    requestId: Fetch.RequestId
  ): Promise<Fetch.TakeResponseBodyAsStreamResult> {
    return this.transport.call<Fetch.TakeResponseBodyAsStreamResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Fetch.takeResponseBodyAsStream',
      params: { requestId: requestId },
    })
  }
  on<K extends keyof Fetch.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Fetch.EventMap[K]>) => void
  ): () => void {
    const filteredListener: typeof listener = (event) => {
      if (event.sessionId !== this.sessionId) {
        return
      }
      listener(event)
    }
    this.listeners.set(
      listener as ChromeEventListener,
      filteredListener as ChromeEventListener
    )
    return this.transport.on(name, filteredListener as ChromeEventListener)
  }
  off<K extends keyof Fetch.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Fetch.EventMap[K]>) => void
  ): void {
    const filteredListener = this.listeners.get(listener as ChromeEventListener)
    if (filteredListener === undefined) {
      return
    }
    this.listeners.delete(listener as ChromeEventListener)
    return this.transport.off(name, filteredListener)
  }
}
class WebAudioClient {
  private transport: Transport
  private sessionId: Target.SessionID | undefined
  private listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  async enable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'WebAudio.enable',
      params: {},
    })
  }
  async disable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'WebAudio.disable',
      params: {},
    })
  }
  async getRealtimeData(
    contextId: WebAudio.GraphObjectId
  ): Promise<WebAudio.GetRealtimeDataResult> {
    return this.transport.call<WebAudio.GetRealtimeDataResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'WebAudio.getRealtimeData',
      params: { contextId: contextId },
    })
  }
  on<K extends keyof WebAudio.EventMap>(
    name: K,
    listener: (event: ChromeEvent<WebAudio.EventMap[K]>) => void
  ): () => void {
    const filteredListener: typeof listener = (event) => {
      if (event.sessionId !== this.sessionId) {
        return
      }
      listener(event)
    }
    this.listeners.set(
      listener as ChromeEventListener,
      filteredListener as ChromeEventListener
    )
    return this.transport.on(name, filteredListener as ChromeEventListener)
  }
  off<K extends keyof WebAudio.EventMap>(
    name: K,
    listener: (event: ChromeEvent<WebAudio.EventMap[K]>) => void
  ): void {
    const filteredListener = this.listeners.get(listener as ChromeEventListener)
    if (filteredListener === undefined) {
      return
    }
    this.listeners.delete(listener as ChromeEventListener)
    return this.transport.off(name, filteredListener)
  }
}
class WebAuthnClient {
  private transport: Transport
  private sessionId: Target.SessionID | undefined
  private listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  async enable(enableUI?: boolean): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'WebAuthn.enable',
      params: { enableUI: enableUI },
    })
  }
  async disable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'WebAuthn.disable',
      params: {},
    })
  }
  async addVirtualAuthenticator(
    options: WebAuthn.VirtualAuthenticatorOptions
  ): Promise<WebAuthn.AddVirtualAuthenticatorResult> {
    return this.transport.call<WebAuthn.AddVirtualAuthenticatorResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'WebAuthn.addVirtualAuthenticator',
      params: { options: options },
    })
  }
  async setResponseOverrideBits(
    authenticatorId: WebAuthn.AuthenticatorId,
    isBogusSignature?: boolean,
    isBadUV?: boolean,
    isBadUP?: boolean
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'WebAuthn.setResponseOverrideBits',
      params: {
        authenticatorId: authenticatorId,
        isBogusSignature: isBogusSignature,
        isBadUV: isBadUV,
        isBadUP: isBadUP,
      },
    })
  }
  async removeVirtualAuthenticator(
    authenticatorId: WebAuthn.AuthenticatorId
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'WebAuthn.removeVirtualAuthenticator',
      params: { authenticatorId: authenticatorId },
    })
  }
  async addCredential(
    authenticatorId: WebAuthn.AuthenticatorId,
    credential: WebAuthn.Credential
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'WebAuthn.addCredential',
      params: { authenticatorId: authenticatorId, credential: credential },
    })
  }
  async getCredential(
    authenticatorId: WebAuthn.AuthenticatorId,
    credentialId: string
  ): Promise<WebAuthn.GetCredentialResult> {
    return this.transport.call<WebAuthn.GetCredentialResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'WebAuthn.getCredential',
      params: { authenticatorId: authenticatorId, credentialId: credentialId },
    })
  }
  async getCredentials(
    authenticatorId: WebAuthn.AuthenticatorId
  ): Promise<WebAuthn.GetCredentialsResult> {
    return this.transport.call<WebAuthn.GetCredentialsResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'WebAuthn.getCredentials',
      params: { authenticatorId: authenticatorId },
    })
  }
  async removeCredential(
    authenticatorId: WebAuthn.AuthenticatorId,
    credentialId: string
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'WebAuthn.removeCredential',
      params: { authenticatorId: authenticatorId, credentialId: credentialId },
    })
  }
  async clearCredentials(
    authenticatorId: WebAuthn.AuthenticatorId
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'WebAuthn.clearCredentials',
      params: { authenticatorId: authenticatorId },
    })
  }
  async setUserVerified(
    authenticatorId: WebAuthn.AuthenticatorId,
    isUserVerified: boolean
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'WebAuthn.setUserVerified',
      params: {
        authenticatorId: authenticatorId,
        isUserVerified: isUserVerified,
      },
    })
  }
  async setAutomaticPresenceSimulation(
    authenticatorId: WebAuthn.AuthenticatorId,
    enabled: boolean
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'WebAuthn.setAutomaticPresenceSimulation',
      params: { authenticatorId: authenticatorId, enabled: enabled },
    })
  }
  async setCredentialProperties(
    authenticatorId: WebAuthn.AuthenticatorId,
    credentialId: string,
    backupEligibility?: boolean,
    backupState?: boolean
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'WebAuthn.setCredentialProperties',
      params: {
        authenticatorId: authenticatorId,
        credentialId: credentialId,
        backupEligibility: backupEligibility,
        backupState: backupState,
      },
    })
  }
  on<K extends keyof WebAuthn.EventMap>(
    name: K,
    listener: (event: ChromeEvent<WebAuthn.EventMap[K]>) => void
  ): () => void {
    const filteredListener: typeof listener = (event) => {
      if (event.sessionId !== this.sessionId) {
        return
      }
      listener(event)
    }
    this.listeners.set(
      listener as ChromeEventListener,
      filteredListener as ChromeEventListener
    )
    return this.transport.on(name, filteredListener as ChromeEventListener)
  }
  off<K extends keyof WebAuthn.EventMap>(
    name: K,
    listener: (event: ChromeEvent<WebAuthn.EventMap[K]>) => void
  ): void {
    const filteredListener = this.listeners.get(listener as ChromeEventListener)
    if (filteredListener === undefined) {
      return
    }
    this.listeners.delete(listener as ChromeEventListener)
    return this.transport.off(name, filteredListener)
  }
}
class MediaClient {
  private transport: Transport
  private sessionId: Target.SessionID | undefined
  private listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  async enable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Media.enable',
      params: {},
    })
  }
  async disable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Media.disable',
      params: {},
    })
  }
  on<K extends keyof Media.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Media.EventMap[K]>) => void
  ): () => void {
    const filteredListener: typeof listener = (event) => {
      if (event.sessionId !== this.sessionId) {
        return
      }
      listener(event)
    }
    this.listeners.set(
      listener as ChromeEventListener,
      filteredListener as ChromeEventListener
    )
    return this.transport.on(name, filteredListener as ChromeEventListener)
  }
  off<K extends keyof Media.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Media.EventMap[K]>) => void
  ): void {
    const filteredListener = this.listeners.get(listener as ChromeEventListener)
    if (filteredListener === undefined) {
      return
    }
    this.listeners.delete(listener as ChromeEventListener)
    return this.transport.off(name, filteredListener)
  }
}
class DeviceAccessClient {
  private transport: Transport
  private sessionId: Target.SessionID | undefined
  private listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  async enable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DeviceAccess.enable',
      params: {},
    })
  }
  async disable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DeviceAccess.disable',
      params: {},
    })
  }
  async selectPrompt(
    id: DeviceAccess.RequestId,
    deviceId: DeviceAccess.DeviceId
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DeviceAccess.selectPrompt',
      params: { id: id, deviceId: deviceId },
    })
  }
  async cancelPrompt(id: DeviceAccess.RequestId): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'DeviceAccess.cancelPrompt',
      params: { id: id },
    })
  }
  on<K extends keyof DeviceAccess.EventMap>(
    name: K,
    listener: (event: ChromeEvent<DeviceAccess.EventMap[K]>) => void
  ): () => void {
    const filteredListener: typeof listener = (event) => {
      if (event.sessionId !== this.sessionId) {
        return
      }
      listener(event)
    }
    this.listeners.set(
      listener as ChromeEventListener,
      filteredListener as ChromeEventListener
    )
    return this.transport.on(name, filteredListener as ChromeEventListener)
  }
  off<K extends keyof DeviceAccess.EventMap>(
    name: K,
    listener: (event: ChromeEvent<DeviceAccess.EventMap[K]>) => void
  ): void {
    const filteredListener = this.listeners.get(listener as ChromeEventListener)
    if (filteredListener === undefined) {
      return
    }
    this.listeners.delete(listener as ChromeEventListener)
    return this.transport.off(name, filteredListener)
  }
}
class PreloadClient {
  private transport: Transport
  private sessionId: Target.SessionID | undefined
  private listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  async enable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Preload.enable',
      params: {},
    })
  }
  async disable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Preload.disable',
      params: {},
    })
  }
  on<K extends keyof Preload.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Preload.EventMap[K]>) => void
  ): () => void {
    const filteredListener: typeof listener = (event) => {
      if (event.sessionId !== this.sessionId) {
        return
      }
      listener(event)
    }
    this.listeners.set(
      listener as ChromeEventListener,
      filteredListener as ChromeEventListener
    )
    return this.transport.on(name, filteredListener as ChromeEventListener)
  }
  off<K extends keyof Preload.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Preload.EventMap[K]>) => void
  ): void {
    const filteredListener = this.listeners.get(listener as ChromeEventListener)
    if (filteredListener === undefined) {
      return
    }
    this.listeners.delete(listener as ChromeEventListener)
    return this.transport.off(name, filteredListener)
  }
}
class FedCmClient {
  private transport: Transport
  private sessionId: Target.SessionID | undefined
  private listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  async enable(disableRejectionDelay?: boolean): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'FedCm.enable',
      params: { disableRejectionDelay: disableRejectionDelay },
    })
  }
  async disable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'FedCm.disable',
      params: {},
    })
  }
  async selectAccount(dialogId: string, accountIndex: number): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'FedCm.selectAccount',
      params: { dialogId: dialogId, accountIndex: accountIndex },
    })
  }
  async clickDialogButton(
    dialogId: string,
    dialogButton: FedCm.DialogButton
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'FedCm.clickDialogButton',
      params: { dialogId: dialogId, dialogButton: dialogButton },
    })
  }
  async openUrl(
    dialogId: string,
    accountIndex: number,
    accountUrlType: FedCm.AccountUrlType
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'FedCm.openUrl',
      params: {
        dialogId: dialogId,
        accountIndex: accountIndex,
        accountUrlType: accountUrlType,
      },
    })
  }
  async dismissDialog(
    dialogId: string,
    triggerCooldown?: boolean
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'FedCm.dismissDialog',
      params: { dialogId: dialogId, triggerCooldown: triggerCooldown },
    })
  }
  async resetCooldown(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'FedCm.resetCooldown',
      params: {},
    })
  }
  on<K extends keyof FedCm.EventMap>(
    name: K,
    listener: (event: ChromeEvent<FedCm.EventMap[K]>) => void
  ): () => void {
    const filteredListener: typeof listener = (event) => {
      if (event.sessionId !== this.sessionId) {
        return
      }
      listener(event)
    }
    this.listeners.set(
      listener as ChromeEventListener,
      filteredListener as ChromeEventListener
    )
    return this.transport.on(name, filteredListener as ChromeEventListener)
  }
  off<K extends keyof FedCm.EventMap>(
    name: K,
    listener: (event: ChromeEvent<FedCm.EventMap[K]>) => void
  ): void {
    const filteredListener = this.listeners.get(listener as ChromeEventListener)
    if (filteredListener === undefined) {
      return
    }
    this.listeners.delete(listener as ChromeEventListener)
    return this.transport.off(name, filteredListener)
  }
}
class PWAClient {
  private transport: Transport
  private sessionId: Target.SessionID | undefined
  private listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  async getOsAppState(manifestId: string): Promise<PWA.GetOsAppStateResult> {
    return this.transport.call<PWA.GetOsAppStateResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'PWA.getOsAppState',
      params: { manifestId: manifestId },
    })
  }
  async install(
    manifestId: string,
    installUrlOrBundleUrl?: string
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'PWA.install',
      params: {
        manifestId: manifestId,
        installUrlOrBundleUrl: installUrlOrBundleUrl,
      },
    })
  }
  async uninstall(manifestId: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'PWA.uninstall',
      params: { manifestId: manifestId },
    })
  }
  async launch(manifestId: string, url?: string): Promise<PWA.LaunchResult> {
    return this.transport.call<PWA.LaunchResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'PWA.launch',
      params: { manifestId: manifestId, url: url },
    })
  }
  async launchFilesInApp(
    manifestId: string,
    files: string[]
  ): Promise<PWA.LaunchFilesInAppResult> {
    return this.transport.call<PWA.LaunchFilesInAppResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'PWA.launchFilesInApp',
      params: { manifestId: manifestId, files: files },
    })
  }
  async openCurrentPageInApp(manifestId: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'PWA.openCurrentPageInApp',
      params: { manifestId: manifestId },
    })
  }
  async changeAppUserSettings(
    manifestId: string,
    linkCapturing?: boolean,
    displayMode?: PWA.DisplayMode
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'PWA.changeAppUserSettings',
      params: {
        manifestId: manifestId,
        linkCapturing: linkCapturing,
        displayMode: displayMode,
      },
    })
  }
}
class BluetoothEmulationClient {
  private transport: Transport
  private sessionId: Target.SessionID | undefined
  private listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  async enable(
    state: BluetoothEmulation.CentralState,
    leSupported: boolean
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'BluetoothEmulation.enable',
      params: { state: state, leSupported: leSupported },
    })
  }
  async setSimulatedCentralState(
    state: BluetoothEmulation.CentralState
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'BluetoothEmulation.setSimulatedCentralState',
      params: { state: state },
    })
  }
  async disable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'BluetoothEmulation.disable',
      params: {},
    })
  }
  async simulatePreconnectedPeripheral(
    address: string,
    name: string,
    manufacturerData: BluetoothEmulation.ManufacturerData[],
    knownServiceUuids: string[]
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'BluetoothEmulation.simulatePreconnectedPeripheral',
      params: {
        address: address,
        name: name,
        manufacturerData: manufacturerData,
        knownServiceUuids: knownServiceUuids,
      },
    })
  }
  async simulateAdvertisement(
    entry: BluetoothEmulation.ScanEntry
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'BluetoothEmulation.simulateAdvertisement',
      params: { entry: entry },
    })
  }
  async simulateGATTOperationResponse(
    address: string,
    type: BluetoothEmulation.GATTOperationType,
    code: number
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'BluetoothEmulation.simulateGATTOperationResponse',
      params: { address: address, type: type, code: code },
    })
  }
  async simulateCharacteristicOperationResponse(
    characteristicId: string,
    type: BluetoothEmulation.CharacteristicOperationType,
    code: number,
    data?: string
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'BluetoothEmulation.simulateCharacteristicOperationResponse',
      params: {
        characteristicId: characteristicId,
        type: type,
        code: code,
        data: data,
      },
    })
  }
  async simulateDescriptorOperationResponse(
    descriptorId: string,
    type: BluetoothEmulation.DescriptorOperationType,
    code: number,
    data?: string
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'BluetoothEmulation.simulateDescriptorOperationResponse',
      params: {
        descriptorId: descriptorId,
        type: type,
        code: code,
        data: data,
      },
    })
  }
  async addService(
    address: string,
    serviceUuid: string
  ): Promise<BluetoothEmulation.AddServiceResult> {
    return this.transport.call<BluetoothEmulation.AddServiceResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'BluetoothEmulation.addService',
      params: { address: address, serviceUuid: serviceUuid },
    })
  }
  async removeService(serviceId: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'BluetoothEmulation.removeService',
      params: { serviceId: serviceId },
    })
  }
  async addCharacteristic(
    serviceId: string,
    characteristicUuid: string,
    properties: BluetoothEmulation.CharacteristicProperties
  ): Promise<BluetoothEmulation.AddCharacteristicResult> {
    return this.transport.call<BluetoothEmulation.AddCharacteristicResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'BluetoothEmulation.addCharacteristic',
      params: {
        serviceId: serviceId,
        characteristicUuid: characteristicUuid,
        properties: properties,
      },
    })
  }
  async removeCharacteristic(characteristicId: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'BluetoothEmulation.removeCharacteristic',
      params: { characteristicId: characteristicId },
    })
  }
  async addDescriptor(
    characteristicId: string,
    descriptorUuid: string
  ): Promise<BluetoothEmulation.AddDescriptorResult> {
    return this.transport.call<BluetoothEmulation.AddDescriptorResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'BluetoothEmulation.addDescriptor',
      params: {
        characteristicId: characteristicId,
        descriptorUuid: descriptorUuid,
      },
    })
  }
  async removeDescriptor(descriptorId: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'BluetoothEmulation.removeDescriptor',
      params: { descriptorId: descriptorId },
    })
  }
  async simulateGATTDisconnection(address: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'BluetoothEmulation.simulateGATTDisconnection',
      params: { address: address },
    })
  }
  on<K extends keyof BluetoothEmulation.EventMap>(
    name: K,
    listener: (event: ChromeEvent<BluetoothEmulation.EventMap[K]>) => void
  ): () => void {
    const filteredListener: typeof listener = (event) => {
      if (event.sessionId !== this.sessionId) {
        return
      }
      listener(event)
    }
    this.listeners.set(
      listener as ChromeEventListener,
      filteredListener as ChromeEventListener
    )
    return this.transport.on(name, filteredListener as ChromeEventListener)
  }
  off<K extends keyof BluetoothEmulation.EventMap>(
    name: K,
    listener: (event: ChromeEvent<BluetoothEmulation.EventMap[K]>) => void
  ): void {
    const filteredListener = this.listeners.get(listener as ChromeEventListener)
    if (filteredListener === undefined) {
      return
    }
    this.listeners.delete(listener as ChromeEventListener)
    return this.transport.off(name, filteredListener)
  }
}
class ConsoleClient {
  private transport: Transport
  private sessionId: Target.SessionID | undefined
  private listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  async clearMessages(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Console.clearMessages',
      params: {},
    })
  }
  async disable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Console.disable',
      params: {},
    })
  }
  async enable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Console.enable',
      params: {},
    })
  }
  on<K extends keyof Console.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Console.EventMap[K]>) => void
  ): () => void {
    const filteredListener: typeof listener = (event) => {
      if (event.sessionId !== this.sessionId) {
        return
      }
      listener(event)
    }
    this.listeners.set(
      listener as ChromeEventListener,
      filteredListener as ChromeEventListener
    )
    return this.transport.on(name, filteredListener as ChromeEventListener)
  }
  off<K extends keyof Console.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Console.EventMap[K]>) => void
  ): void {
    const filteredListener = this.listeners.get(listener as ChromeEventListener)
    if (filteredListener === undefined) {
      return
    }
    this.listeners.delete(listener as ChromeEventListener)
    return this.transport.off(name, filteredListener)
  }
}
class DebuggerClient {
  private transport: Transport
  private sessionId: Target.SessionID | undefined
  private listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  async continueToLocation(
    location: Debugger.Location,
    targetCallFrames?: string
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Debugger.continueToLocation',
      params: { location: location, targetCallFrames: targetCallFrames },
    })
  }
  async disable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Debugger.disable',
      params: {},
    })
  }
  async enable(maxScriptsCacheSize?: number): Promise<Debugger.EnableResult> {
    return this.transport.call<Debugger.EnableResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Debugger.enable',
      params: { maxScriptsCacheSize: maxScriptsCacheSize },
    })
  }
  async evaluateOnCallFrame(
    callFrameId: Debugger.CallFrameId,
    expression: string,
    objectGroup?: string,
    includeCommandLineAPI?: boolean,
    silent?: boolean,
    returnByValue?: boolean,
    generatePreview?: boolean,
    throwOnSideEffect?: boolean,
    timeout?: Runtime.TimeDelta
  ): Promise<Debugger.EvaluateOnCallFrameResult> {
    return this.transport.call<Debugger.EvaluateOnCallFrameResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Debugger.evaluateOnCallFrame',
      params: {
        callFrameId: callFrameId,
        expression: expression,
        objectGroup: objectGroup,
        includeCommandLineAPI: includeCommandLineAPI,
        silent: silent,
        returnByValue: returnByValue,
        generatePreview: generatePreview,
        throwOnSideEffect: throwOnSideEffect,
        timeout: timeout,
      },
    })
  }
  async getPossibleBreakpoints(
    start: Debugger.Location,
    end?: Debugger.Location,
    restrictToFunction?: boolean
  ): Promise<Debugger.GetPossibleBreakpointsResult> {
    return this.transport.call<Debugger.GetPossibleBreakpointsResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Debugger.getPossibleBreakpoints',
      params: {
        start: start,
        end: end,
        restrictToFunction: restrictToFunction,
      },
    })
  }
  async getScriptSource(
    scriptId: Runtime.ScriptId
  ): Promise<Debugger.GetScriptSourceResult> {
    return this.transport.call<Debugger.GetScriptSourceResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Debugger.getScriptSource',
      params: { scriptId: scriptId },
    })
  }
  async disassembleWasmModule(
    scriptId: Runtime.ScriptId
  ): Promise<Debugger.DisassembleWasmModuleResult> {
    return this.transport.call<Debugger.DisassembleWasmModuleResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Debugger.disassembleWasmModule',
      params: { scriptId: scriptId },
    })
  }
  async nextWasmDisassemblyChunk(
    streamId: string
  ): Promise<Debugger.NextWasmDisassemblyChunkResult> {
    return this.transport.call<Debugger.NextWasmDisassemblyChunkResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Debugger.nextWasmDisassemblyChunk',
      params: { streamId: streamId },
    })
  }
  async getWasmBytecode(
    scriptId: Runtime.ScriptId
  ): Promise<Debugger.GetWasmBytecodeResult> {
    return this.transport.call<Debugger.GetWasmBytecodeResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Debugger.getWasmBytecode',
      params: { scriptId: scriptId },
    })
  }
  async getStackTrace(
    stackTraceId: Runtime.StackTraceId
  ): Promise<Debugger.GetStackTraceResult> {
    return this.transport.call<Debugger.GetStackTraceResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Debugger.getStackTrace',
      params: { stackTraceId: stackTraceId },
    })
  }
  async pause(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Debugger.pause',
      params: {},
    })
  }
  async pauseOnAsyncCall(
    parentStackTraceId: Runtime.StackTraceId
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Debugger.pauseOnAsyncCall',
      params: { parentStackTraceId: parentStackTraceId },
    })
  }
  async removeBreakpoint(breakpointId: Debugger.BreakpointId): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Debugger.removeBreakpoint',
      params: { breakpointId: breakpointId },
    })
  }
  async restartFrame(
    callFrameId: Debugger.CallFrameId,
    mode?: string
  ): Promise<Debugger.RestartFrameResult> {
    return this.transport.call<Debugger.RestartFrameResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Debugger.restartFrame',
      params: { callFrameId: callFrameId, mode: mode },
    })
  }
  async resume(terminateOnResume?: boolean): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Debugger.resume',
      params: { terminateOnResume: terminateOnResume },
    })
  }
  async searchInContent(
    scriptId: Runtime.ScriptId,
    query: string,
    caseSensitive?: boolean,
    isRegex?: boolean
  ): Promise<Debugger.SearchInContentResult> {
    return this.transport.call<Debugger.SearchInContentResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Debugger.searchInContent',
      params: {
        scriptId: scriptId,
        query: query,
        caseSensitive: caseSensitive,
        isRegex: isRegex,
      },
    })
  }
  async setAsyncCallStackDepth(maxDepth: number): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Debugger.setAsyncCallStackDepth',
      params: { maxDepth: maxDepth },
    })
  }
  async setBlackboxExecutionContexts(uniqueIds: string[]): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Debugger.setBlackboxExecutionContexts',
      params: { uniqueIds: uniqueIds },
    })
  }
  async setBlackboxPatterns(
    patterns: string[],
    skipAnonymous?: boolean
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Debugger.setBlackboxPatterns',
      params: { patterns: patterns, skipAnonymous: skipAnonymous },
    })
  }
  async setBlackboxedRanges(
    scriptId: Runtime.ScriptId,
    positions: Debugger.ScriptPosition[]
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Debugger.setBlackboxedRanges',
      params: { scriptId: scriptId, positions: positions },
    })
  }
  async setBreakpoint(
    location: Debugger.Location,
    condition?: string
  ): Promise<Debugger.SetBreakpointResult> {
    return this.transport.call<Debugger.SetBreakpointResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Debugger.setBreakpoint',
      params: { location: location, condition: condition },
    })
  }
  async setInstrumentationBreakpoint(
    instrumentation: string
  ): Promise<Debugger.SetInstrumentationBreakpointResult> {
    return this.transport.call<Debugger.SetInstrumentationBreakpointResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Debugger.setInstrumentationBreakpoint',
      params: { instrumentation: instrumentation },
    })
  }
  async setBreakpointByUrl(
    lineNumber: number,
    url?: string,
    urlRegex?: string,
    scriptHash?: string,
    columnNumber?: number,
    condition?: string
  ): Promise<Debugger.SetBreakpointByUrlResult> {
    return this.transport.call<Debugger.SetBreakpointByUrlResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Debugger.setBreakpointByUrl',
      params: {
        lineNumber: lineNumber,
        url: url,
        urlRegex: urlRegex,
        scriptHash: scriptHash,
        columnNumber: columnNumber,
        condition: condition,
      },
    })
  }
  async setBreakpointOnFunctionCall(
    objectId: Runtime.RemoteObjectId,
    condition?: string
  ): Promise<Debugger.SetBreakpointOnFunctionCallResult> {
    return this.transport.call<Debugger.SetBreakpointOnFunctionCallResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Debugger.setBreakpointOnFunctionCall',
      params: { objectId: objectId, condition: condition },
    })
  }
  async setBreakpointsActive(active: boolean): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Debugger.setBreakpointsActive',
      params: { active: active },
    })
  }
  async setPauseOnExceptions(state: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Debugger.setPauseOnExceptions',
      params: { state: state },
    })
  }
  async setReturnValue(newValue: Runtime.CallArgument): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Debugger.setReturnValue',
      params: { newValue: newValue },
    })
  }
  async setScriptSource(
    scriptId: Runtime.ScriptId,
    scriptSource: string,
    dryRun?: boolean,
    allowTopFrameEditing?: boolean
  ): Promise<Debugger.SetScriptSourceResult> {
    return this.transport.call<Debugger.SetScriptSourceResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Debugger.setScriptSource',
      params: {
        scriptId: scriptId,
        scriptSource: scriptSource,
        dryRun: dryRun,
        allowTopFrameEditing: allowTopFrameEditing,
      },
    })
  }
  async setSkipAllPauses(skip: boolean): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Debugger.setSkipAllPauses',
      params: { skip: skip },
    })
  }
  async setVariableValue(
    scopeNumber: number,
    variableName: string,
    newValue: Runtime.CallArgument,
    callFrameId: Debugger.CallFrameId
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Debugger.setVariableValue',
      params: {
        scopeNumber: scopeNumber,
        variableName: variableName,
        newValue: newValue,
        callFrameId: callFrameId,
      },
    })
  }
  async stepInto(
    breakOnAsyncCall?: boolean,
    skipList?: Debugger.LocationRange[]
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Debugger.stepInto',
      params: { breakOnAsyncCall: breakOnAsyncCall, skipList: skipList },
    })
  }
  async stepOut(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Debugger.stepOut',
      params: {},
    })
  }
  async stepOver(skipList?: Debugger.LocationRange[]): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Debugger.stepOver',
      params: { skipList: skipList },
    })
  }
  on<K extends keyof Debugger.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Debugger.EventMap[K]>) => void
  ): () => void {
    const filteredListener: typeof listener = (event) => {
      if (event.sessionId !== this.sessionId) {
        return
      }
      listener(event)
    }
    this.listeners.set(
      listener as ChromeEventListener,
      filteredListener as ChromeEventListener
    )
    return this.transport.on(name, filteredListener as ChromeEventListener)
  }
  off<K extends keyof Debugger.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Debugger.EventMap[K]>) => void
  ): void {
    const filteredListener = this.listeners.get(listener as ChromeEventListener)
    if (filteredListener === undefined) {
      return
    }
    this.listeners.delete(listener as ChromeEventListener)
    return this.transport.off(name, filteredListener)
  }
}
class HeapProfilerClient {
  private transport: Transport
  private sessionId: Target.SessionID | undefined
  private listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  async addInspectedHeapObject(
    heapObjectId: HeapProfiler.HeapSnapshotObjectId
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'HeapProfiler.addInspectedHeapObject',
      params: { heapObjectId: heapObjectId },
    })
  }
  async collectGarbage(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'HeapProfiler.collectGarbage',
      params: {},
    })
  }
  async disable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'HeapProfiler.disable',
      params: {},
    })
  }
  async enable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'HeapProfiler.enable',
      params: {},
    })
  }
  async getHeapObjectId(
    objectId: Runtime.RemoteObjectId
  ): Promise<HeapProfiler.GetHeapObjectIdResult> {
    return this.transport.call<HeapProfiler.GetHeapObjectIdResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'HeapProfiler.getHeapObjectId',
      params: { objectId: objectId },
    })
  }
  async getObjectByHeapObjectId(
    objectId: HeapProfiler.HeapSnapshotObjectId,
    objectGroup?: string
  ): Promise<HeapProfiler.GetObjectByHeapObjectIdResult> {
    return this.transport.call<HeapProfiler.GetObjectByHeapObjectIdResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'HeapProfiler.getObjectByHeapObjectId',
      params: { objectId: objectId, objectGroup: objectGroup },
    })
  }
  async getSamplingProfile(): Promise<HeapProfiler.GetSamplingProfileResult> {
    return this.transport.call<HeapProfiler.GetSamplingProfileResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'HeapProfiler.getSamplingProfile',
      params: {},
    })
  }
  async startSampling(
    samplingInterval?: number,
    includeObjectsCollectedByMajorGC?: boolean,
    includeObjectsCollectedByMinorGC?: boolean
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'HeapProfiler.startSampling',
      params: {
        samplingInterval: samplingInterval,
        includeObjectsCollectedByMajorGC: includeObjectsCollectedByMajorGC,
        includeObjectsCollectedByMinorGC: includeObjectsCollectedByMinorGC,
      },
    })
  }
  async startTrackingHeapObjects(trackAllocations?: boolean): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'HeapProfiler.startTrackingHeapObjects',
      params: { trackAllocations: trackAllocations },
    })
  }
  async stopSampling(): Promise<HeapProfiler.StopSamplingResult> {
    return this.transport.call<HeapProfiler.StopSamplingResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'HeapProfiler.stopSampling',
      params: {},
    })
  }
  async stopTrackingHeapObjects(
    reportProgress?: boolean,
    treatGlobalObjectsAsRoots?: boolean,
    captureNumericValue?: boolean,
    exposeInternals?: boolean
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'HeapProfiler.stopTrackingHeapObjects',
      params: {
        reportProgress: reportProgress,
        treatGlobalObjectsAsRoots: treatGlobalObjectsAsRoots,
        captureNumericValue: captureNumericValue,
        exposeInternals: exposeInternals,
      },
    })
  }
  async takeHeapSnapshot(
    reportProgress?: boolean,
    treatGlobalObjectsAsRoots?: boolean,
    captureNumericValue?: boolean,
    exposeInternals?: boolean
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'HeapProfiler.takeHeapSnapshot',
      params: {
        reportProgress: reportProgress,
        treatGlobalObjectsAsRoots: treatGlobalObjectsAsRoots,
        captureNumericValue: captureNumericValue,
        exposeInternals: exposeInternals,
      },
    })
  }
  on<K extends keyof HeapProfiler.EventMap>(
    name: K,
    listener: (event: ChromeEvent<HeapProfiler.EventMap[K]>) => void
  ): () => void {
    const filteredListener: typeof listener = (event) => {
      if (event.sessionId !== this.sessionId) {
        return
      }
      listener(event)
    }
    this.listeners.set(
      listener as ChromeEventListener,
      filteredListener as ChromeEventListener
    )
    return this.transport.on(name, filteredListener as ChromeEventListener)
  }
  off<K extends keyof HeapProfiler.EventMap>(
    name: K,
    listener: (event: ChromeEvent<HeapProfiler.EventMap[K]>) => void
  ): void {
    const filteredListener = this.listeners.get(listener as ChromeEventListener)
    if (filteredListener === undefined) {
      return
    }
    this.listeners.delete(listener as ChromeEventListener)
    return this.transport.off(name, filteredListener)
  }
}
class ProfilerClient {
  private transport: Transport
  private sessionId: Target.SessionID | undefined
  private listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  async disable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Profiler.disable',
      params: {},
    })
  }
  async enable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Profiler.enable',
      params: {},
    })
  }
  async getBestEffortCoverage(): Promise<Profiler.GetBestEffortCoverageResult> {
    return this.transport.call<Profiler.GetBestEffortCoverageResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Profiler.getBestEffortCoverage',
      params: {},
    })
  }
  async setSamplingInterval(interval: number): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Profiler.setSamplingInterval',
      params: { interval: interval },
    })
  }
  async start(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Profiler.start',
      params: {},
    })
  }
  async startPreciseCoverage(
    callCount?: boolean,
    detailed?: boolean,
    allowTriggeredUpdates?: boolean
  ): Promise<Profiler.StartPreciseCoverageResult> {
    return this.transport.call<Profiler.StartPreciseCoverageResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Profiler.startPreciseCoverage',
      params: {
        callCount: callCount,
        detailed: detailed,
        allowTriggeredUpdates: allowTriggeredUpdates,
      },
    })
  }
  async stop(): Promise<Profiler.StopResult> {
    return this.transport.call<Profiler.StopResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Profiler.stop',
      params: {},
    })
  }
  async stopPreciseCoverage(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Profiler.stopPreciseCoverage',
      params: {},
    })
  }
  async takePreciseCoverage(): Promise<Profiler.TakePreciseCoverageResult> {
    return this.transport.call<Profiler.TakePreciseCoverageResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Profiler.takePreciseCoverage',
      params: {},
    })
  }
  on<K extends keyof Profiler.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Profiler.EventMap[K]>) => void
  ): () => void {
    const filteredListener: typeof listener = (event) => {
      if (event.sessionId !== this.sessionId) {
        return
      }
      listener(event)
    }
    this.listeners.set(
      listener as ChromeEventListener,
      filteredListener as ChromeEventListener
    )
    return this.transport.on(name, filteredListener as ChromeEventListener)
  }
  off<K extends keyof Profiler.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Profiler.EventMap[K]>) => void
  ): void {
    const filteredListener = this.listeners.get(listener as ChromeEventListener)
    if (filteredListener === undefined) {
      return
    }
    this.listeners.delete(listener as ChromeEventListener)
    return this.transport.off(name, filteredListener)
  }
}
class RuntimeClient {
  private transport: Transport
  private sessionId: Target.SessionID | undefined
  private listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  async awaitPromise(
    promiseObjectId: Runtime.RemoteObjectId,
    returnByValue?: boolean,
    generatePreview?: boolean
  ): Promise<Runtime.AwaitPromiseResult> {
    return this.transport.call<Runtime.AwaitPromiseResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Runtime.awaitPromise',
      params: {
        promiseObjectId: promiseObjectId,
        returnByValue: returnByValue,
        generatePreview: generatePreview,
      },
    })
  }
  async callFunctionOn(
    functionDeclaration: string,
    objectId?: Runtime.RemoteObjectId,
    arguments_?: Runtime.CallArgument[],
    silent?: boolean,
    returnByValue?: boolean,
    generatePreview?: boolean,
    userGesture?: boolean,
    awaitPromise?: boolean,
    executionContextId?: Runtime.ExecutionContextId,
    objectGroup?: string,
    throwOnSideEffect?: boolean,
    uniqueContextId?: string,
    serializationOptions?: Runtime.SerializationOptions
  ): Promise<Runtime.CallFunctionOnResult> {
    return this.transport.call<Runtime.CallFunctionOnResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Runtime.callFunctionOn',
      params: {
        functionDeclaration: functionDeclaration,
        objectId: objectId,
        arguments: arguments_,
        silent: silent,
        returnByValue: returnByValue,
        generatePreview: generatePreview,
        userGesture: userGesture,
        awaitPromise: awaitPromise,
        executionContextId: executionContextId,
        objectGroup: objectGroup,
        throwOnSideEffect: throwOnSideEffect,
        uniqueContextId: uniqueContextId,
        serializationOptions: serializationOptions,
      },
    })
  }
  async compileScript(
    expression: string,
    sourceURL: string,
    persistScript: boolean,
    executionContextId?: Runtime.ExecutionContextId
  ): Promise<Runtime.CompileScriptResult> {
    return this.transport.call<Runtime.CompileScriptResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Runtime.compileScript',
      params: {
        expression: expression,
        sourceURL: sourceURL,
        persistScript: persistScript,
        executionContextId: executionContextId,
      },
    })
  }
  async disable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Runtime.disable',
      params: {},
    })
  }
  async discardConsoleEntries(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Runtime.discardConsoleEntries',
      params: {},
    })
  }
  async enable(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Runtime.enable',
      params: {},
    })
  }
  async evaluate(
    expression: string,
    objectGroup?: string,
    includeCommandLineAPI?: boolean,
    silent?: boolean,
    contextId?: Runtime.ExecutionContextId,
    returnByValue?: boolean,
    generatePreview?: boolean,
    userGesture?: boolean,
    awaitPromise?: boolean,
    throwOnSideEffect?: boolean,
    timeout?: Runtime.TimeDelta,
    disableBreaks?: boolean,
    replMode?: boolean,
    allowUnsafeEvalBlockedByCSP?: boolean,
    uniqueContextId?: string,
    serializationOptions?: Runtime.SerializationOptions
  ): Promise<Runtime.EvaluateResult> {
    return this.transport.call<Runtime.EvaluateResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Runtime.evaluate',
      params: {
        expression: expression,
        objectGroup: objectGroup,
        includeCommandLineAPI: includeCommandLineAPI,
        silent: silent,
        contextId: contextId,
        returnByValue: returnByValue,
        generatePreview: generatePreview,
        userGesture: userGesture,
        awaitPromise: awaitPromise,
        throwOnSideEffect: throwOnSideEffect,
        timeout: timeout,
        disableBreaks: disableBreaks,
        replMode: replMode,
        allowUnsafeEvalBlockedByCSP: allowUnsafeEvalBlockedByCSP,
        uniqueContextId: uniqueContextId,
        serializationOptions: serializationOptions,
      },
    })
  }
  async getIsolateId(): Promise<Runtime.GetIsolateIdResult> {
    return this.transport.call<Runtime.GetIsolateIdResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Runtime.getIsolateId',
      params: {},
    })
  }
  async getHeapUsage(): Promise<Runtime.GetHeapUsageResult> {
    return this.transport.call<Runtime.GetHeapUsageResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Runtime.getHeapUsage',
      params: {},
    })
  }
  async getProperties(
    objectId: Runtime.RemoteObjectId,
    ownProperties?: boolean,
    accessorPropertiesOnly?: boolean,
    generatePreview?: boolean,
    nonIndexedPropertiesOnly?: boolean
  ): Promise<Runtime.GetPropertiesResult> {
    return this.transport.call<Runtime.GetPropertiesResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Runtime.getProperties',
      params: {
        objectId: objectId,
        ownProperties: ownProperties,
        accessorPropertiesOnly: accessorPropertiesOnly,
        generatePreview: generatePreview,
        nonIndexedPropertiesOnly: nonIndexedPropertiesOnly,
      },
    })
  }
  async globalLexicalScopeNames(
    executionContextId?: Runtime.ExecutionContextId
  ): Promise<Runtime.GlobalLexicalScopeNamesResult> {
    return this.transport.call<Runtime.GlobalLexicalScopeNamesResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Runtime.globalLexicalScopeNames',
      params: { executionContextId: executionContextId },
    })
  }
  async queryObjects(
    prototypeObjectId: Runtime.RemoteObjectId,
    objectGroup?: string
  ): Promise<Runtime.QueryObjectsResult> {
    return this.transport.call<Runtime.QueryObjectsResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Runtime.queryObjects',
      params: {
        prototypeObjectId: prototypeObjectId,
        objectGroup: objectGroup,
      },
    })
  }
  async releaseObject(objectId: Runtime.RemoteObjectId): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Runtime.releaseObject',
      params: { objectId: objectId },
    })
  }
  async releaseObjectGroup(objectGroup: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Runtime.releaseObjectGroup',
      params: { objectGroup: objectGroup },
    })
  }
  async runIfWaitingForDebugger(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Runtime.runIfWaitingForDebugger',
      params: {},
    })
  }
  async runScript(
    scriptId: Runtime.ScriptId,
    executionContextId?: Runtime.ExecutionContextId,
    objectGroup?: string,
    silent?: boolean,
    includeCommandLineAPI?: boolean,
    returnByValue?: boolean,
    generatePreview?: boolean,
    awaitPromise?: boolean
  ): Promise<Runtime.RunScriptResult> {
    return this.transport.call<Runtime.RunScriptResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Runtime.runScript',
      params: {
        scriptId: scriptId,
        executionContextId: executionContextId,
        objectGroup: objectGroup,
        silent: silent,
        includeCommandLineAPI: includeCommandLineAPI,
        returnByValue: returnByValue,
        generatePreview: generatePreview,
        awaitPromise: awaitPromise,
      },
    })
  }
  async setAsyncCallStackDepth(maxDepth: number): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Runtime.setAsyncCallStackDepth',
      params: { maxDepth: maxDepth },
    })
  }
  async setCustomObjectFormatterEnabled(enabled: boolean): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Runtime.setCustomObjectFormatterEnabled',
      params: { enabled: enabled },
    })
  }
  async setMaxCallStackSizeToCapture(size: number): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Runtime.setMaxCallStackSizeToCapture',
      params: { size: size },
    })
  }
  async terminateExecution(): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Runtime.terminateExecution',
      params: {},
    })
  }
  async addBinding(
    name: string,
    executionContextId?: Runtime.ExecutionContextId,
    executionContextName?: string
  ): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Runtime.addBinding',
      params: {
        name: name,
        executionContextId: executionContextId,
        executionContextName: executionContextName,
      },
    })
  }
  async removeBinding(name: string): Promise<void> {
    return this.transport.call<void>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Runtime.removeBinding',
      params: { name: name },
    })
  }
  async getExceptionDetails(
    errorObjectId: Runtime.RemoteObjectId
  ): Promise<Runtime.GetExceptionDetailsResult> {
    return this.transport.call<Runtime.GetExceptionDetailsResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Runtime.getExceptionDetails',
      params: { errorObjectId: errorObjectId },
    })
  }
  on<K extends keyof Runtime.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Runtime.EventMap[K]>) => void
  ): () => void {
    const filteredListener: typeof listener = (event) => {
      if (event.sessionId !== this.sessionId) {
        return
      }
      listener(event)
    }
    this.listeners.set(
      listener as ChromeEventListener,
      filteredListener as ChromeEventListener
    )
    return this.transport.on(name, filteredListener as ChromeEventListener)
  }
  off<K extends keyof Runtime.EventMap>(
    name: K,
    listener: (event: ChromeEvent<Runtime.EventMap[K]>) => void
  ): void {
    const filteredListener = this.listeners.get(listener as ChromeEventListener)
    if (filteredListener === undefined) {
      return
    }
    this.listeners.delete(listener as ChromeEventListener)
    return this.transport.off(name, filteredListener)
  }
}
class SchemaClient {
  private transport: Transport
  private sessionId: Target.SessionID | undefined
  private listeners: WeakMap<ChromeEventListener, ChromeEventListener>
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.sessionId = sessionId
    this.listeners = new WeakMap()
  }
  async getDomains(): Promise<Schema.GetDomainsResult> {
    return this.transport.call<Schema.GetDomainsResult>({
      id: generateId(),
      sessionId: this.sessionId,
      method: 'Schema.getDomains',
      params: {},
    })
  }
}
export class ChromeDevToolsClient {
  private transport: Transport
  withSession(sessionId: Target.SessionID): ChromeDevToolsClient {
    return new ChromeDevToolsClient(this.transport, sessionId)
  }
  accessibility: AccessibilityClient
  animation: AnimationClient
  audits: AuditsClient
  extensions: ExtensionsClient
  autofill: AutofillClient
  backgroundService: BackgroundServiceClient
  browser: BrowserClient
  css: CSSClient
  cacheStorage: CacheStorageClient
  cast: CastClient
  dom: DOMClient
  domDebugger: DOMDebuggerClient
  eventBreakpoints: EventBreakpointsClient
  domSnapshot: DOMSnapshotClient
  domStorage: DOMStorageClient
  deviceOrientation: DeviceOrientationClient
  emulation: EmulationClient
  headlessExperimental: HeadlessExperimentalClient
  io: IOClient
  fileSystem: FileSystemClient
  indexedDB: IndexedDBClient
  input: InputClient
  inspector: InspectorClient
  layerTree: LayerTreeClient
  log: LogClient
  memory: MemoryClient
  network: NetworkClient
  overlay: OverlayClient
  page: PageClient
  performance: PerformanceClient
  performanceTimeline: PerformanceTimelineClient
  security: SecurityClient
  serviceWorker: ServiceWorkerClient
  storage: StorageClient
  systemInfo: SystemInfoClient
  target: TargetClient
  tethering: TetheringClient
  tracing: TracingClient
  fetch: FetchClient
  webAudio: WebAudioClient
  webAuthn: WebAuthnClient
  media: MediaClient
  deviceAccess: DeviceAccessClient
  preload: PreloadClient
  fedCm: FedCmClient
  pwa: PWAClient
  bluetoothEmulation: BluetoothEmulationClient
  console: ConsoleClient
  debugger: DebuggerClient
  heapProfiler: HeapProfilerClient
  profiler: ProfilerClient
  runtime: RuntimeClient
  schema: SchemaClient
  constructor(transport: Transport, sessionId?: Target.SessionID) {
    this.transport = transport
    this.accessibility = new AccessibilityClient(transport, sessionId)
    this.animation = new AnimationClient(transport, sessionId)
    this.audits = new AuditsClient(transport, sessionId)
    this.extensions = new ExtensionsClient(transport, sessionId)
    this.autofill = new AutofillClient(transport, sessionId)
    this.backgroundService = new BackgroundServiceClient(transport, sessionId)
    this.browser = new BrowserClient(transport, sessionId)
    this.css = new CSSClient(transport, sessionId)
    this.cacheStorage = new CacheStorageClient(transport, sessionId)
    this.cast = new CastClient(transport, sessionId)
    this.dom = new DOMClient(transport, sessionId)
    this.domDebugger = new DOMDebuggerClient(transport, sessionId)
    this.eventBreakpoints = new EventBreakpointsClient(transport, sessionId)
    this.domSnapshot = new DOMSnapshotClient(transport, sessionId)
    this.domStorage = new DOMStorageClient(transport, sessionId)
    this.deviceOrientation = new DeviceOrientationClient(transport, sessionId)
    this.emulation = new EmulationClient(transport, sessionId)
    this.headlessExperimental = new HeadlessExperimentalClient(
      transport,
      sessionId
    )
    this.io = new IOClient(transport, sessionId)
    this.fileSystem = new FileSystemClient(transport, sessionId)
    this.indexedDB = new IndexedDBClient(transport, sessionId)
    this.input = new InputClient(transport, sessionId)
    this.inspector = new InspectorClient(transport, sessionId)
    this.layerTree = new LayerTreeClient(transport, sessionId)
    this.log = new LogClient(transport, sessionId)
    this.memory = new MemoryClient(transport, sessionId)
    this.network = new NetworkClient(transport, sessionId)
    this.overlay = new OverlayClient(transport, sessionId)
    this.page = new PageClient(transport, sessionId)
    this.performance = new PerformanceClient(transport, sessionId)
    this.performanceTimeline = new PerformanceTimelineClient(
      transport,
      sessionId
    )
    this.security = new SecurityClient(transport, sessionId)
    this.serviceWorker = new ServiceWorkerClient(transport, sessionId)
    this.storage = new StorageClient(transport, sessionId)
    this.systemInfo = new SystemInfoClient(transport, sessionId)
    this.target = new TargetClient(transport, sessionId)
    this.tethering = new TetheringClient(transport, sessionId)
    this.tracing = new TracingClient(transport, sessionId)
    this.fetch = new FetchClient(transport, sessionId)
    this.webAudio = new WebAudioClient(transport, sessionId)
    this.webAuthn = new WebAuthnClient(transport, sessionId)
    this.media = new MediaClient(transport, sessionId)
    this.deviceAccess = new DeviceAccessClient(transport, sessionId)
    this.preload = new PreloadClient(transport, sessionId)
    this.fedCm = new FedCmClient(transport, sessionId)
    this.pwa = new PWAClient(transport, sessionId)
    this.bluetoothEmulation = new BluetoothEmulationClient(transport, sessionId)
    this.console = new ConsoleClient(transport, sessionId)
    this.debugger = new DebuggerClient(transport, sessionId)
    this.heapProfiler = new HeapProfilerClient(transport, sessionId)
    this.profiler = new ProfilerClient(transport, sessionId)
    this.runtime = new RuntimeClient(transport, sessionId)
    this.schema = new SchemaClient(transport, sessionId)
  }
}
